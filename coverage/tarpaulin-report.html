<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","commitments","ajtai_commitment.rs"],"content":"use crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\nuse thiserror::Error;\n\n// Error types with documentation\n#[derive(Debug, Error)]\npub enum ParameterError {\n    #[error(\"parameters must be positive\")]\n    ZeroParameter,\n    #[error(\"security bound β·m^(3/2) must be less than q\")]\n    SecurityBoundViolation,\n    #[error(\"invalid witness bounds specified\")]\n    InvalidWitnessBounds(Zq),\n    #[error(\"commitment output length {0} is too large\")]\n    TooLargeCommitmentLength(usize),\n}\n\n#[derive(Debug, Error)]\npub enum CommitError {\n    #[error(\"witness coefficients exceed bound {0}\")]\n    InvalidWitnessBounds(Zq),\n    #[error(\"invalid witness vector size\")]\n    InvalidWitnessSize,\n}\n\n#[derive(Debug, Error)]\npub enum VerificationError {\n    #[error(\"witness coefficients exceed bound {0}\")]\n    InvalidWitnessBounds(Zq),\n    #[error(\"commitment does not match opening\")]\n    CommitmentMismatch,\n    #[error(\"invalid opening vector size\")]\n    InvalidOpeningSize,\n    #[error(\"invalid commitment vector size\")]\n    InvalidCommitmentSize,\n}\n\n/// Ajtai commitment scheme implementation with matrix-based operations\n#[derive(Debug)]\npub struct AjtaiScheme {\n    witness_bound: Zq,\n    random_matrix: RqMatrix,\n}\n\nimpl AjtaiScheme {\n    pub fn new(witness_bound: Zq, random_matrix: RqMatrix) -\u003e Result\u003cSelf, ParameterError\u003e {\n        if witness_bound.is_zero() {\n            return Err(ParameterError::InvalidWitnessBounds(witness_bound));\n        }\n        Self::validate_parameters(\n            witness_bound,\n            random_matrix.get_row_len(),\n            random_matrix.get_col_len(),\n        )?;\n\n        Ok(Self {\n            witness_bound,\n            random_matrix,\n        })\n    }\n\n    /// Generates commitment and opening information with bounds checking\n    pub fn commit(\u0026self, witness: \u0026RqVector) -\u003e Result\u003cRqVector, CommitError\u003e {\n        if !self.check_bounds(witness) {\n            return Err(CommitError::InvalidWitnessBounds(self.witness_bound));\n        }\n        if witness.get_length() != self.random_matrix.get_col_len() {\n            return Err(CommitError::InvalidWitnessSize);\n        }\n        let commitment = \u0026self.random_matrix * witness;\n        Ok(commitment)\n    }\n\n    /// Verifies commitment against opening information\n    pub fn verify(\n        \u0026self,\n        commitment: \u0026RqVector,\n        opening: \u0026RqVector,\n    ) -\u003e Result\u003c(), VerificationError\u003e {\n        if !self.check_bounds(opening) {\n            return Err(VerificationError::InvalidWitnessBounds(self.witness_bound));\n        }\n        if opening.get_length() != self.random_matrix.get_col_len() {\n            return Err(VerificationError::InvalidOpeningSize);\n        }\n        if commitment.get_length() != self.random_matrix.get_row_len() {\n            return Err(VerificationError::InvalidCommitmentSize);\n        }\n\n        let recomputed = \u0026self.random_matrix * opening;\n        if commitment != \u0026recomputed {\n            return Err(VerificationError::CommitmentMismatch);\n        }\n\n        Ok(())\n    }\n\n    /// Validates scheme parameters against cryptographic security requirements\n    fn validate_parameters(beta: Zq, row_len: usize, col_len: usize) -\u003e Result\u003c(), ParameterError\u003e {\n        if [row_len, col_len].contains(\u00260) {\n            return Err(ParameterError::ZeroParameter);\n        }\n        Self::verify_security_relation(beta, row_len)\n    }\n\n    /// Verifies the security relation β²m³ \u003c q² required for Ajtai's commitment scheme.\n    ///\n    /// This bound ensures the scheme's security by:\n    /// 1. Making the underlying lattice problem hard (SIS assumption)\n    /// 2. Preventing statistical attacks on the commitment\n    /// 3. Ensuring the commitment is binding under standard lattice assumptions\n    ///\n    /// The relation β²m³ \u003c q² is a necessary condition derived from the security\n    /// proof of Ajtai's commitment scheme, where:\n    /// - β bounds the size of witness coefficients\n    /// - m is the commitment output length\n    /// - q is the modulus of the underlying ring\n    fn verify_security_relation(beta: Zq, m: usize) -\u003e Result\u003c(), ParameterError\u003e {\n        // Calculate q from Zq properties\n        let q: u128 = Zq::NEG_ONE.to_u128() + 1;\n\n        // Calculate beta²\n        let beta_squared = beta\n            .to_u128()\n            .checked_pow(2)\n            .ok_or(ParameterError::SecurityBoundViolation)?;\n\n        // Calculate m³\n        let m_cubed: u128 = m\n            .checked_pow(3)\n            .ok_or(ParameterError::SecurityBoundViolation)?\n            .try_into()\n            .map_err(|_| ParameterError::TooLargeCommitmentLength(m))?;\n\n        // Calculate q²\n        let q_squared = q\n            .checked_pow(2)\n            .ok_or(ParameterError::SecurityBoundViolation)?;\n\n        // Check if beta² * m³ \u003c q²\n        // Use division instead of multiplication to avoid potential overflow\n        if beta_squared \u003e= q_squared.checked_div(m_cubed).unwrap_or(0) {\n            return Err(ParameterError::SecurityBoundViolation);\n        }\n\n        Ok(())\n    }\n\n    /// Checks polynomial coefficients against specified bound\n    fn check_bounds(\u0026self, _polynomials: \u0026RqVector) -\u003e bool {\n        // As now there are no concrete parameters, we return true.\n        true\n        // polynomials\n        //     .iter()\n        //     .all(|p| p.check_bounds(self.witness_bound))\n    }\n\n    /// Returns a reference to the internal matrix\n    pub fn matrix(\u0026self) -\u003e \u0026RqMatrix {\n        \u0026self.random_matrix\n    }\n\n    /// Returns the witness bound\n    pub fn witness_bound(\u0026self) -\u003e Zq {\n        self.witness_bound\n    }\n\n    pub fn get_row_size(\u0026self) -\u003e usize {\n        self.random_matrix.get_elements().len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::ring::rq::Rq;\n\n    const TEST_M: usize = 8;\n    const TEST_N: usize = 8;\n\n    // Test helpers\n    mod test_utils {\n        use crate::relation::witness::Witness;\n\n        use super::*;\n\n        pub fn valid_witness(scheme: \u0026AjtaiScheme) -\u003e RqVector {\n            vec![Rq::new([scheme.witness_bound(); Rq::DEGREE]); TEST_N].into()\n        }\n\n        pub fn random_valid_witness() -\u003e Vec\u003cRqVector\u003e {\n            Witness::new(TEST_N, 1, Zq::new(10000)).s\n        }\n\n        pub fn setup_scheme() -\u003e AjtaiScheme {\n            let mut rng = rand::rng();\n            let random_matrix = RqMatrix::random(\u0026mut rng, TEST_M, TEST_N);\n            AjtaiScheme::new(Zq::ONE, random_matrix).unwrap()\n        }\n    }\n\n    #[test]\n    fn rejects_invalid_parameters() {\n        assert!(AjtaiScheme::new(\n            Zq::ZERO,\n            RqMatrix::new(vec![RqVector::new(vec![Rq::zero()])], false)\n        )\n        .is_err());\n        let _ = test_utils::setup_scheme(); // Will panic if setup fails\n    }\n\n    #[test]\n    fn initializes_with_correct_bounds() {\n        let scheme = test_utils::setup_scheme();\n        assert_eq!(scheme.witness_bound(), Zq::ONE);\n    }\n\n    #[test]\n    fn completes_commitment_cycle() {\n        let scheme = test_utils::setup_scheme();\n        let witness = test_utils::valid_witness(\u0026scheme);\n\n        let commitment = scheme.commit(\u0026witness).unwrap();\n        assert!(scheme.verify(\u0026commitment, \u0026witness).is_ok());\n\n        let mut bad_opening = witness.clone();\n        let mut rng = rand::rng();\n        bad_opening.set(0, Rq::random(\u0026mut rng));\n        assert!(scheme.verify(\u0026commitment, \u0026bad_opening).is_err());\n    }\n\n    #[test]\n    fn maintains_security_properties() {\n        let scheme = test_utils::setup_scheme();\n\n        // Use random witnesses to ensure they're different\n        let witness1 = test_utils::random_valid_witness();\n        let witness2 = test_utils::random_valid_witness();\n\n        // Ensure the witnesses are actually different\n        assert_ne!(witness1, witness2, \"Test requires different witnesses\");\n\n        let c1 = scheme.commit(\u0026witness1[0]).unwrap();\n        let c2 = scheme.commit(\u0026witness2[0]).unwrap();\n        assert_ne!(\n            c1, c2,\n            \"Different witnesses should produce different commitments\"\n        );\n    }\n\n    #[test]\n    fn handles_edge_cases() {\n        let scheme = test_utils::setup_scheme();\n        let zero_witness = RqVector::zero(TEST_N);\n\n        assert!(scheme.commit(\u0026zero_witness).is_ok());\n        assert!(scheme.commit(\u0026test_utils::valid_witness(\u0026scheme)).is_ok());\n    }\n\n    #[test]\n    fn stress_test() {\n        let scheme = test_utils::setup_scheme();\n\n        (0..100).for_each(|_| {\n            let witness = test_utils::valid_witness(\u0026scheme);\n            let commitment = scheme.commit(\u0026witness).unwrap();\n            assert!(scheme.verify(\u0026commitment, \u0026witness).is_ok());\n        });\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":19}},{"line":48,"address":[],"length":0,"stats":{"Line":19}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":18}},{"line":53,"address":[],"length":0,"stats":{"Line":18}},{"line":54,"address":[],"length":0,"stats":{"Line":18}},{"line":57,"address":[],"length":0,"stats":{"Line":18}},{"line":58,"address":[],"length":0,"stats":{"Line":18}},{"line":59,"address":[],"length":0,"stats":{"Line":18}},{"line":64,"address":[],"length":0,"stats":{"Line":120}},{"line":65,"address":[],"length":0,"stats":{"Line":120}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":120}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":120}},{"line":72,"address":[],"length":0,"stats":{"Line":120}},{"line":76,"address":[],"length":0,"stats":{"Line":102}},{"line":81,"address":[],"length":0,"stats":{"Line":102}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":102}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":102}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":102}},{"line":92,"address":[],"length":0,"stats":{"Line":102}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":101}},{"line":100,"address":[],"length":0,"stats":{"Line":18}},{"line":101,"address":[],"length":0,"stats":{"Line":18}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":18}},{"line":119,"address":[],"length":0,"stats":{"Line":18}},{"line":121,"address":[],"length":0,"stats":{"Line":18}},{"line":124,"address":[],"length":0,"stats":{"Line":36}},{"line":127,"address":[],"length":0,"stats":{"Line":18}},{"line":130,"address":[],"length":0,"stats":{"Line":18}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":18}},{"line":137,"address":[],"length":0,"stats":{"Line":18}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":18}},{"line":151,"address":[],"length":0,"stats":{"Line":222}},{"line":153,"address":[],"length":0,"stats":{"Line":222}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":103}},{"line":166,"address":[],"length":0,"stats":{"Line":103}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}}],"covered":39,"coverable":50},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","commitments","common_instances.rs"],"content":"use rand::rng;\n\nuse crate::commitments::ajtai_commitment::AjtaiScheme;\nuse crate::relation::env_params::EnvironmentParameters;\nuse crate::ring::rq::Rq;\nuse crate::ring::rq_matrix::RqMatrix;\n\npub struct AjtaiInstances {\n    // A \\in R_q^(k*n)\n    pub commitment_scheme_a: AjtaiScheme,\n    // B_{ik} \\in R_q^(k_1*k), for i \\in [1,r] and k \\in [0, t_1-1]\n    pub commitment_scheme_b: AjtaiScheme,\n    // C_{ijk} \\in R_q^(k_2*1), for i \\in [1,r], j \\in [i, r], and k \\in [0, t_2-1]\n    pub commitment_scheme_c: AjtaiScheme,\n    // D_{ijk} \\in R_q^(k_2*1), for i \\in [1,r], j \\in [i, r], and k \\in [0, t_1-1]\n    pub commitment_scheme_d: AjtaiScheme,\n}\n\nimpl AjtaiInstances {\n    pub fn new(ep: \u0026EnvironmentParameters) -\u003e Self {\n        Self {\n            commitment_scheme_a: AjtaiScheme::new(\n                ep.beta,\n                Self::challenge_rq_matrix(ep.kappa, ep.rank),\n            )\n            .expect(\"Invalid Parameters for commitment scheme A\"),\n            commitment_scheme_b: AjtaiScheme::new(\n                ep.gamma_1,\n                Self::challenge_rq_matrix(ep.kappa_1, ep.multiplicity * ep.t_1 * ep.kappa),\n            )\n            .expect(\"Invalid Parameters for commitment scheme B\"),\n            // Todo: gamma_1 should be changed to a valid witness bound\n            commitment_scheme_c: AjtaiScheme::new(\n                ep.gamma_1,\n                Self::challenge_rq_matrix(\n                    ep.kappa_1,\n                    ep.t_2 * ((ep.multiplicity.pow(2)) + ep.multiplicity) / 2,\n                ),\n            )\n            .expect(\"Invalid Parameters for commitment scheme C\"),\n            commitment_scheme_d: AjtaiScheme::new(\n                ep.gamma_2,\n                Self::challenge_rq_matrix(\n                    ep.kappa_2,\n                    ep.t_1 * ((ep.multiplicity.pow(2)) + ep.multiplicity) / 2,\n                ),\n            )\n            .expect(\"Invalid Parameters for commitment scheme D\"),\n        }\n    }\n\n    fn challenge_rq_matrix(row: usize, col: usize) -\u003e RqMatrix {\n        (0..row)\n            .map(|_| (0..col).map(|_| Rq::random(\u0026mut rng())).collect())\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Instant;\n\n    #[test]\n    fn test_crs() {\n        // set up example environment parameters, use default set for testing.\n        let ep_1 = EnvironmentParameters::default();\n\n        let total_start = Instant::now();\n        // generate the common reference string matrices A, B, C, D\n        let _pp = AjtaiInstances::new(\u0026ep_1);\n\n        println!(\n            \"Total time for PublicPrams::new: {:?}\",\n            total_start.elapsed()\n        );\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":3}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":1278}}],"covered":8,"coverable":8},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","commitments","mod.rs"],"content":"pub mod ajtai_commitment;\npub mod common_instances;\npub mod outer_commitments;\npub use ajtai_commitment::CommitError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","commitments","outer_commitments.rs"],"content":"use thiserror::Error;\n\nuse crate::{\n    commitments::common_instances::AjtaiInstances,\n    ring::{rq_matrix::RqMatrix, rq_vector::RqVector, zq::Zq},\n};\n\nuse super::ajtai_commitment::AjtaiScheme;\n\n#[derive(Debug, Error)]\npub enum DecompositionError {\n    #[error(\"invalid decomposition base: {0}\")]\n    InvalidBase(Zq),\n    #[error(\"invalid number of parts: {0}\")]\n    InvalidPartCount(usize),\n}\n\n/// Parameters for polynomial decomposition in hierarchical commitments\n/// The base parameter controls how coefficients are decomposed\n/// The num_parts parameter determines how many parts each coefficient is split into\n#[derive(Debug, Clone)]\npub struct DecompositionParameters {\n    base: Zq,\n    num_parts: usize,\n}\n\nimpl DecompositionParameters {\n    /// Creates new decomposition parameters with validation\n    /// - base must be greater than 1 for meaningful decomposition\n    /// - num_parts must be positive to ensure decomposition occurs\n    pub fn new(base: Zq, num_parts: usize) -\u003e Result\u003cSelf, DecompositionError\u003e {\n        if base \u003c= Zq::ONE {\n            return Err(DecompositionError::InvalidBase(base));\n        }\n        if num_parts == 0 {\n            return Err(DecompositionError::InvalidPartCount(num_parts));\n        }\n\n        Ok(Self { base, num_parts })\n    }\n\n    /// Returns the decomposition base\n    pub fn base(\u0026self) -\u003e Zq {\n        self.base\n    }\n\n    /// Returns the number of decomposition parts\n    pub fn num_parts(\u0026self) -\u003e usize {\n        self.num_parts\n    }\n}\n\nfn decompose_and_commit(\n    commitment_matrix: \u0026AjtaiScheme,\n    input: \u0026RqMatrix,\n    params: \u0026DecompositionParameters,\n) -\u003e RqVector {\n    let decomposed_input = input.decompose_each_cell(params.base, params.num_parts);\n    commitment_matrix\n        .commit(\u0026decomposed_input)\n        .expect(\"Commitment error in committing to decomposed input\")\n}\n\npub fn compute_u1(\n    crs: \u0026AjtaiInstances,\n    t: \u0026RqMatrix,\n    t_decomposition_params: DecompositionParameters,\n    g: \u0026RqMatrix,\n    g_decomposition_params: DecompositionParameters,\n) -\u003e RqVector {\n    \u0026decompose_and_commit(\u0026crs.commitment_scheme_b, t, \u0026t_decomposition_params)\n        + \u0026decompose_and_commit(\u0026crs.commitment_scheme_c, g, \u0026g_decomposition_params)\n}\n\npub fn compute_u2(\n    crs: \u0026AjtaiInstances,\n    h: \u0026RqMatrix,\n    h_decomposition_params: DecompositionParameters,\n) -\u003e RqVector {\n    decompose_and_commit(\u0026crs.commitment_scheme_d, h, \u0026h_decomposition_params)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_decomposition_parameters() {\n        assert!(DecompositionParameters::new(Zq::ZERO, 2).is_err());\n        assert!(DecompositionParameters::new(Zq::TWO, 0).is_err());\n        let params = DecompositionParameters::new(Zq::new(8), 3).unwrap();\n        assert_eq!(params.base(), Zq::new(8));\n        assert_eq!(params.num_parts(), 3);\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":32,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":11}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":10}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":9}},{"line":58,"address":[],"length":0,"stats":{"Line":9}},{"line":59,"address":[],"length":0,"stats":{"Line":9}},{"line":60,"address":[],"length":0,"stats":{"Line":9}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":3}}],"covered":19,"coverable":19},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","aggregate.rs"],"content":"use crate::relation::env_params::EnvironmentParameters;\nuse crate::ring::rq::Rq;\nuse crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\n\nuse super::inner_product;\n\n/// This struct serves as aggregation of functions with constant value 0.\npub struct ZeroConstantFunctionsAggregation\u003c'a\u003e {\n    ep: \u0026'a EnvironmentParameters,\n    a_double_prime: Vec\u003cRqMatrix\u003e,\n    phi_double_prime: Vec\u003cVec\u003cRqVector\u003e\u003e,\n}\n\nimpl\u003c'a\u003e ZeroConstantFunctionsAggregation\u003c'a\u003e {\n    pub fn new(parameters: \u0026'a EnvironmentParameters) -\u003e Self {\n        Self {\n            ep: parameters,\n            a_double_prime: vec![\n                RqMatrix::symmetric_zero(parameters.multiplicity);\n                parameters.const_agg_length\n            ],\n            phi_double_prime: vec![\n                vec![RqVector::zero(parameters.rank); parameters.multiplicity];\n                parameters.const_agg_length\n            ],\n        }\n    }\n\n    /// Calculate a_double_primes from a_prime, a_{i,j}^{''k} = \\sum_{l=1}^{L}\\psi_l^{k}a_{ij}^{'(l)}\n    ///\n    /// @param: vector_psi: \\psi_l^k\n    /// @param: a_prime: a_{ij}^{'(l)}, each a_{ij} is a ring element (PolyRing)\n    ///\n    /// @return: a_{ij}^{''(k)}, return a vector length k of matrix a_{ij}^{''}\n    pub fn calculate_agg_a_double_prime(\u0026mut self, vector_psi: \u0026[Vec\u003cZq\u003e], a_prime: \u0026[RqMatrix]) {\n        for i in 0..self.ep.multiplicity {\n            for j in 0..i + 1 {\n                let a_prime_l_vector: Vec\u003c\u0026Rq\u003e =\n                    a_prime.iter().map(|matrix| matrix.get_cell(i, j)).collect();\n\n                for (k, matrix) in self.a_double_prime.iter_mut().enumerate() {\n                    matrix.set_sell(\n                        i,\n                        j,\n                        inner_product::compute_linear_combination(\n                            \u0026a_prime_l_vector,\n                            \u0026vector_psi[k],\n                        ),\n                    );\n                }\n            }\n        }\n    }\n\n    /// calculate \\phi_{i}^{''(k)} = \\sum_{l=1}^{L}\\psi_l^{k}\\phi_{i}^{'(l)} + \\sum(\\omega_j^{k} * \\sigma_{-1} * pi_i^{j})\n    /// in the prover process, page 17 from the paper.\n    ///\n    /// @param: phi_ct: \\phi_{i}^{'(l)}\n    /// @param: pi: pi_i^{j}\n    /// @param: random_psi: \\psi_l^{k}\n    /// @param: random_omega: \\omega_j^{k}\n    ///\n    /// return: \\phi_{i}^{''(k)}\n    pub fn calculate_agg_phi_double_prime(\n        \u0026mut self,\n        phi_prime: \u0026[Vec\u003cRqVector\u003e],\n        conjugated_pi: \u0026[RqMatrix],\n        vector_psi: \u0026[Vec\u003cZq\u003e],\n        vector_omega: \u0026[Vec\u003cZq\u003e],\n    ) {\n        for i in 0..self.ep.multiplicity {\n            let phi_prime_l_vector: Vec\u003c\u0026RqVector\u003e =\n                phi_prime.iter().map(|elems| \u0026elems[i]).collect();\n            for (k, phi_k) in self.phi_double_prime.iter_mut().enumerate() {\n                phi_k[i] =\n                    inner_product::compute_linear_combination(\u0026phi_prime_l_vector, \u0026vector_psi[k]);\n            }\n        }\n\n        for (i, pi_i) in conjugated_pi.iter().enumerate() {\n            for (k, phi_k) in self.phi_double_prime.iter_mut().enumerate() {\n                phi_k[i] = \u0026phi_k[i]\n                    + \u0026inner_product::compute_linear_combination(\n                        pi_i.get_elements(),\n                        \u0026vector_omega[k],\n                    );\n            }\n        }\n    }\n\n    /// calculate b^{''(k)} = \\sum_{i,j=1}^{r} a_{ij}^{''(k)} * \u003cs_i, s_j\u003e + \\sum_{i=1}^{r} \u003c\\phi_{i}^{''(k)} * s_i\u003e\n    ///\n    /// @param: a_ct_aggr: a_{ij}^{''(k)}\n    /// @param: phi_ct_aggr: \\phi_{i}^{''(k)}\n    /// @param: witness: s_i\n    ///\n    /// @return: b^{''(k)}\n    pub fn calculate_agg_b_double_prime(\u0026mut self, witness: \u0026[RqVector]) -\u003e RqVector {\n        (0..self.ep.kappa)\n            .map(|k| {\n                (0..self.ep.multiplicity)\n                    .map(|i| {\n                        \u0026(0..self.ep.multiplicity).map(|j| {\n                    // calculate a_{ij}^{''(k)} * \u003cs_i, s_j\u003e\n                    self.a_double_prime[k].get_cell(i, j)\n                        * \u0026inner_product::compute_linear_combination(witness[i].get_elements(), witness[j].get_elements())\n                })\n                .fold(\n                    // sum over all i,j\n                    Rq::zero(),\n                    |acc, val| \u0026acc + \u0026val,\n                )\n                // add \\phi_{i}^{''(k)} * s[i]\n                + \u0026inner_product::compute_linear_combination(self.phi_double_prime[k][i].get_elements(), witness[i].get_elements())\n                    }) // sum over all i,j\n                    .fold(Rq::zero(), |acc, val| \u0026acc + \u0026val)\n            })\n            .collect()\n    }\n\n    pub fn get_alpha_double_prime(\u0026self) -\u003e \u0026[RqMatrix] {\n        \u0026self.a_double_prime\n    }\n\n    pub fn get_phi_double_prime(\u0026self) -\u003e \u0026[Vec\u003cRqVector\u003e] {\n        \u0026self.phi_double_prime\n    }\n}\n\npub struct FunctionsAggregation\u003c'a\u003e {\n    ep: \u0026'a EnvironmentParameters,\n    aggregated_a: RqMatrix,\n    aggregated_phi: Vec\u003cRqVector\u003e,\n    aggregated_b: Rq,\n}\n\nimpl\u003c'a\u003e FunctionsAggregation\u003c'a\u003e {\n    pub fn new(parameters: \u0026'a EnvironmentParameters) -\u003e Self {\n        Self {\n            ep: parameters,\n            aggregated_a: RqMatrix::symmetric_zero(parameters.multiplicity),\n            aggregated_phi: vec![RqVector::zero(parameters.rank); parameters.multiplicity],\n            aggregated_b: Rq::zero(),\n        }\n    }\n\n    /// calculate a_i = \\sum(alpha_k * a_{ij}) + \\sum(beta_k * a_{ij}^{''(k)})\n    /// equation 5, in the verifier process, page 18 from the paper.\n    ///\n    /// @param: a_constraint: a_{ij}\n    /// @param: a_ct_aggr: a_{ij}^{''(k)}\n    /// @param: random_alpha: alpha_k\n    /// @param: random_beta: beta_k\n    /// @param: ep: struct SizeParams\n    ///\n    /// @return: a_i\n    pub fn calculate_agg_a(\n        \u0026mut self,\n        a_constraint: \u0026[RqMatrix],\n        a_double_prime: \u0026[RqMatrix],\n        vector_alpha: \u0026RqVector,\n        vector_beta: \u0026RqVector,\n    ) {\n        for i in 0..self.ep.multiplicity {\n            for j in 0..i + 1 {\n                let a_constraint_k: Vec\u003c\u0026Rq\u003e = a_constraint\n                    .iter()\n                    .map(|matrix| matrix.get_cell(i, j))\n                    .collect();\n                let a_double_prime_k: Vec\u003c\u0026Rq\u003e = a_double_prime\n                    .iter()\n                    .map(|matrix| matrix.get_cell(i, j))\n                    .collect();\n                self.aggregated_a.set_sell(\n                    i,\n                    j,\n                    \u0026inner_product::compute_linear_combination::\u003c\u0026Rq, Rq, Rq\u003e(\n                        \u0026a_constraint_k,\n                        vector_alpha.get_elements(),\n                    ) + \u0026inner_product::compute_linear_combination(\n                        \u0026a_double_prime_k,\n                        vector_beta.get_elements(),\n                    ),\n                );\n            }\n        }\n    }\n\n    /// calculate phi_i = \\sum(alpha_k * \\phi_{i}^{k}) + \\sum(beta_k * \\phi_{i}^{''(k)})\n    /// equation 6, in the verifier process, page 18 from the paper.\n    ///\n    /// param: phi_constraint: \\phi_{i}^{k}\n    /// param: phi_ct_aggr: \\phi_{i}^{''(k)}\n    /// param: random_alpha: alpha_k\n    /// param: random_beta: beta_k\n    /// param: ep: struct SizeParams\n    ///\n    /// return: phi_i\n    pub fn calculate_aggr_phi(\n        \u0026mut self,\n        phi_constraint: \u0026[Vec\u003cRqVector\u003e],\n        phi_double_prime: \u0026[Vec\u003cRqVector\u003e],\n        vector_alpha: \u0026RqVector,\n        vector_beta: \u0026RqVector,\n    ) {\n        for i in 0..self.ep.multiplicity {\n            let phi_constraint_k: Vec\u003c\u0026RqVector\u003e =\n                phi_constraint.iter().map(|element| \u0026element[i]).collect();\n            let phi_double_prime_k: Vec\u003c\u0026RqVector\u003e =\n                phi_double_prime.iter().map(|element| \u0026element[i]).collect();\n            self.aggregated_phi[i] =\n                \u0026inner_product::compute_linear_combination::\u003c\u0026RqVector, RqVector, Rq\u003e(\n                    \u0026phi_constraint_k,\n                    vector_alpha.get_elements(),\n                ) + \u0026inner_product::compute_linear_combination(\n                    \u0026phi_double_prime_k,\n                    vector_beta.get_elements(),\n                );\n        }\n    }\n\n    /// calculate b_i = \\sum(alpha_k * b^{k}) + \\sum(beta_k * b^{''(k})\n    /// equation 7, in the verifier process, page 18 from the paper.\n    ///\n    /// @param: b_constraint: b^{k}\n    /// @param: b_ct_aggr: b^{''(k)}\n    /// @param: random_alpha: alpha_k\n    /// @param: random_beta: beta_k\n    /// @param: ep: struct SizeParams\n    ///\n    /// @return: b_i\n    pub fn calculate_aggr_b(\n        \u0026mut self,\n        b_constraint: \u0026RqVector,\n        b_double_prime: \u0026RqVector,\n        vector_alpha: \u0026RqVector,\n        vector_beta: \u0026RqVector,\n    ) {\n        self.aggregated_b = \u0026inner_product::compute_linear_combination(\n            b_constraint.get_elements(),\n            vector_alpha.get_elements(),\n        ) + \u0026inner_product::compute_linear_combination(\n            b_double_prime.get_elements(),\n            vector_beta.get_elements(),\n        )\n    }\n\n    pub fn get_agg_a(\u0026self) -\u003e \u0026RqMatrix {\n        \u0026self.aggregated_a\n    }\n\n    pub fn get_appr_phi(\u0026self) -\u003e \u0026[RqVector] {\n        \u0026self.aggregated_phi\n    }\n\n    pub fn get_aggr_b(\u0026self) -\u003e \u0026Rq {\n        \u0026self.aggregated_b\n    }\n}\n\n// #[cfg(test)]\n// mod tests {\n//     use super::*;\n//     use crate::prover::Challenges;\n//     use crate::verifier::LabradorVerifier;\n//     #[test]\n//     fn test_check_relation_full() {\n//         // set up example environment, use set1 for testing.\n//         let ep = EnvironmentParameters::default();\n//         // generate a random witness based on ep above\n//         let witness_1 = Witness::new(\u0026ep);\n//         // generate public statements based on witness_1\n//         let st = Statement::new(\u0026witness_1, \u0026ep);\n//         // generate random challenges\n//         let tr = Challenges::new(\u0026ep);\n//         // first aggregation\n//         let aggr_1 = AggregationOne::new(\u0026witness_1, \u0026st, \u0026ep, \u0026tr);\n//         // second aggregation\n//         let aggr_2 = AggregationTwo::new(\u0026aggr_1, \u0026st, \u0026ep, \u0026tr);\n\n//         // calculate garbage polynomial g_{ij} = \u003cs_i, s_j\u003e\n//         let g = (0..ep.multiplicity)\n//             .map(|i| {\n//                 (0..ep.multiplicity)\n//                     .map(|j| witness_1.s[i].inner_product_poly_vector(\u0026witness_1.s[j]))\n//                     .collect()\n//             })\n//             .collect();\n\n//         // calculate h_{ii}\n//         let h = (0..ep.multiplicity)\n//             .map(|i| {\n//                 (0..ep.multiplicity)\n//                     .map(|j| {\n//                         let inner_phii_sj =\n//                             aggr_2.phi_i[i].inner_product_poly_vector(\u0026witness_1.s[j]);\n//                         let inner_phij_si =\n//                             aggr_2.phi_i[j].inner_product_poly_vector(\u0026witness_1.s[i]);\n//                         \u0026inner_phii_sj + \u0026inner_phij_si\n//                     })\n//                     .collect()\n//             })\n//             .collect();\n\n//         // check aggregation relation\n//         let relation = LabradorVerifier::check_relation(\u0026aggr_2.a_i, \u0026aggr_2.b_i, \u0026g, \u0026h);\n\n//         assert!(relation);\n//     }\n// }\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":24,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":18}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":90}},{"line":43,"address":[],"length":0,"stats":{"Line":72}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":45}},{"line":76,"address":[],"length":0,"stats":{"Line":36}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":12}},{"line":83,"address":[],"length":0,"stats":{"Line":36}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":10}},{"line":103,"address":[],"length":0,"stats":{"Line":8}},{"line":104,"address":[],"length":0,"stats":{"Line":32}},{"line":105,"address":[],"length":0,"stats":{"Line":96}},{"line":107,"address":[],"length":0,"stats":{"Line":72}},{"line":108,"address":[],"length":0,"stats":{"Line":72}},{"line":110,"address":[],"length":0,"stats":{"Line":24}},{"line":112,"address":[],"length":0,"stats":{"Line":24}},{"line":113,"address":[],"length":0,"stats":{"Line":120}},{"line":116,"address":[],"length":0,"stats":{"Line":24}},{"line":117,"address":[],"length":0,"stats":{"Line":32}},{"line":118,"address":[],"length":0,"stats":{"Line":40}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":6}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":30}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":24}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":208,"address":[],"length":0,"stats":{"Line":12}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":45}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":36}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":3}},{"line":255,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":1}}],"covered":58,"coverable":92},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","garbage_polynomials.rs"],"content":"use crate::ring::{rq_matrix::RqMatrix, rq_vector::RqVector};\n\nuse super::inner_product;\n\n/// Calculate the garbage polynomials g_{ij} = \u003cs_i, s_j\u003e\n/// Exploits symmetry by only calculating for i ≤ j since g_{ij} = g_{ji}\npub fn compute_g(witness_vector: \u0026[RqVector]) -\u003e RqMatrix {\n    let mut g_i = Vec::new();\n    for i in 0..witness_vector.len() {\n        let mut g_ij = Vec::new();\n        for j in 0..=i {\n            // Only calculate for j ≤ i (upper triangular)\n            g_ij.push(inner_product::compute_linear_combination(\n                witness_vector[i].get_elements(),\n                witness_vector[j].get_elements(),\n            ));\n        }\n        g_i.push(RqVector::new(g_ij));\n    }\n    RqMatrix::new(g_i, true)\n}\n\n/// Calculate the h_{ij} = \u003cφ_i, s_j\u003e + \u003cφ_j, s_i\u003e garbage polynomials\n/// In the paper, h_{ij} is defined with a factor of 1/2 in front\n/// However, since we're using q = 2^32, division by 2 is problematic in Z_q\n/// So we store h'_{ij} = 2*h_{ij} = \u003cφ_i, s_j\u003e + \u003cφ_j, s_i\u003e directly\n/// Exploits symmetry by only calculating for i ≤ j since h_{ij} = h_{ji}\npub fn compute_h(witness_vector: \u0026[RqVector], phi: \u0026[RqVector]) -\u003e RqMatrix {\n    let r = witness_vector.len();\n    let mut h_i = Vec::with_capacity((r * (r + 1)) / 2);\n\n    for i in 0..r {\n        let mut h_ij = Vec::new();\n        for j in 0..=i {\n            // Only calculate for j ≤ i (upper triangular)\n            let inner_phi_i_s_j = inner_product::compute_linear_combination(\n                phi[i].get_elements(),\n                witness_vector[j].get_elements(),\n            );\n            let inner_phi_j_s_i = inner_product::compute_linear_combination(\n                phi[j].get_elements(),\n                witness_vector[i].get_elements(),\n            );\n            h_ij.push(\u0026inner_phi_i_s_j + \u0026inner_phi_j_s_i);\n        }\n        h_i.push(RqVector::new(h_ij));\n    }\n    RqMatrix::new(h_i, true)\n}\n\n// Todo: Revise and complete the following\n// Implementation of the final level optimization (Section 5.6)\n// /// Uses sequentially derived challenges via Fiat-Shamir to simulate the interactive protocol\n// pub fn optimize_final_level(\n//     witnesses: \u0026[PolyVector],\n//     phi: \u0026[PolyVector],\n//     initial_seed: u64,\n// ) -\u003e (PolyRing, Vec\u003cPolyRing\u003e, Vec\u003cPolyRing\u003e) {\n//     let r = witnesses.len();\n\n//     // Calculate g_0 = Σ_i \u003cs_i, s_i\u003e (diagonal sum)\n//     let g0 = (0..r)\n//         .map(|i| witnesses[i].inner_product_poly_vector(\u0026witnesses[i]))\n//         .fold(\n//             PolyRing::zero(witnesses[0].get_elements()[0].len()),\n//             |acc, g| \u0026acc + \u0026g,\n//         );\n\n//     // Generate sequence of challenges using Fiat-Shamir\n//     let mut challenges = Vec::with_capacity(r / 2);\n//     let mut hasher = DefaultHasher::new();\n//     initial_seed.hash(\u0026mut hasher);\n//     let mut current_seed = hasher.finish();\n\n//     for _ in 0..r / 2 {\n//         let mut rng = rand::rngs::StdRng::seed_from_u64(current_seed);\n//         let challenge = PolyRing::random(\u0026mut rng, witnesses[0].get_elements()[0].len());\n//         challenges.push(challenge);\n\n//         // Update seed for next challenge\n//         let mut hasher = DefaultHasher::new();\n//         current_seed.hash(\u0026mut hasher);\n//         current_seed = hasher.finish();\n//     }\n\n//     // Calculate selected g terms: g_{2i-1} and g_{2i}\n//     let mut g_terms = Vec::new();\n//     for i in 1..=r / 2 {\n//         let idx1 = 2 * i - 2;\n//         let idx2 = 2 * i - 1;\n\n//         // Use unique challenge for each i\n//         let challenge = \u0026challenges[i - 1];\n\n//         // Add g_{2i-1}\n//         if idx2 \u003c r {\n//             // For g_{2i-1} = \u003cs_{2i-2}, c_i * s_{2i-1}\u003e\n//             let s_j_scaled = witnesses[idx2]\n//                 .iter()\n//                 .map(|p| p * challenge)\n//                 .collect::\u003cPolyVector\u003e();\n\n//             let g_2i_1 = witnesses[idx1].inner_product_poly_vector(\u0026s_j_scaled);\n//             g_terms.push(g_2i_1);\n\n//             // Add g_{2i} if we have enough witnesses\n//             if 2 * i \u003c r {\n//                 // For g_{2i} = \u003cs_{2i-1}, c_i * s_{2i}\u003e\n//                 let s_j_scaled = witnesses[2 * i]\n//                     .iter()\n//                     .map(|p| p * challenge)\n//                     .collect::\u003cPolyVector\u003e();\n\n//                 let g_2i = witnesses[idx2].inner_product_poly_vector(\u0026s_j_scaled);\n//                 g_terms.push(g_2i);\n//             }\n//         }\n//     }\n\n//     // Calculate selected h terms: h_{2i-1} and h_{2i}\n//     let mut h_terms = Vec::new();\n//     for i in 1..=r / 2 {\n//         let idx1 = 2 * i - 2;\n//         let idx2 = 2 * i - 1;\n\n//         // Use unique challenge for each i\n//         let challenge = \u0026challenges[i - 1];\n\n//         // Add h_{2i-1}\n//         if idx2 \u003c r {\n//             // For h_{2i-1} = \u003cφ_{2i-2}, c_i * s_{2i-1}\u003e + \u003cφ_{2i-1}, c_i * s_{2i-2}\u003e\n//             let s_j_scaled = witnesses[idx2]\n//                 .iter()\n//                 .map(|p| p * challenge)\n//                 .collect::\u003cPolyVector\u003e();\n\n//             let phi_i_s_j = phi[idx1].inner_product_poly_vector(\u0026s_j_scaled);\n\n//             let s_i_scaled = witnesses[idx1]\n//                 .iter()\n//                 .map(|p| p * challenge)\n//                 .collect::\u003cPolyVector\u003e();\n\n//             let phi_j_s_i = phi[idx2].inner_product_poly_vector(\u0026s_i_scaled);\n\n//             let h_2i_1 = \u0026phi_i_s_j + \u0026phi_j_s_i;\n//             h_terms.push(h_2i_1);\n\n//             // Add h_{2i} if we have enough witnesses\n//             if 2 * i \u003c r {\n//                 // For h_{2i} = \u003cφ_{2i-1}, c_i * s_{2i}\u003e + \u003cφ_{2i}, c_i * s_{2i-1}\u003e\n//                 let s_j_scaled = witnesses[2 * i]\n//                     .iter()\n//                     .map(|p| p * challenge)\n//                     .collect::\u003cPolyVector\u003e();\n\n//                 let phi_i_s_j = phi[idx2].inner_product_poly_vector(\u0026s_j_scaled);\n\n//                 let s_i_scaled = witnesses[idx2]\n//                     .iter()\n//                     .map(|p| p * challenge)\n//                     .collect::\u003cPolyVector\u003e();\n\n//                 let phi_j_s_i = phi[2 * i].inner_product_poly_vector(\u0026s_i_scaled);\n\n//                 let h_2i = \u0026phi_i_s_j + \u0026phi_j_s_i;\n//                 h_terms.push(h_2i);\n//             }\n//         }\n//     }\n\n//     (g0, g_terms, h_terms)\n// }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand::rng;\n\n    const RANK: usize = 8;\n\n    fn create_test_witnesses(count: usize) -\u003e (Vec\u003cRqVector\u003e, Vec\u003cRqVector\u003e) {\n        let witnesses = (0..count)\n            .map(|_| RqVector::random(\u0026mut rng(), RANK))\n            .collect();\n\n        let phi = (0..count)\n            .map(|_| RqVector::random(\u0026mut rng(), RANK))\n            .collect();\n\n        (witnesses, phi)\n    }\n\n    #[test]\n    fn test_g_matrix_size() {\n        let multiplicity = 3;\n        let (witnesses, _) = create_test_witnesses(multiplicity);\n        let g = compute_g(\u0026witnesses);\n\n        assert_eq!(g.get_row_len(), 3);\n        // Assert that g stores half of the matrix\n        for row in 0..multiplicity {\n            assert_eq!(g.get_elements()[row].get_length(), row + 1);\n        }\n    }\n\n    #[test]\n    fn test_g_calculation() {\n        let (witnesses, _) = create_test_witnesses(3);\n\n        let g = compute_g(\u0026witnesses);\n\n        // Verify a few specific values\n        let expected_g_01 = inner_product::compute_linear_combination(\n            witnesses[0].get_elements(),\n            witnesses[1].get_elements(),\n        );\n        let expected_g_10 = inner_product::compute_linear_combination(\n            witnesses[1].get_elements(),\n            witnesses[0].get_elements(),\n        );\n        assert_eq!(expected_g_01, expected_g_10);\n\n        let expected_g_22 = inner_product::compute_linear_combination(\n            witnesses[2].get_elements(),\n            witnesses[2].get_elements(),\n        );\n\n        assert_eq!(*g.get_cell(0, 1), expected_g_01);\n        assert_eq!(*g.get_cell(1, 0), expected_g_10);\n        assert_eq!(*g.get_cell(2, 2), expected_g_22);\n    }\n\n    #[test]\n    fn test_h_matrix_size() {\n        let multiplicity = 3;\n        let (witnesses, phi) = create_test_witnesses(multiplicity);\n        let h = compute_h(\u0026witnesses, \u0026phi);\n\n        assert_eq!(h.get_row_len(), 3);\n        // Assert that g stores half of the matrix\n        for row in 0..multiplicity {\n            assert_eq!(h.get_elements()[row].get_length(), row + 1);\n        }\n    }\n\n    #[test]\n    fn test_h_calculation() {\n        let (witnesses, phi) = create_test_witnesses(3);\n        let h = compute_h(\u0026witnesses, \u0026phi);\n\n        // Verify a specific value\n        let phi_0_s_1 = inner_product::compute_linear_combination(\n            phi[0].get_elements(),\n            witnesses[1].get_elements(),\n        );\n        let phi_1_s_0 = inner_product::compute_linear_combination(\n            phi[1].get_elements(),\n            witnesses[0].get_elements(),\n        );\n        let expected_h_01 = \u0026phi_0_s_1 + \u0026phi_1_s_0;\n\n        assert_eq!(h.get_cell(0, 1), h.get_cell(1, 0));\n        assert_eq!(expected_h_01, *h.get_cell(0, 1));\n    }\n\n    // #[test]\n    // fn test_commit_recursive() {\n    //     let commitment_scheme = create_test_commitment();\n    //     let (witnesses, phi) = create_test_witnesses(3);\n\n    //     // Create mock inner commitment parts (t and z)\n    //     let t_parts = create_test_parts(5);\n    //     let z_parts = create_test_parts(5);\n\n    //     let (recursive_commitment, recursive_witness) = commitment_scheme\n    //         .commit_recursive(\u0026witnesses, \u0026phi, \u0026t_parts, \u0026z_parts)\n    //         .unwrap();\n\n    //     // Check the output structure\n    //     assert!(!recursive_commitment.nu1.as_slice().is_empty());\n    //     assert!(!recursive_commitment.nu2.as_slice().is_empty());\n\n    //     // Check witness has appropriate parts\n    //     assert_eq!(recursive_witness.t_parts.len(), t_parts.len());\n    //     assert_eq!(recursive_witness.z_parts.len(), z_parts.len());\n    //     assert!(!recursive_witness.g_parts.is_empty());\n    //     assert!(!recursive_witness.h_parts.is_empty());\n    // }\n\n    // #[test]\n    // fn test_commit_recursive_correctness() {\n    //     let commitment_scheme = create_test_commitment();\n    //     let (witnesses, phi) = create_test_witnesses(3);\n\n    //     // Create test parts for inner commitment\n    //     let t_parts = create_test_parts(5);\n    //     let z_parts = create_test_parts(5);\n\n    //     // Get the recursive commitment and witness\n    //     let (recursive_commitment, recursive_witness) = commitment_scheme\n    //         .commit_recursive(\u0026witnesses, \u0026phi, \u0026t_parts, \u0026z_parts)\n    //         .unwrap();\n\n    //     // Manually compute the expected commitments:\n\n    //     // 1. For nu1, combine t_parts and g_parts\n    //     let mut combined_parts = recursive_witness.t_parts.clone();\n    //     combined_parts.extend(recursive_witness.g_parts.clone());\n\n    //     // 2. Create expected witnesses\n    //     let expected_nu1_witness = commitment_scheme.create_witness_from_parts(\u0026combined_parts);\n    //     let expected_nu2_witness =\n    //         commitment_scheme.create_witness_from_parts(\u0026recursive_witness.h_parts);\n\n    //     // 3. Create AjtaiCommitment instances with the correct matrices\n    //     let nu1_commitment = AjtaiCommitment::new(\n    //         commitment_scheme.params.clone(),\n    //         commitment_scheme.nu1_matrix.clone(),\n    //     )\n    //     .unwrap();\n\n    //     let nu2_commitment = AjtaiCommitment::new(\n    //         commitment_scheme.params.clone(),\n    //         commitment_scheme.nu2_matrix.clone(),\n    //     )\n    //     .unwrap();\n\n    //     // 4. Compute expected commitments\n    //     let (expected_nu1, _) = nu1_commitment.commit(expected_nu1_witness).unwrap();\n    //     let (expected_nu2, _) = nu2_commitment.commit(expected_nu2_witness).unwrap();\n\n    //     // 5. Compare expected with actual\n    //     assert_eq!(\n    //         recursive_commitment.nu1, expected_nu1,\n    //         \"nu1 commitment does not match expected value\"\n    //     );\n    //     assert_eq!(\n    //         recursive_commitment.nu2, expected_nu2,\n    //         \"nu2 commitment does not match expected value\"\n    //     );\n    // }\n\n    // #[test]\n    // fn test_decomposition_reconstruction() {\n    //     let commitment_scheme = create_test_commitment();\n    //     let mut rng = rand::rng();\n\n    //     // Create a random polynomial\n    //     let original_poly = PolyRing::random(\u0026mut rng, TEST_D);\n    //     let original_rq: Rq\u003cTEST_D\u003e = original_poly.clone().into();\n\n    //     // Test g decomposition parameters\n    //     let g_parts = commitment_scheme.decompose_polynomial(\u0026original_poly, true);\n    //     let g_base = commitment_scheme.g_decomp_params.base();\n\n    //     // Reconstruct the polynomial from parts\n    //     let mut reconstructed_g = Rq::\u003cTEST_D\u003e::zero();\n    //     let mut current_base_power = Zq::ONE; // Base^0\n\n    //     for part in \u0026g_parts {\n    //         // Add part * base^k\n    //         reconstructed_g = reconstructed_g.clone() + part.clone().scalar_mul(current_base_power);\n    //         // Multiply by base for next iteration\n    //         current_base_power *= g_base;\n    //     }\n\n    //     assert_eq!(\n    //         reconstructed_g, original_rq,\n    //         \"G decomposition reconstruction failed\"\n    //     );\n\n    //     // Test h decomposition parameters\n    //     let h_parts = commitment_scheme.decompose_polynomial(\u0026original_poly, false);\n    //     let h_base = commitment_scheme.h_decomp_params.base();\n\n    //     // Reconstruct the polynomial from parts\n    //     let mut reconstructed_h = Rq::\u003cTEST_D\u003e::zero();\n    //     let mut current_base_power = Zq::ONE; // Base^0\n\n    //     for part in \u0026h_parts {\n    //         // Add part * base^k\n    //         reconstructed_h = reconstructed_h.clone() + part.clone().scalar_mul(current_base_power);\n    //         // Multiply by base for next iteration\n    //         current_base_power *= h_base;\n    //     }\n\n    //     assert_eq!(\n    //         reconstructed_h, original_rq,\n    //         \"H decomposition reconstruction failed\"\n    //     );\n    // }\n\n    // #[test]\n    // fn test_create_witness_from_parts_edge_cases() {\n    //     let commitment_scheme = create_test_commitment();\n    //     let mut rng = rand::rng();\n\n    //     // Test case 1: parts.len() \u003c N (should pad with zeros)\n    //     let few_parts: Vec\u003cRq\u003cTEST_D\u003e\u003e = (0..TEST_N - 2)\n    //         .map(|_| Rq::\u003cTEST_D\u003e::random(\u0026mut rng))\n    //         .collect();\n\n    //     let witness_few = commitment_scheme.create_witness_from_parts(\u0026few_parts);\n\n    //     // Check length is exactly N\n    //     assert_eq!(witness_few.as_slice().len(), TEST_N);\n\n    //     // Check that last elements are zero\n    //     for i in few_parts.len()..TEST_N {\n    //         assert_eq!(witness_few[i], Rq::\u003cTEST_D\u003e::zero());\n    //     }\n\n    //     // Check original parts are preserved (with possible bounding applied)\n    //     let witness_bound = commitment_scheme.params.witness_bound();\n    //     for (i, part) in few_parts.iter().enumerate() {\n    //         let mut bounded_part_coeffs = [Zq::ZERO; TEST_D];\n    //         for (j, coeff) in part.get_coefficients().iter().enumerate().take(TEST_D) {\n    //             bounded_part_coeffs[j] = coeff.centered_mod(witness_bound);\n    //         }\n    //         let bounded_part = Rq::\u003cTEST_D\u003e::new(bounded_part_coeffs);\n    //         assert_eq!(witness_few[i], bounded_part);\n    //     }\n\n    //     // Test case 2: parts.len() \u003e N (should truncate to first N)\n    //     let many_parts: Vec\u003cRq\u003cTEST_D\u003e\u003e = (0..TEST_N + 3)\n    //         .map(|_| Rq::\u003cTEST_D\u003e::random(\u0026mut rng))\n    //         .collect();\n\n    //     let witness_many = commitment_scheme.create_witness_from_parts(\u0026many_parts);\n\n    //     // Check length is exactly N\n    //     assert_eq!(witness_many.as_slice().len(), TEST_N);\n\n    //     // Check only first N parts are included (with possible bounding applied)\n    //     let witness_bound = commitment_scheme.params.witness_bound();\n    //     for i in 0..TEST_N {\n    //         let mut bounded_part_coeffs = [Zq::ZERO; TEST_D];\n    //         for (j, coeff) in many_parts[i]\n    //             .get_coefficients()\n    //             .iter()\n    //             .enumerate()\n    //             .take(TEST_D)\n    //         {\n    //             bounded_part_coeffs[j] = coeff.centered_mod(witness_bound);\n    //         }\n    //         let bounded_part = Rq::\u003cTEST_D\u003e::new(bounded_part_coeffs);\n    //         assert_eq!(witness_many[i], bounded_part);\n    //     }\n\n    //     // Test case 3: Coefficient bounding\n    //     // Create parts with large coefficients\n    //     let large_coeff_parts: Vec\u003cRq\u003cTEST_D\u003e\u003e = (0..TEST_N)\n    //         .map(|_| {\n    //             let mut large_part = Rq::\u003cTEST_D\u003e::random(\u0026mut rng);\n    //             // Set first coefficient to a large value beyond the witness bound\n    //             if let Some(c) = large_part.iter_mut().next() {\n    //                 *c = Zq::MAX - Zq::ONE;\n    //             }\n    //             large_part\n    //         })\n    //         .collect();\n\n    //     let witness_large = commitment_scheme.create_witness_from_parts(\u0026large_coeff_parts);\n\n    //     // Check coefficients are properly bounded\n    //     for i in 0..TEST_N {\n    //         let mut bounded_part_coeffs = [Zq::ZERO; TEST_D];\n    //         for (j, coeff) in large_coeff_parts[i]\n    //             .get_coefficients()\n    //             .iter()\n    //             .enumerate()\n    //             .take(TEST_D)\n    //         {\n    //             bounded_part_coeffs[j] = coeff.centered_mod(witness_bound);\n    //         }\n    //         let bounded_part = Rq::\u003cTEST_D\u003e::new(bounded_part_coeffs);\n\n    //         assert_eq!(witness_large[i], bounded_part);\n\n    //         // Also check that large coefficients were properly bounded\n    //         for (j, coeff) in witness_large[i].get_coefficients().iter().enumerate() {\n    //             let original_coeff = large_coeff_parts[i].get_coefficients()[j];\n    //             if original_coeff \u003e witness_bound {\n    //                 assert!(*coeff \u003c= witness_bound);\n    //             }\n    //         }\n    //     }\n    // }\n\n    // #[test]\n    // #[allow(clippy::as_conversions)]\n    // fn test_optimal_parameters_accuracy() {\n    //     // Choose small, simple values for manual calculation\n    //     let n = 4; // Small dimension\n    //     let d = 4; // Small degree\n    //     let s = 2.0; // Simple standard deviation\n    //     let beta = 1.0; // Simple beta value\n\n    //     // Manually calculate the expected values according to the paper's formulas\n    //     let n_d_sqrt = (n * d) as f64; // = 4.0\n\n    //     // s_g = sqrt(n*d) * s^2 = 4.0 * 4.0 = 16.0\n    //     let s_g = n_d_sqrt * s * s;\n\n    //     // s_h = beta * sqrt(n*d) * s = 1.0 * 4.0 * 2.0 = 8.0\n    //     let s_h = beta * n_d_sqrt * s;\n\n    //     // b2 ≈ sqrt(12 * s_g) = sqrt(12 * 16.0) = sqrt(192) ≈ 13.856... =\u003e 13\n    //     let expected_b2 = (12.0 * s_g).sqrt() as u32;\n\n    //     // b1 ≈ sqrt(12 * s_h) = sqrt(12 * 8.0) = sqrt(96) ≈ 9.798... =\u003e 9\n    //     let expected_b1 = (12.0 * s_h).sqrt() as u32;\n\n    //     // For q = 2^32:\n    //     // t2 ≈ log_b2(q) = log_13(2^32) = 32/log_2(13) ≈ 32/3.7 ≈ 8.65 =\u003e 9\n    //     let expected_t2 = ((32.0 / (expected_b2 as f64).log2()).ceil() as usize).max(2);\n\n    //     // t1 ≈ log_b1(q) = log_9(2^32) = 32/log_2(9) ≈ 32/3.17 ≈ 10.09 =\u003e 11\n    //     let expected_t1 = ((32.0 / (expected_b1 as f64).log2()).ceil() as usize).max(2);\n\n    //     // Call the function under test\n    //     let params =\n    //         GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::calculate_optimal_parameters(\n    //             n, d, s, beta,\n    //         );\n\n    //     // Check results\n    //     assert!(\n    //         params.g_base.to_u128() \u003e= expected_b2 as u128 - 1\n    //             \u0026\u0026 params.g_base.to_u128() \u003c= expected_b2 as u128 + 1,\n    //         \"g_base {}, expected {}\",\n    //         params.g_base.to_u128(),\n    //         expected_b2\n    //     );\n\n    //     assert!(\n    //         params.h_base.to_u128() \u003e= expected_b1 as u128 - 1\n    //             \u0026\u0026 params.h_base.to_u128() \u003c= expected_b1 as u128 + 1,\n    //         \"h_base {}, expected {}\",\n    //         params.h_base.to_u128(),\n    //         expected_b1\n    //     );\n\n    //     // For part counts, use approximate comparison due to potential floating point differences\n    //     assert!(\n    //         params.g_parts \u003e= expected_t2 - 1 \u0026\u0026 params.g_parts \u003c= expected_t2 + 1,\n    //         \"g_parts {}, expected {}\",\n    //         params.g_parts,\n    //         expected_t2\n    //     );\n\n    //     assert!(\n    //         params.h_parts \u003e= expected_t1 - 1 \u0026\u0026 params.h_parts \u003c= expected_t1 + 1,\n    //         \"h_parts {}, expected {}\",\n    //         params.h_parts,\n    //         expected_t1\n    //     );\n    // }\n\n    // #[test]\n    // fn test_error_handling() {\n    //     let params = AjtaiParameters::new(Zq::ONE, Zq::ONE).unwrap();\n    //     let mut rng = rand::rng();\n    //     let nu1_matrix = RqMatrix::\u003cTEST_M, TEST_N, TEST_D\u003e::random(\u0026mut rng);\n    //     let nu2_matrix = RqMatrix::\u003cTEST_M, TEST_N, TEST_D\u003e::random(\u0026mut rng);\n\n    //     // Test invalid g_base (≤ 1)\n    //     let invalid_g_base = GarbageParameters {\n    //         g_base: Zq::ONE, // Invalid: base must be \u003e 1\n    //         g_parts: 2,\n    //         h_base: Zq::new(4),\n    //         h_parts: 3,\n    //     };\n\n    //     let result = GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::new(\n    //         params.clone(),\n    //         nu1_matrix.clone(),\n    //         nu2_matrix.clone(),\n    //         invalid_g_base,\n    //     );\n\n    //     assert!(result.is_err(), \"Should reject g_base ≤ 1\");\n    //     match result {\n    //         Err(HierarchicalError::InvalidBase(_)) =\u003e {} // Expected error\n    //         _ =\u003e panic!(\"Wrong error type for invalid g_base\"),\n    //     }\n\n    //     // Test invalid g_parts (0)\n    //     let invalid_g_parts = GarbageParameters {\n    //         g_base: Zq::new(8),\n    //         g_parts: 0, // Invalid: parts must be \u003e 0\n    //         h_base: Zq::new(4),\n    //         h_parts: 3,\n    //     };\n\n    //     let result = GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::new(\n    //         params.clone(),\n    //         nu1_matrix.clone(),\n    //         nu2_matrix.clone(),\n    //         invalid_g_parts,\n    //     );\n\n    //     assert!(result.is_err(), \"Should reject g_parts = 0\");\n    //     match result {\n    //         Err(HierarchicalError::InvalidPartCount(_)) =\u003e {} // Expected error\n    //         _ =\u003e panic!(\"Wrong error type for invalid g_parts\"),\n    //     }\n\n    //     // Test invalid h_base (≤ 1)\n    //     let invalid_h_base = GarbageParameters {\n    //         g_base: Zq::new(8),\n    //         g_parts: 2,\n    //         h_base: Zq::ZERO, // Invalid: base must be \u003e 0\n    //         h_parts: 3,\n    //     };\n\n    //     let result = GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::new(\n    //         params.clone(),\n    //         nu1_matrix.clone(),\n    //         nu2_matrix.clone(),\n    //         invalid_h_base,\n    //     );\n\n    //     assert!(result.is_err(), \"Should reject h_base ≤ 1\");\n    //     match result {\n    //         Err(HierarchicalError::InvalidBase(_)) =\u003e {} // Expected error\n    //         _ =\u003e panic!(\"Wrong error type for invalid h_base\"),\n    //     }\n\n    //     // Test invalid h_parts (0)\n    //     let invalid_h_parts = GarbageParameters {\n    //         g_base: Zq::new(8),\n    //         g_parts: 2,\n    //         h_base: Zq::new(4),\n    //         h_parts: 0, // Invalid: parts must be \u003e 0\n    //     };\n\n    //     let result = GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::new(\n    //         params.clone(),\n    //         nu1_matrix.clone(),\n    //         nu2_matrix,\n    //         invalid_h_parts,\n    //     );\n\n    //     assert!(result.is_err(), \"Should reject h_parts = 0\");\n    //     match result {\n    //         Err(HierarchicalError::InvalidPartCount(_)) =\u003e {} // Expected error\n    //         _ =\u003e panic!(\"Wrong error type for invalid h_parts\"),\n    //     }\n    // }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":4}},{"line":8,"address":[],"length":0,"stats":{"Line":4}},{"line":9,"address":[],"length":0,"stats":{"Line":16}},{"line":11,"address":[],"length":0,"stats":{"Line":24}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":16}},{"line":34,"address":[],"length":0,"stats":{"Line":24}},{"line":48,"address":[],"length":0,"stats":{"Line":4}}],"covered":11,"coverable":11},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","inner_product.rs"],"content":"use std::{\n    borrow::Borrow,\n    ops::{Add, Mul},\n};\n\npub fn compute_linear_combination\u003cE, B, C\u003e(elements: \u0026[E], challenges: \u0026[C]) -\u003e B\nwhere\n    E: Borrow\u003cB\u003e,\n    for\u003c'a\u003e \u0026'a B: Mul\u003c\u0026'a C, Output = B\u003e,\n    for\u003c'a\u003e \u0026'a B: Add\u003c\u0026'a B, Output = B\u003e,\n{\n    debug_assert_eq!(\n        elements.len(),\n        challenges.len(),\n        \"vectors must be the same length\"\n    );\n    debug_assert!(!elements.is_empty(), \"`elements` must not be empty\");\n\n    let mut zipped_iter = elements.iter().zip(challenges.iter());\n    // Must do the following as the init value in fold requires size of B\n    let (e0, c0) = zipped_iter.next().unwrap();\n    let init = e0.borrow() * c0;\n\n    zipped_iter.fold(init, |acc, (elem, c)| \u0026acc + \u0026(elem.borrow() * c))\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":2345}},{"line":12,"address":[],"length":0,"stats":{"Line":2345}},{"line":13,"address":[],"length":0,"stats":{"Line":2345}},{"line":14,"address":[],"length":0,"stats":{"Line":2345}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":4690}},{"line":19,"address":[],"length":0,"stats":{"Line":2345}},{"line":21,"address":[],"length":0,"stats":{"Line":2345}},{"line":22,"address":[],"length":0,"stats":{"Line":2345}},{"line":24,"address":[],"length":0,"stats":{"Line":30604}}],"covered":9,"coverable":10},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","jl.rs"],"content":"use crate::ring;\nuse crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\n\n// LaBRADOR: Compact Proofs for R1CS from Module-SIS | Page 5 | Proving smallness section\nconst UPPER_BOUND_FACTOR: Zq = Zq::new(128);\nconst LOWER_BOUND_FACTOR: Zq = Zq::new(30);\n\npub struct Projection {\n    random_linear_map_vector: Vec\u003cRqMatrix\u003e,\n    security_level: usize,\n}\n\nimpl Projection {\n    pub fn new(random_linear_map_vector: Vec\u003cRqMatrix\u003e, security_level: usize) -\u003e Self {\n        Self {\n            random_linear_map_vector,\n            security_level,\n        }\n    }\n\n    fn compute_projection(\u0026self, index: usize, witness: \u0026RqVector) -\u003e Vec\u003cZq\u003e {\n        let mut projection = vec![Zq::ZERO; 2 * self.security_level];\n        let coefficients = witness.concatenate_coefficients();\n        for (i, pi_ij) in self.random_linear_map_vector[index]\n            .get_elements()\n            .iter()\n            .enumerate()\n        {\n            projection[i] = pi_ij\n                .concatenate_coefficients()\n                .iter()\n                .zip(coefficients.iter())\n                .map(|(m, s)| *m * *s)\n                .sum::\u003cZq\u003e();\n        }\n        projection\n    }\n\n    pub fn compute_batch_projection(\u0026self, witness_vector: \u0026[RqVector]) -\u003e Vec\u003cZq\u003e {\n        let mut result = vec![Zq::ZERO; 2 * self.security_level];\n        for (index_i, witness) in witness_vector.iter().enumerate() {\n            ring::zq::add_assign_two_zq_vectors(\n                \u0026mut result,\n                self.compute_projection(index_i, witness),\n            );\n        }\n        result\n    }\n\n    pub fn get_projection_matrices(\u0026self) -\u003e \u0026[RqMatrix] {\n        \u0026self.random_linear_map_vector\n    }\n\n    pub fn get_conjugated_projection_matrices(\u0026self) -\u003e Vec\u003cRqMatrix\u003e {\n        self.random_linear_map_vector\n            .iter()\n            .map(|pi_i| {\n                pi_i.get_elements()\n                    .iter()\n                    .map(|pi_ij| {\n                        pi_ij\n                            .get_elements()\n                            .iter()\n                            .map(|polynomial| polynomial.conjugate_automorphism())\n                            .collect()\n                    })\n                    .collect()\n            })\n            .collect()\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn norm_squared(projection: \u0026[Zq]) -\u003e Zq {\n        projection\n            .iter()\n            .map(|coeff| {\n                coeff.centered_mod(Zq::new(Zq::Q as u32))\n                    * coeff.centered_mod(Zq::new(Zq::Q as u32))\n            })\n            .sum()\n    }\n\n    // Function to verify upper bound of projection\n    pub fn verify_projection_upper_bound(projection: \u0026[Zq], beta_squared: Zq) -\u003e bool {\n        Self::norm_squared(projection) \u003c (UPPER_BOUND_FACTOR * beta_squared)\n    }\n\n    // Function to verify lower bound of projection\n    pub fn verify_projection_lower_bound(projection: \u0026[Zq], beta_squared: Zq) -\u003e bool {\n        Self::norm_squared(projection) \u003e (LOWER_BOUND_FACTOR * beta_squared)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::relation::witness::Witness;\n    use crate::transcript::sponges::shake::ShakeSponge;\n    use crate::transcript::{LabradorTranscript, Sponge};\n    use rand::rng;\n\n    // Test that the probability of the inequality being true is close to 1/2\n    #[test]\n    #[cfg(not(feature = \"skip-slow-tests\"))]\n    fn test_projection_is_smaller_than_upper_bound() {\n        use crate::transcript::Sponge;\n\n        let (security_parameter, rank, multiplicity) = (128, 5, 1);\n        // 1000 was chosen to provide a reasonably large sample size\n\n        let trials: f64 = 1000.0;\n        let mut success_count: f64 = 0.0;\n        for _ in 0..1000 {\n            let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n            // This gives randomness to the transcript, to generate random projection matrices.\n            transcript.set_u1(RqVector::random(\u0026mut rng(), 1));\n            let projections =\n                transcript.generate_projections(security_parameter, rank, multiplicity);\n\n            let witness = RqVector::random(\u0026mut rand::rng(), rank);\n            let result = projections.compute_projection(0, \u0026witness);\n\n            let beta = witness.l2_norm_squared();\n            // Check if the norm of the projection is smaller than 128 * (squared norm of the projection of the random polynomial)\n            let test: bool = Projection::verify_projection_upper_bound(\u0026result, beta);\n            if test {\n                success_count += 1.0;\n            }\n        }\n\n        let observed_probability = success_count / trials;\n\n        // We allow some tolerance because of the statistical nature of the results.\n        let tolerance = 0.05;\n        assert!(\n            (observed_probability - 0.5).abs() \u003c tolerance,\n            \"Observed probability {} is not close to 0.5\",\n            observed_probability\n        );\n    }\n\n    // On average the projected norm squared is the same as 128 * vector norm squared\n    #[test]\n    #[cfg(not(feature = \"skip-slow-tests\"))]\n    fn test_projection_average_value() {\n        use crate::{relation::witness::Witness, transcript::Sponge};\n\n        let (security_parameter, rank, multiplicity) = (128, 3, 1);\n        let trials: u128 = 10000;\n\n        // let witness = RqVector::random_ternary(\u0026mut rand::rng(), rank);\n        let witness = Witness::new(rank, multiplicity, Zq::new(6400)).s;\n        let witness_norm = (128 * witness[0].l2_norm_squared().to_u128()) as f64;\n\n        let mut norm_sum = 0u128;\n        // Run the test multiple times to simulate the probability\n        for _ in 0..trials {\n            let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n            // This gives randomness to the transcript, to generate random projection matrices.\n            transcript.set_u1(RqVector::random(\u0026mut rng(), 1));\n            let projections =\n                transcript.generate_projections(security_parameter, rank, multiplicity);\n            let result = projections.compute_projection(0, \u0026witness[0]);\n            norm_sum += Projection::norm_squared(\u0026result).to_u128();\n        }\n\n        // Calculate the observed probability\n        let average = norm_sum as f64 / trials as f64;\n        let ratio = if witness_norm \u003c= average {\n            average / witness_norm\n        } else {\n            witness_norm / average\n        };\n\n        // we choose a small tolerance value for possible statistical error\n        let tolerance_percent: f64 = 1.01;\n        assert!(\n            ratio \u003c tolerance_percent,\n            \"Average norm value {} is not equal to {}.\",\n            average,\n            witness_norm,\n        );\n    }\n\n    // Test lower bound verification\n    #[test]\n    fn test_lower_bound() {\n        let (security_parameter, rank, multiplicity) = (128, 5, 1);\n\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        transcript.set_u1(RqVector::random(\u0026mut rng(), 1));\n        let projections = transcript.generate_projections(security_parameter, rank, multiplicity);\n        let witness = Witness::new(rank, multiplicity, Zq::new(6400)).s;\n\n        let beta = witness[0].l2_norm_squared();\n        // Check if the norm of the projection is bigger than 30 * (squared norm of the projection of the random polynomial)\n        assert!(Projection::verify_projection_lower_bound(\n            \u0026projections.compute_projection(0, \u0026witness[0]),\n            beta\n        ));\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":7}},{"line":24,"address":[],"length":0,"stats":{"Line":7}},{"line":25,"address":[],"length":0,"stats":{"Line":7}},{"line":26,"address":[],"length":0,"stats":{"Line":1799}},{"line":27,"address":[],"length":0,"stats":{"Line":7}},{"line":28,"address":[],"length":0,"stats":{"Line":7}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":573440}},{"line":38,"address":[],"length":0,"stats":{"Line":7}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":8}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":9}},{"line":61,"address":[],"length":0,"stats":{"Line":9}},{"line":62,"address":[],"length":0,"stats":{"Line":2313}},{"line":63,"address":[],"length":0,"stats":{"Line":2304}},{"line":64,"address":[],"length":0,"stats":{"Line":2304}},{"line":65,"address":[],"length":0,"stats":{"Line":2304}},{"line":66,"address":[],"length":0,"stats":{"Line":16128}},{"line":67,"address":[],"length":0,"stats":{"Line":2304}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":257}},{"line":79,"address":[],"length":0,"stats":{"Line":256}},{"line":80,"address":[],"length":0,"stats":{"Line":256}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}}],"covered":35,"coverable":37},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","mod.rs"],"content":"pub mod aggregate;\npub mod garbage_polynomials;\npub mod inner_product;\npub mod jl;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","lib.rs"],"content":"// Documentation\n\n// Main Introduction\n#![forbid(unsafe_code)]\n#![deny(clippy::as_conversions)]\n#![doc = include_str!(\"../doc/mainpage-doc.md\")]\n// Arithmetic Circuit Translation\n#![doc = include_str!(\"../doc/arithmetic_circuit_translation.md\")]\n// Ajtai Commitment\n#![doc = include_str!(\"../doc/ajtai_commitment.md\")]\n// Hierarchical Commitment\n#![doc = include_str!(\"../doc/hierarchical_commitment.md\")]\n// Projections\n#![doc = include_str!(\"../doc/projections.md\")]\n// Aggregation\n#![doc = include_str!(\"../doc/aggregation.md\")]\n// Amortization\n#![doc = include_str!(\"../doc/amortization.md\")]\n\npub mod commitments;\npub mod core;\npub mod prover;\npub mod relation;\npub mod ring;\npub mod transcript;\npub mod verifier;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","main.rs"],"content":"// use labrador::core::jl::{verify_upper_bound, ProjectionMatrix, ProjectionVector};\n// use labrador::ring::rq::Rq;\n// use labrador::ring::rq_vector::RqVector;\n// use labrador::ring::zq::Zq;\n// use rand::rng;\n\n// const D: usize = 4; // Degree of polynomials in S_i\n// const N: usize = 5; // Size of S_i\n\n// fn main() {\n//     // Example poly_ring\n//     let p1: Rq\u003cD\u003e = vec![Zq::new(1)].into();\n//     let p2: Rq\u003cD\u003e = vec![Zq::new(2), Zq::new(1), Zq::new(1)].into();\n//     // Perform polynomial multiplication\n//     let product = p1.clone() * p2.clone();\n\n//     // Perform polynomial addition\n//     let sum = p1.clone() + p2.clone();\n\n//     // Perform polynomial subtraction\n//     let sub = p1.clone() - p2.clone();\n\n//     // Compute the dot product between the polynomial coefficients\n//     let dot = p1.clone().inner_product(\u0026p2);\n\n//     // Negate the polynomial\n//     let negation = -p1.clone();\n\n//     // Perform scalar multiplication\n//     let scalar_multiplication = p1.scalar_mul(Zq::new(2));\n\n//     // Evaluate the polynomial at x = 2\n//     let evaluation = p2.eval(Zq::new(2));\n\n//     // Check if the polynomial is the zero polynomial\n//     let zero_check = p1.is_zero();\n\n//     // Check if p1 is equal to p2\n//     let are_equal = p1.is_equal(\u0026p2);\n\n//     // Print the results\n//     println!(\"Product: {:?}\", product);\n//     println!(\"Sum: {:?}\", sum);\n//     println!(\"Subtraction: {:?}\", sub);\n//     println!(\"Dot product: {:?}\", dot);\n//     println!(\"Negation: {:?}\", negation);\n//     println!(\"Scalar multiplication: {:?}\", scalar_multiplication);\n//     println!(\"Evaluation at x=2: {:?}\", evaluation);\n//     println!(\"Is zero polynomial: {:?}\", zero_check);\n//     println!(\"Are polynomials equal: {:?}\", are_equal);\n\n//     let a = Zq::new(5);\n//     let b = Zq::new(3);\n//     println!(\"a + b = {}\", a + b);\n\n//     // Johnson Linderstrauss Projections\n//     // Example\n//     // Generate the random polynomials\n//     let n = 3;\n//     let mut rng = rng();\n//     let polynomials = RqVector::\u003cN, D\u003e::random_ternary(\u0026mut rng);\n//     // Random projection matrix\n//     let matrix = ProjectionMatrix::new(n);\n//     // Calculate projection\n//     let projection = ProjectionVector::new(\u0026matrix, \u0026polynomials);\n//     // Within bounds with probability 1/2\n//     let beta = polynomials.compute_norm_squared();\n//     println!(\"{}\", verify_upper_bound(projection, beta));\n// }\n\nfn main() {}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","prover.rs"],"content":"use crate::commitments::ajtai_commitment;\nuse crate::commitments::common_instances::AjtaiInstances;\nuse crate::commitments::outer_commitments;\nuse crate::commitments::outer_commitments::DecompositionParameters;\nuse crate::commitments::CommitError;\nuse crate::core::aggregate::FunctionsAggregation;\nuse crate::core::aggregate::ZeroConstantFunctionsAggregation;\nuse crate::core::garbage_polynomials;\nuse crate::core::inner_product;\nuse crate::core::jl::Projection;\nuse crate::relation::env_params;\nuse crate::relation::witness::Witness;\nuse crate::relation::{env_params::EnvironmentParameters, statement::Statement};\nuse crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\nuse crate::transcript::LabradorTranscript;\nuse crate::transcript::Sponge;\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum ProverError {\n    /// Indicates that the L2 norm (squared) of the witness exceeded the allowed threshold.\n    #[error(\"invalid witness size: norm_squared {norm_squared}, allowed {allowed}\")]\n    WitnessL2NormViolated { norm_squared: Zq, allowed: Zq },\n    #[error(\"Invalid Projection of index {index}. Expected {expected}, got {computed}\")]\n    ProjectionError {\n        index: usize,\n        expected: Zq,\n        computed: Zq,\n    },\n    #[error(\"commitment failure\")]\n    CommitError(#[from] ajtai_commitment::CommitError),\n    #[error(\"decomposition failure\")]\n    DecompositionError(#[from] outer_commitments::DecompositionError),\n}\n\npub struct LabradorProver\u003c'a\u003e {\n    params: \u0026'a EnvironmentParameters,\n    crs: \u0026'a AjtaiInstances,\n    witness: \u0026'a Witness,\n    st: \u0026'a Statement,\n    // Aggregation instances\n    constant_aggregator: ZeroConstantFunctionsAggregation\u003c'a\u003e,\n    funcs_aggregator: FunctionsAggregation\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e LabradorProver\u003c'a\u003e {\n    pub fn new(\n        params: \u0026'a EnvironmentParameters,\n        crs: \u0026'a AjtaiInstances,\n        witness: \u0026'a Witness,\n        st: \u0026'a Statement,\n    ) -\u003e Self {\n        Self {\n            params,\n            crs,\n            witness,\n            st,\n            constant_aggregator: ZeroConstantFunctionsAggregation::new(params),\n            funcs_aggregator: FunctionsAggregation::new(params),\n        }\n    }\n\n    fn compute_vector_ti(\u0026self) -\u003e Result\u003cRqMatrix, CommitError\u003e {\n        // Ajtai Commitments t_i = A * s_i\n        let commitments = self\n            .witness\n            .s\n            .iter()\n            .cloned()\n            .map(|s_i| self.crs.commitment_scheme_a.commit(\u0026s_i))\n            .collect::\u003cResult\u003cVec\u003c_\u003e, CommitError\u003e\u003e()?;\n\n        Ok(RqMatrix::new(commitments, false))\n    }\n\n    fn compute_u1\u003cS: Sponge\u003e(\n        \u0026mut self,\n        transcript: \u0026mut LabradorTranscript\u003cS\u003e,\n    ) -\u003e Result\u003c(RqMatrix, RqMatrix), ProverError\u003e {\n        let t_i = self.compute_vector_ti()?;\n        // g_ij = \u003cs_i, s_j\u003e\n        let garbage_polynomial_g = garbage_polynomials::compute_g(\u0026self.witness.s);\n        // calculate outer commitment u_1 = \\sum(B_ik * t_i^(k)) + \\sum(C_ijk * g_ij^(k))\n        let commitment_u1 = outer_commitments::compute_u1(\n            self.crs,\n            \u0026t_i,\n            DecompositionParameters::new(self.params.b, self.params.t_1)?,\n            \u0026garbage_polynomial_g,\n            DecompositionParameters::new(self.params.b, self.params.t_2)?,\n        );\n        transcript.set_u1(commitment_u1);\n        Ok((t_i, garbage_polynomial_g))\n    }\n\n    fn compute_p\u003cS: Sponge\u003e(\u0026self, transcript: \u0026mut LabradorTranscript\u003cS\u003e) -\u003e Projection {\n        let projections = transcript.generate_projections(\n            env_params::SECURITY_PARAMETER,\n            self.params.rank,\n            self.params.multiplicity,\n        );\n        let vector_p = projections.compute_batch_projection(\u0026self.witness.s);\n        transcript.set_vector_p(vector_p);\n        projections\n    }\n\n    fn compute_b_double_prime\u003cS: Sponge\u003e(\n        \u0026mut self,\n        transcript: \u0026mut LabradorTranscript\u003cS\u003e,\n        projections: \u0026Projection,\n    ) {\n        let vector_psi =\n            transcript.generate_vector_psi(self.params.const_agg_length, self.params.constraint_l);\n        let vector_omega = transcript\n            .generate_vector_omega(self.params.const_agg_length, env_params::SECURITY_PARAMETER);\n        // first aggregation\n        self.constant_aggregator\n            .calculate_agg_a_double_prime(\u0026vector_psi, \u0026self.st.a_ct);\n        self.constant_aggregator.calculate_agg_phi_double_prime(\n            \u0026self.st.phi_ct,\n            \u0026projections.get_conjugated_projection_matrices(),\n            \u0026vector_psi,\n            \u0026vector_omega,\n        );\n        let b_ct_aggr = self\n            .constant_aggregator\n            .calculate_agg_b_double_prime(\u0026self.witness.s);\n        transcript.set_vector_b_ct_aggr(b_ct_aggr);\n    }\n\n    fn compute_u2\u003cS: Sponge\u003e(\n        \u0026mut self,\n        transcript: \u0026mut LabradorTranscript\u003cS\u003e,\n    ) -\u003e Result\u003cRqMatrix, ProverError\u003e {\n        let alpha_vector = transcript.generate_rq_vector(self.params.constraint_k);\n        let beta_vector = transcript.generate_rq_vector(self.params.const_agg_length);\n        self.funcs_aggregator.calculate_aggr_phi(\n            \u0026self.st.phi_constraint,\n            self.constant_aggregator.get_phi_double_prime(),\n            \u0026alpha_vector,\n            \u0026beta_vector,\n        );\n\n        // Step 4: Calculate h_ij, u_2, and z starts: ---------------------------------------\n        let garbage_polynomial_h =\n            garbage_polynomials::compute_h(\u0026self.witness.s, self.funcs_aggregator.get_appr_phi());\n        let commitment_u2 = outer_commitments::compute_u2(\n            self.crs,\n            \u0026garbage_polynomial_h,\n            DecompositionParameters::new(self.params.b, self.params.t_1)?,\n        );\n        transcript.set_u2(commitment_u2);\n        Ok(garbage_polynomial_h)\n    }\n\n    // calculate z = c_1*s_1 + ... + c_r*s_r\n    fn compute_z\u003cS: Sponge\u003e(\u0026mut self, transcript: \u0026mut LabradorTranscript\u003cS\u003e) -\u003e RqVector {\n        let challenges =\n            transcript.generate_challenges(env_params::OPERATOR_NORM, self.params.multiplicity);\n        let z =\n            inner_product::compute_linear_combination(\u0026self.witness.s, challenges.get_elements());\n        z\n    }\n\n    /// all prove steps are from page 17\n    pub fn prove\u003cS: Sponge\u003e(\u0026mut self) -\u003e Result\u003cLabradorTranscript\u003cS\u003e, ProverError\u003e {\n        // Generate random challenges used between prover and verifier\n        let mut transcript = LabradorTranscript::new(S::default());\n\n        // Step 1: Outer commitments u_1 starts: --------------------------------------------\n        let (t_i, garbage_polynomial_g) = self.compute_u1(\u0026mut transcript)?;\n        // Step 1: Outer commitments u_1 ends: ----------------------------------------------\n\n        // Step 2: JL projection starts: ----------------------------------------------------\n        let projections = self.compute_p(\u0026mut transcript);\n        // Step 2: JL projection ends: ------------------------------------------------------\n\n        // Step 3: Aggregation starts: --------------------------------------------------------------\n        self.compute_b_double_prime(\u0026mut transcript, \u0026projections);\n\n        // second aggregation\n\n        // Aggregation ends: ----------------------------------------------------------------\n        let garbage_polynomial_h = self.compute_u2(\u0026mut transcript)?;\n\n        let z = self.compute_z(\u0026mut transcript);\n\n        transcript.set_recursive_part(z, t_i, garbage_polynomial_g, garbage_polynomial_h);\n\n        // Step 4: Calculate h_ij, u_2, and z ends: -----------------------------------------\n\n        Ok(transcript)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_prove() {\n        // set up example environment parameters, use default set for testing.\n        let ep_1 = EnvironmentParameters::default();\n        // generate a random witness based on environment parameters above\n        let witness_1 = Witness::new(ep_1.rank, ep_1.multiplicity, ep_1.beta);\n        // generate public statement based on witness_1\n        let st: Statement = Statement::new(\u0026witness_1, \u0026ep_1);\n        // generate the common reference string matrices A, B, C, D\n        let crs: AjtaiInstances = AjtaiInstances::new(\u0026ep_1);\n\n        // create a new prover\n        let mut prover = LabradorProver::new(\u0026ep_1, \u0026crs, \u0026witness_1, \u0026st);\n        let _: LabradorTranscript\u003cShakeSponge\u003e = prover.prove().unwrap();\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":10}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}}],"covered":59,"coverable":73},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","relation","env_params.rs"],"content":"#![allow(clippy::as_conversions)]\nuse crate::ring::{rq::Rq, zq::Zq};\n\n/// Security Parameter\npub const SECURITY_PARAMETER: usize = 128;\npub const OPERATOR_NORM: f64 = 15.0;\n\n// Example Environment parameters used for LaBRADOR, can be expanded as required by testing.\n#[derive(Clone)]\npub struct EnvironmentParameters {\n    /// Relation R Parameters\n    pub rank: usize, // size of each witness s_i\n    pub multiplicity: usize, // number of witness elements\n\n    /// Decomposition Parameters\n    pub b: Zq, // z decomposition base\n    pub b_1: usize, // t_i decomposition base\n    pub t_1: usize, // t_i number of parts\n    pub b_2: usize, // g_ij decomposition base\n    pub t_2: usize, // g_ij number of parts\n\n    /// Norm Bounds\n    pub beta: Zq, // Bound for witness s_i\n    pub gamma: Zq,   // Bound for z\n    pub gamma_1: Zq, // Bound for t\n    pub gamma_2: Zq, // Bound for g and h\n    pub beta_prime: Zq,\n\n    /// Commitment Matrices Sizes\n    pub kappa: usize, // Number of rows in A\n    pub kappa_1: usize, // Number of rows in B\n    pub kappa_2: usize, // Number of rows in C\n\n    /// Function Families Sizes\n    pub constraint_k: usize, // Number of constraints of the form f\n    pub constraint_l: usize,     // Number of constraints of the form f'\n    pub const_agg_length: usize, // Number of functions in the first aggregation step\n\n    /// Other Parameters\n    pub log_q: usize, // Size of log(q) in bits, where q is the modulo\n}\n\nimpl EnvironmentParameters {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        rank: usize,\n        multiplicity: usize,\n        beta: f64,\n        kappa: usize,\n        kappa_1: usize,\n        kappa_2: usize,\n        constraint_k: usize,\n        constraint_l: usize,\n        tau: f64,\n        modulo_q: usize,\n    ) -\u003e Self {\n        let std_s = Self::compute_std_s(rank, multiplicity, beta);\n\n        // balanced radix for z‑split\n        let base_b = Self::compute_base_b(std_s, multiplicity, tau);\n\n        // Decomposition parameters for t and h\n        let parts_t1 = Self::compute_t1(modulo_q, base_b);\n        let base_b1 = Self::compute_b1(modulo_q, parts_t1);\n\n        // Decomposition parameters for g\n        let parts_t2 = Self::compute_t2(rank, std_s, base_b);\n        let base_b2 = Self::compute_b2(rank, std_s, parts_t2);\n\n        let gamma = Self::compute_gamma(beta, tau);\n        let gamma_1 =\n            Self::compute_gamma1(base_b1, parts_t1, multiplicity, kappa, base_b2, parts_t2);\n        let gamma_2 = Self::compute_gamma2(base_b1, parts_t1, multiplicity);\n        let beta_prime = Self::compute_beta_prime(base_b, gamma, gamma_1, gamma_2);\n        let log_q = (modulo_q as f64).log2() as usize;\n        EnvironmentParameters {\n            rank,\n            multiplicity,\n            b: Zq::new(base_b as u32),\n            b_1: base_b1,\n            t_1: parts_t1,\n            b_2: base_b2,\n            t_2: parts_t2,\n            beta: Zq::new(beta as u32),\n            gamma: Zq::new(gamma as u32),\n            gamma_1: Zq::new(gamma_1 as u32),\n            gamma_2: Zq::new(gamma_2 as u32),\n            beta_prime: Zq::new(beta_prime as u32),\n            kappa,\n            kappa_1,\n            kappa_2,\n            constraint_k,\n            constraint_l,\n            const_agg_length: usize::div_ceil(SECURITY_PARAMETER, log_q),\n            log_q, // Size of log(q) in bits, where q is the modulo\n        }\n    }\n\n    // s = β / √(r·n·d)\n    fn compute_std_s(n: usize, r: usize, beta: f64) -\u003e f64 {\n        beta / ((r * n * Rq::DEGREE) as f64).sqrt()\n    }\n\n    /// b = round( √(√(12 r τ) · s) ), but at least 2\n    fn compute_base_b(s: f64, multiplicity: usize, tau: f64) -\u003e usize {\n        let raw = ((12.0 * multiplicity as f64 * tau).sqrt() * s).sqrt();\n        let mut b = raw.round() as usize;\n        if b \u003c 2 {\n            b = 2;\n        }\n        b\n    }\n\n    /// t₁ = round( log_q / log_b )\n    fn compute_t1(q: usize, b: usize) -\u003e usize {\n        let log_q = (q as f64).ln();\n        let log_b = (b as f64).ln();\n        (log_q / log_b).round() as usize\n    }\n\n    /// b₁ = ceil( q^(1/t₁) )\n    fn compute_b1(q: usize, t1: usize) -\u003e usize {\n        let root = (q as f64).powf(1.0 / t1 as f64);\n        root.ceil() as usize\n    }\n\n    /// t₂ = ceil( log(√(24 n d) · s^2) / log(b) )\n    fn compute_t2(n: usize, std_s: f64, b: usize) -\u003e usize {\n        (((24.0 * n as f64 * Rq::DEGREE as f64).sqrt() * std_s * std_s).ln() / (b as f64).ln())\n            .round() as usize\n    }\n\n    /// t₂ = ceil( log(√(24 n d) · s^2) / log(b) )\n    fn compute_b2(n: usize, std_s: f64, t2: usize) -\u003e usize {\n        ((24.0 * n as f64 * Rq::DEGREE as f64).sqrt() * std_s * std_s)\n            .powf(1.0 / t2 as f64)\n            .round() as usize\n    }\n\n    /// γ = β·√τ\n    fn compute_gamma(beta: f64, tau: f64) -\u003e f64 {\n        beta * (tau).sqrt()\n    }\n\n    /// γ₁ = √( (b₁² t₁ /12) · r κ d  +  (b₂² t₂ /12) · (r²+r)/2 · d )\n    #[allow(clippy::too_many_arguments)]\n    fn compute_gamma1(\n        b1: usize,\n        t1: usize,\n        multiplicity: usize,\n        kappa: usize,\n        b2: usize,\n        t2: usize,\n    ) -\u003e f64 {\n        let term1 =\n            (b1.pow(2) * t1) as f64 / 12.0 * multiplicity as f64 * kappa as f64 * Rq::DEGREE as f64;\n        let term2 = (b2.pow(2) * t2) as f64 / 12.0\n            * ((multiplicity * multiplicity + multiplicity) as f64)\n            / 2.0\n            * Rq::DEGREE as f64;\n        (term1 + term2).sqrt()\n    }\n\n    /// γ₂ = √( (b₁² t₁ /12) · (r²+r)/2 · d )\n    fn compute_gamma2(b1: usize, t1: usize, multiplicity: usize) -\u003e f64 {\n        let term = (b1.pow(2) * t1) as f64 / 12.0\n            * ((multiplicity * multiplicity + multiplicity) as f64)\n            / 2.0\n            * Rq::DEGREE as f64;\n        term.sqrt()\n    }\n\n    /// β' = √( 2 γ² / b²  +  γ₁²  +  γ₂² )\n    fn compute_beta_prime(b: usize, gamma: f64, gamma1: f64, gamma2: f64) -\u003e f64 {\n        let part_z = 2.0 * (gamma * gamma) / (b * b) as f64;\n        (part_z + gamma1 * gamma1 + gamma2 * gamma2).sqrt()\n    }\n}\n\nimpl Default for EnvironmentParameters {\n    fn default() -\u003e Self {\n        Self::new(5, 3, 65535.0, 4, 5, 5, 5, 5, 65535.0, (1u64 \u003c\u003c 32) as usize)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ring::zq::Zq;\n\n    use super::EnvironmentParameters;\n    use super::Rq;\n\n    #[test]\n    fn test_std_s_matches_formula() {\n        let (n, r, beta) = (12, 5, 42.0);\n        let result = EnvironmentParameters::compute_std_s(n, r, beta);\n        let expected = beta / ((r * n * Rq::DEGREE) as f64).sqrt();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_compute_base_b_not_below_two() {\n        let b = EnvironmentParameters::compute_base_b(0.001, 1, 0.0001);\n        assert!(b \u003e= 2);\n    }\n\n    #[test]\n    fn test_base_b_formula_and_floor() {\n        let s = 0.17;\n        let (r, tau) = (3, 12.0);\n        let result = EnvironmentParameters::compute_base_b(s, r, tau);\n        let expected = ((12.0 * r as f64 * tau).sqrt() * s).sqrt().round().max(2.0) as usize;\n        assert_eq!(result, expected, \"balanced radix b\");\n    }\n\n    #[test]\n    fn test_t1_rounding() {\n        let (q, b) = (257usize, 4usize); // ln(q)/ln(b)=~4.006\n        let result = EnvironmentParameters::compute_t1(q, b);\n        assert_eq!(result, 4, \"t1 = round(log_q / log_b)\");\n    }\n\n    #[test]\n    fn test_b1_is_ceil_root() {\n        let (q, t1) = (1usize \u003c\u003c 20, 5usize);\n        let result = EnvironmentParameters::compute_b1(q, t1);\n        let expected = (q as f64).powf(1.0 / t1 as f64).ceil() as usize;\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_t1_and_b1_are_consistent() {\n        let q = 1usize \u003c\u003c 23;\n        let b = 137usize;\n        let t1 = EnvironmentParameters::compute_t1(q, b);\n        let b1 = EnvironmentParameters::compute_b1(q, t1);\n        assert!(b1.pow(t1 as u32) \u003e= q);\n    }\n\n    #[test]\n    fn test_t2_b2_pair_match() {\n        let (n, s, b) = (10usize, 0.12, 150usize);\n        let t2: usize = EnvironmentParameters::compute_t2(n, s, b);\n        let b2 = EnvironmentParameters::compute_b2(n, s, t2);\n        // recompute tmp and double-check injectivity analogue\n        let tmp_ln = ((24.0 * n as f64 * Rq::DEGREE as f64).sqrt() * s * s).ln();\n        let expected_t2 = (tmp_ln / (b as f64).ln()).round() as usize;\n        assert_eq!(t2, expected_t2, \"t2 formula\");\n        let lhs = (b2 as f64).powf(t2 as f64);\n        let rhs = (24.0 * n as f64 * Rq::DEGREE as f64).sqrt() * s * s;\n        assert!(lhs \u003e= rhs - 1.0);\n    }\n\n    #[test]\n    fn test_gamma_functions() {\n        let (beta, tau) = (32.0, 49.0);\n        let gamma = EnvironmentParameters::compute_gamma(beta, tau);\n        assert_eq!(gamma, beta * tau.sqrt());\n\n        // simple numeric spot-check for γ₁, γ₂\n        let (b1, t1, r, kappa, b2, t2) = (7, 3, 2, 4, 5, 2);\n        let manual1 = ((b1 * b1 * t1) as f64 / 12.0 * r as f64 * kappa as f64 * Rq::DEGREE as f64\n            + (b2 * b2 * t2) as f64 / 12.0 * ((r * r + r) as f64) / 2.0 * Rq::DEGREE as f64)\n            .sqrt();\n        let got1 = EnvironmentParameters::compute_gamma1(b1, t1, r, kappa, b2, t2);\n        assert_eq!(got1, manual1);\n\n        let manual2 = ((b1.pow(2) * t1) as f64 / 12.0 * ((r * r + r) as f64) / 2.0\n            * Rq::DEGREE as f64)\n            .sqrt();\n        let got2 = EnvironmentParameters::compute_gamma2(b1, t1, r);\n        assert_eq!(got2, manual2);\n    }\n\n    #[test]\n    fn beta_prime_formula() {\n        let (b, gamma, g1, g2) = (11usize, 3.3, 7.7, 2.2);\n        let expected = ((2.0 * gamma * gamma) / (b * b) as f64 + g1 * g1 + g2 * g2).sqrt();\n        let result = EnvironmentParameters::compute_beta_prime(b, gamma, g1, g2);\n        assert_eq!(expected, result);\n    }\n\n    #[test]\n    fn test_gamma_and_beta_prime_are_positive() {\n        let beta = 100.0;\n        let tau = 64.0;\n        let gamma = EnvironmentParameters::compute_gamma(beta, tau);\n        assert!(gamma \u003e 0.0);\n        let beta_p = EnvironmentParameters::compute_beta_prime(3, gamma, 2.0, 1.0);\n        assert!(beta_p \u003e 0.0);\n    }\n\n    #[test]\n    fn default_instance_is_consistent() {\n        let p = EnvironmentParameters::default();\n\n        assert!(p.b \u003e= Zq::TWO \u0026\u0026 p.b_1 \u003e= 2 \u0026\u0026 p.b_2 \u003e= 2);\n        assert!(p.t_1 \u003e 0 \u0026\u0026 p.t_2 \u003e 0);\n\n        assert!((p.b_1 as u64).pow(p.t_1 as u32) \u003e= p.log_q as u64);\n        assert!((p.b_2 as u64).pow(p.t_2 as u32) \u003e 1);\n\n        // c)  norm bounds are non-negative\n        assert!(p.gamma \u003e Zq::ZERO \u0026\u0026 p.gamma_1 \u003e Zq::ZERO \u0026\u0026 p.gamma_2 \u003e Zq::ZERO);\n        assert!(p.beta_prime \u003e= p.gamma_1.max(p.gamma_2));\n    }\n\n    #[test]\n    fn random_parameter_sets_hold_invariants() {\n        for seed in 1..=20 {\n            let rank = 2 + seed as usize % 8; // 2..9\n            let multiplicity = 1 + seed as usize % 5; // 1..5\n            let beta = 10.0 + seed as f64;\n            let tau = 32.0 + seed as f64;\n            let q = (1usize \u003c\u003c 20) + (seed as usize * 12345);\n            let params =\n                EnvironmentParameters::new(rank, multiplicity, beta, 4, 4, 4, 3, 3, tau, q);\n\n            // main invariants\n            assert!(params.b \u003e= Zq::TWO);\n            assert!(params.t_1 \u003e= 1 \u0026\u0026 params.t_2 \u003e= 1);\n            assert!((params.b_1 as u64).pow(params.t_1 as u32) \u003e= q as u64);\n            assert!(params.gamma \u003e Zq::ZERO);\n            assert!(params.beta_prime \u003e= params.gamma_1.max(params.gamma_2));\n        }\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":24}},{"line":57,"address":[],"length":0,"stats":{"Line":24}},{"line":60,"address":[],"length":0,"stats":{"Line":24}},{"line":63,"address":[],"length":0,"stats":{"Line":24}},{"line":64,"address":[],"length":0,"stats":{"Line":24}},{"line":67,"address":[],"length":0,"stats":{"Line":24}},{"line":68,"address":[],"length":0,"stats":{"Line":24}},{"line":70,"address":[],"length":0,"stats":{"Line":24}},{"line":71,"address":[],"length":0,"stats":{"Line":24}},{"line":72,"address":[],"length":0,"stats":{"Line":24}},{"line":73,"address":[],"length":0,"stats":{"Line":24}},{"line":74,"address":[],"length":0,"stats":{"Line":24}},{"line":75,"address":[],"length":0,"stats":{"Line":24}},{"line":79,"address":[],"length":0,"stats":{"Line":24}},{"line":84,"address":[],"length":0,"stats":{"Line":24}},{"line":85,"address":[],"length":0,"stats":{"Line":24}},{"line":86,"address":[],"length":0,"stats":{"Line":24}},{"line":87,"address":[],"length":0,"stats":{"Line":24}},{"line":88,"address":[],"length":0,"stats":{"Line":24}},{"line":94,"address":[],"length":0,"stats":{"Line":24}},{"line":100,"address":[],"length":0,"stats":{"Line":25}},{"line":101,"address":[],"length":0,"stats":{"Line":25}},{"line":105,"address":[],"length":0,"stats":{"Line":26}},{"line":106,"address":[],"length":0,"stats":{"Line":26}},{"line":107,"address":[],"length":0,"stats":{"Line":26}},{"line":108,"address":[],"length":0,"stats":{"Line":27}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":26}},{"line":115,"address":[],"length":0,"stats":{"Line":26}},{"line":116,"address":[],"length":0,"stats":{"Line":26}},{"line":117,"address":[],"length":0,"stats":{"Line":26}},{"line":118,"address":[],"length":0,"stats":{"Line":26}},{"line":122,"address":[],"length":0,"stats":{"Line":26}},{"line":123,"address":[],"length":0,"stats":{"Line":26}},{"line":124,"address":[],"length":0,"stats":{"Line":26}},{"line":128,"address":[],"length":0,"stats":{"Line":25}},{"line":129,"address":[],"length":0,"stats":{"Line":25}},{"line":130,"address":[],"length":0,"stats":{"Line":25}},{"line":134,"address":[],"length":0,"stats":{"Line":25}},{"line":135,"address":[],"length":0,"stats":{"Line":25}},{"line":136,"address":[],"length":0,"stats":{"Line":25}},{"line":137,"address":[],"length":0,"stats":{"Line":25}},{"line":141,"address":[],"length":0,"stats":{"Line":26}},{"line":142,"address":[],"length":0,"stats":{"Line":26}},{"line":147,"address":[],"length":0,"stats":{"Line":25}},{"line":155,"address":[],"length":0,"stats":{"Line":25}},{"line":156,"address":[],"length":0,"stats":{"Line":25}},{"line":157,"address":[],"length":0,"stats":{"Line":25}},{"line":158,"address":[],"length":0,"stats":{"Line":25}},{"line":159,"address":[],"length":0,"stats":{"Line":25}},{"line":160,"address":[],"length":0,"stats":{"Line":25}},{"line":161,"address":[],"length":0,"stats":{"Line":25}},{"line":165,"address":[],"length":0,"stats":{"Line":25}},{"line":166,"address":[],"length":0,"stats":{"Line":25}},{"line":167,"address":[],"length":0,"stats":{"Line":25}},{"line":168,"address":[],"length":0,"stats":{"Line":25}},{"line":169,"address":[],"length":0,"stats":{"Line":25}},{"line":170,"address":[],"length":0,"stats":{"Line":25}},{"line":174,"address":[],"length":0,"stats":{"Line":26}},{"line":175,"address":[],"length":0,"stats":{"Line":26}},{"line":176,"address":[],"length":0,"stats":{"Line":26}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}}],"covered":63,"coverable":63},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","relation","mod.rs"],"content":"pub mod env_params;\npub mod statement;\npub mod witness;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","relation","statement.rs"],"content":"use super::env_params::EnvironmentParameters;\nuse crate::relation::witness::Witness;\nuse crate::ring::rq::Rq;\nuse crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\n\nuse crate::core::inner_product;\n\n/// Statement is the input of the prover, which contains the constraints.\n/// All parameters are from line 1, st, in the verifier process, page 18 from the paper.\npub struct Statement {\n    // $a_{ij}^k$\n    pub a_constraint: Vec\u003cRqMatrix\u003e,\n    // $\\varphi_i^k$\n    pub phi_constraint: Vec\u003cVec\u003cRqVector\u003e\u003e,\n    // $b^{(k)}$\n    pub b_constraint: RqVector,\n    // $a_{ij}^{'(l)}$\n    pub a_ct: Vec\u003cRqMatrix\u003e,\n    // $\\varphi_i^{'(l)}$\n    pub phi_ct: Vec\u003cVec\u003cRqVector\u003e\u003e,\n    // $b_0^{'(l)}$\n    pub b_0_ct: Vec\u003cZq\u003e,\n}\n\nimpl Statement {\n    pub fn new(witness: \u0026Witness, ep: \u0026EnvironmentParameters) -\u003e Self {\n        // generate random a_constraint with size: constraint_k * r * n\n        let a_constraint: Vec\u003cRqMatrix\u003e = (0..ep.constraint_k)\n            .map(|_| RqMatrix::symmetric_random(\u0026mut rand::rng(), ep.multiplicity))\n            .collect();\n\n        // generate random phi_constraint with size: constraint_k * r * n\n        let phi_constraint: Vec\u003cVec\u003cRqVector\u003e\u003e = (0..ep.constraint_k)\n            .map(|_| {\n                (0..ep.multiplicity)\n                    .map(|_| RqVector::random(\u0026mut rand::rng(), ep.rank))\n                    .collect()\n            })\n            .collect();\n\n        // calculate b_constraint b^k with size: constraint_k\n        let b_constraint: RqVector = (0..ep.constraint_k)\n            .map(|k| calculate_b_constraint(\u0026witness.s, \u0026a_constraint[k], \u0026phi_constraint[k]))\n            .collect();\n\n        // generate example a_ct with size: constraint_l * r * n\n        let a_ct: Vec\u003cRqMatrix\u003e = (0..ep.constraint_l)\n            .map(|_| RqMatrix::symmetric_random(\u0026mut rand::rng(), ep.multiplicity))\n            .collect();\n\n        // generate random phi_ct with size: constraint_k * r * n\n        // it is a k length vector of matrix with size: r * n\n        let phi_ct: Vec\u003cVec\u003cRqVector\u003e\u003e = (0..ep.constraint_l)\n            .map(|_| {\n                (0..ep.multiplicity)\n                    .map(|_| RqVector::random(\u0026mut rand::rng(), ep.rank))\n                    .collect()\n            })\n            .collect();\n\n        // calculate b^l with size: constraint_l\n        let b_constraint_l: RqVector = (0..ep.constraint_l)\n            .map(|l| calculate_b_constraint(\u0026witness.s, \u0026a_ct[l], \u0026phi_ct[l]))\n            .collect();\n\n        // calculate b_0^l\n        let b_0_ct: Vec\u003cZq\u003e = (0..ep.constraint_l)\n            .map(|l| b_constraint_l.get_elements()[l].get_coefficients()[0])\n            .collect();\n\n        Self {\n            a_constraint,\n            phi_constraint,\n            b_constraint,\n            a_ct,\n            phi_ct,\n            b_0_ct,\n        }\n    }\n}\n\n/// calculate b^{k} = \\sum(a_{ij}^{k}\u003cs_i, s_j\u003e) + \\sum(\u003cphi_{i}^{k}, s_i\u003e), k \\in [K]\n/// in Prover initialization process, page 17 from the paper.\n///\n/// @param: s: s_i\n/// @param: a_constraint: a_{ij}^{k}\n/// @param: phi_constraint: \\phi_{i}^{k}\n///\n/// @return: b^{k}\n#[rustfmt::skip]\npub fn calculate_b_constraint(\n    s: \u0026[RqVector],\n    a_constraint: \u0026RqMatrix,\n    phi_constraint: \u0026[RqVector],\n) -\u003e Rq {\n    let size_s = s.len();\n    // calculate \\sum(a_{ij}^{k}\u003cs_i, s_j\u003e)\n    let left_side = (0..size_s).map(|i| {\n        (0..size_s).map(|j: usize| {\n            a_constraint.get_cell(i, j)\n                * \u0026inner_product::compute_linear_combination(s[i].get_elements(), s[j].get_elements())\n        })\n        .fold(Rq::zero(), |acc, val| \u0026acc + \u0026val )\n    })\n    .fold(Rq::zero(), |acc, val| \u0026acc + \u0026val );\n\n    // calculate \\sum(\u003cphi_{i}^{k}, s_i\u003e)\n    let right_side = (0..size_s).fold(Rq::zero(), |acc, i| {\n        \u0026acc + \u0026inner_product::compute_linear_combination(phi_constraint[i].get_elements(), s[i].get_elements())\n    });\n\n    \u0026left_side + \u0026right_side\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":14}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":50}},{"line":39,"address":[],"length":0,"stats":{"Line":10}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":14}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":14}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":10}},{"line":58,"address":[],"length":0,"stats":{"Line":50}},{"line":59,"address":[],"length":0,"stats":{"Line":10}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":14}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":14}},{"line":93,"address":[],"length":0,"stats":{"Line":20}},{"line":98,"address":[],"length":0,"stats":{"Line":20}},{"line":100,"address":[],"length":0,"stats":{"Line":80}},{"line":101,"address":[],"length":0,"stats":{"Line":240}},{"line":102,"address":[],"length":0,"stats":{"Line":180}},{"line":103,"address":[],"length":0,"stats":{"Line":180}},{"line":105,"address":[],"length":0,"stats":{"Line":300}},{"line":107,"address":[],"length":0,"stats":{"Line":100}},{"line":110,"address":[],"length":0,"stats":{"Line":80}},{"line":111,"address":[],"length":0,"stats":{"Line":60}},{"line":114,"address":[],"length":0,"stats":{"Line":20}}],"covered":32,"coverable":32},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","relation","witness.rs"],"content":"use rand::rng;\n\nuse crate::ring::{rq::Rq, rq_vector::RqVector, zq::Zq};\n\npub struct Witness {\n    pub s: Vec\u003cRqVector\u003e,\n}\n\nimpl Witness {\n    pub fn new(rank: usize, multiplicity: usize, bound: Zq) -\u003e Self {\n        #[allow(clippy::as_conversions)]\n        let std = (bound.get_value() as f64) / f64::sqrt((rank * multiplicity * Rq::DEGREE) as f64);\n        #[allow(clippy::as_conversions)]\n        let std = std as u32;\n        loop {\n            let s: Vec\u003cRqVector\u003e = (0..multiplicity)\n                .map(|_| RqVector::random_with_bound(\u0026mut rng(), rank, std))\n                .collect();\n            if Self::validate_l2_norm(\u0026s, bound) {\n                return Self { s };\n            }\n        }\n    }\n\n    fn validate_l2_norm(candidate: \u0026[RqVector], bound: Zq) -\u003e bool {\n        for witness in candidate {\n            if witness.l2_norm_squared() \u003e bound * bound {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use crate::ring::{rq::Rq, rq_vector::RqVector, zq::Zq};\n\n    use super::Witness;\n\n    #[test]\n    fn test_witness_vector_norm() {\n        let bound = Zq::new(320000);\n        let witness_vector = Witness::new(40, 100, bound);\n        assert_eq!(witness_vector.s.len(), 100);\n        assert_eq!(witness_vector.s[0].get_length(), 40);\n        for witness in witness_vector.s.iter() {\n            let l2_norm = witness.l2_norm_squared();\n            assert!(l2_norm \u003c bound * bound)\n        }\n    }\n\n    #[test]\n    fn test_witness_with_larger_bound() {\n        let poly1 = Rq::new([Zq::new(10000); Rq::DEGREE]);\n        let poly2 = Rq::new([Zq::new(142310); Rq::DEGREE]);\n        let poly3 = Rq::new([Zq::new(9310); Rq::DEGREE]);\n        let poly_vector = vec![poly1, poly2, poly3];\n        assert!(!Witness::validate_l2_norm(\n            \u0026[RqVector::new(poly_vector)],\n            Zq::new(1000)\n        ));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":6}},{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":14,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":121}},{"line":19,"address":[],"length":0,"stats":{"Line":6}},{"line":20,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":7}},{"line":26,"address":[],"length":0,"stats":{"Line":226}},{"line":27,"address":[],"length":0,"stats":{"Line":110}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":6}}],"covered":13,"coverable":13},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","mod.rs"],"content":"pub mod rq;\npub mod rq_matrix;\npub mod rq_vector;\npub mod zq;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","rq.rs"],"content":"// This file is part of the polynomial ring operations module.\n//\n//\n// Currently implemented functions include:\n// - Polynomial addition:          +\n// - Polynomial multiplication:    *\n// - inner_product/ Dot product:   inner_product()\n// - Polynomial subtraction:       -\n// - Polynomial negation:          neg()\n// - Scalar multiplication:        scalar_mul()\n// - Polynomial evaluation:        eval()\n// - Zero check:                   is_zero()\n// - Polynomial equality check:    is_equal()\n// - Get the Coefficients:         get_coefficients()\n// - Random small norm vector:     random_small_vector()\n// - Squared norm of coefficients: compute_norm_squared()\n//\n// Further operations and optimizations will be added in future versions.\n\n// We use the Zq ring\nuse crate::ring::zq::Zq;\nuse core::ops::{Add, Mul, Sub};\nuse rand::distr::{Distribution, Uniform};\nuse rand::{CryptoRng, Rng};\nuse rustfft::num_complex::Complex;\nuse rustfft::FftPlanner;\n\n/// This module provides implementations for various operations\n/// in the polynomial ring R = Z_q\\[X\\] / (X^d + 1).\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Rq {\n    coeffs: [Zq; Self::DEGREE],\n}\n\nimpl Rq {\n    pub const DEGREE: usize = 64;\n    /// Constructor for the polynomial ring\n    pub const fn new(coeffs: [Zq; Self::DEGREE]) -\u003e Self {\n        Rq { coeffs }\n    }\n\n    /// Generate zero polynomial\n    pub const fn zero() -\u003e Self {\n        Self {\n            coeffs: [Zq::ZERO; Self::DEGREE],\n        }\n    }\n\n    /// ```compile_fail\n    ///\n    /// let poly = Rq::zero(); // or any constructor you have\n    ///\n    /// // Move happens here …\n    /// let _coeffs = poly.into_coeffs();\n    ///\n    /// // …so using `poly` again must not compile:\n    /// let _still_here = poly; //^ ERROR use of moved value\n    /// ```\n    pub fn into_coeffs(self) -\u003e [Zq; Self::DEGREE] {\n        self.coeffs\n    }\n\n    /// Get the coefficients as a vector\n    pub fn get_coefficients(\u0026self) -\u003e \u0026[Zq; Self::DEGREE] {\n        \u0026self.coeffs\n    }\n\n    /// Generate random polynomial with a provided cryptographically secure RNG\n    pub fn random\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R) -\u003e Self {\n        let uniform = Uniform::new_inclusive(Zq::ZERO, Zq::NEG_ONE).unwrap();\n        let mut coeffs = [Zq::ZERO; Self::DEGREE];\n        coeffs.iter_mut().for_each(|c| *c = uniform.sample(rng));\n        Self { coeffs }\n    }\n\n    /// Generate random polynomial with a provided cryptographically secure RNG and given bound\n    pub fn random_with_bound\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, bound: u32) -\u003e Self {\n        let uniform = Uniform::new_inclusive(Zq::ZERO, Zq::new(bound)).unwrap();\n        let mut coeffs = [Zq::ZERO; Self::DEGREE];\n        coeffs.iter_mut().for_each(|c| {\n            *c = if rng.random_bool(0.5) {\n                -uniform.sample(rng)\n            } else {\n                uniform.sample(rng)\n            }\n        });\n        Self { coeffs }\n    }\n\n    #[allow(clippy::as_conversions)]\n    pub fn l2_norm_squared(\u0026self) -\u003e Zq {\n        self.coeffs\n            .iter()\n            .map(|coeff| {\n                coeff.centered_mod(Zq::new(Zq::Q as u32))\n                    * coeff.centered_mod(Zq::new(Zq::Q as u32))\n            })\n            .sum()\n    }\n\n    /// Decomposes a polynomial into base-B representation:\n    /// p = p⁽⁰⁾ + p⁽¹⁾·B + p⁽²⁾·B² + ... + p⁽ᵗ⁻¹⁾·B^(t-1)\n    /// Where each p⁽ⁱ⁾ has small coefficients, using centered representatives\n    pub fn decompose(\u0026self, base: Zq, num_parts: usize) -\u003e Vec\u003cRq\u003e {\n        debug_assert!(num_parts \u003e 0, \"num_parts must be positive\");\n        let mut parts = Vec::with_capacity(num_parts);\n        let mut initial_coeffs = *self.get_coefficients();\n\n        for _ in 0..num_parts - 1 {\n            // Extract low part (mod base, centered around 0)\n            let mut low_coeffs = [Zq::ZERO; Self::DEGREE];\n\n            for (low_c, coeff) in low_coeffs.iter_mut().zip(initial_coeffs.iter_mut()) {\n                let centered = coeff.centered_mod(base);\n                *low_c = centered;\n                *coeff = (*coeff - centered).scale_by(base);\n            }\n            parts.push(Self::new(low_coeffs));\n        }\n        parts.push(Self::new(initial_coeffs));\n        parts\n    }\n\n    /// Compute the conjugate automorphism \\sigma_{-1} of vector based on B) Constraints..., Page 21.\n    pub fn conjugate_automorphism(\u0026self) -\u003e Self {\n        let q_minus_1 = Zq::NEG_ONE;\n\n        let original_coefficients = self.get_coefficients();\n\n        let mut conjugated_coeffs = [Zq::ZERO; Rq::DEGREE];\n        conjugated_coeffs[0] = original_coefficients[0];\n\n        for (conj_coeff, original_coeff) in conjugated_coeffs\n            .iter_mut()\n            .skip(1)\n            .zip(original_coefficients.iter().rev())\n        {\n            *conj_coeff = original_coeff * q_minus_1;\n        }\n\n        Self::new(conjugated_coeffs)\n    }\n\n    /// Compute the operator norm of a polynomial given its coefficients.\n    /// The operator norm is defined as the maximum magnitude of the DFT (eigenvalues)\n    /// of the coefficient vector.\n    ///\n    /// Note that: The operator norm only affects the coefficients of the random PolyRings generated from the challenge space.\n    /// Prover and Verifier will not do the operator norm check, because random PolyRings are determined after generation.\n    /// Both party will have access to the same PolyRings through transcript,\n    #[allow(clippy::as_conversions)]\n    pub fn operator_norm(\u0026self) -\u003e f64 {\n        let coeffs = self.get_coefficients();\n        let n = coeffs.len();\n        let mut planner = FftPlanner::new();\n        let fft = planner.plan_fft_forward(n);\n\n        // Convert coefficients into complex numbers (with zero imaginary parts)\n        let mut buffer: Vec\u003cComplex\u003cf64\u003e\u003e = coeffs\n            .iter()\n            .map(|\u0026x| {\n                let half = Zq::NEG_ONE.scale_by(Zq::TWO);\n                let converted_value = if x \u003e half {\n                    x.to_u128() as f64 - Zq::NEG_ONE.to_u128() as f64 - 1.0\n                } else {\n                    x.to_u128() as f64\n                };\n                Complex {\n                    re: converted_value,\n                    im: 0.0,\n                }\n            })\n            .collect();\n\n        // Compute the FFT (this gives the eigenvalues of the circulant matrix)\n        fft.process(\u0026mut buffer);\n\n        // Return the maximum absolute value (norm) among the eigenvalues\n        buffer\n            .iter()\n            .map(|c| c.norm())\n            .fold(0.0, |max, x| max.max(x))\n    }\n}\n\nimpl Add\u003c\u0026Rq\u003e for \u0026Rq {\n    type Output = Rq;\n    /// Add two polynomials\n    fn add(self, other: \u0026Rq) -\u003e Rq {\n        let mut coeffs = [Zq::ZERO; Rq::DEGREE];\n        for (r, (a, b)) in coeffs\n            .iter_mut()\n            .zip(self.coeffs.iter().zip(other.coeffs.iter()))\n        {\n            *r = *a + *b;\n        }\n        Rq::new(coeffs)\n    }\n}\n\nimpl Sub\u003c\u0026Rq\u003e for \u0026Rq {\n    type Output = Rq;\n    /// Add two polynomials\n    fn sub(self, other: \u0026Rq) -\u003e Rq {\n        let mut coeffs = [Zq::ZERO; Rq::DEGREE];\n        for (r, (a, b)) in coeffs\n            .iter_mut()\n            .zip(self.coeffs.iter().zip(other.coeffs.iter()))\n        {\n            *r = *a - *b;\n        }\n        Rq::new(coeffs)\n    }\n}\n\nimpl Mul\u003c\u0026Rq\u003e for \u0026Rq {\n    type Output = Rq;\n    /// Polynomial multiplication modulo x^D + 1\n    fn mul(self, other: \u0026Rq) -\u003e Rq {\n        let mut result = [Zq::ZERO; Rq::DEGREE];\n        let mut out_of_field = [Zq::ZERO; Rq::DEGREE];\n        for (i, \u0026self_coeff) in self.coeffs.iter().enumerate() {\n            for (j, \u0026other_coeff) in other.coeffs.iter().enumerate() {\n                if i + j \u003c Rq::DEGREE {\n                    result[i + j] += self_coeff * other_coeff;\n                } else {\n                    out_of_field[(i + j) % Rq::DEGREE] += self_coeff * other_coeff;\n                }\n            }\n        }\n        // Process excess terms with sign adjustment\n        for i in (0..Rq::DEGREE).rev() {\n            result[i] -= out_of_field[i];\n        }\n        Rq::new(result)\n    }\n}\n\nimpl Mul\u003c\u0026Zq\u003e for \u0026Rq {\n    type Output = Rq;\n    /// Scalar multiplication of a polynomial\n    fn mul(self, other: \u0026Zq) -\u003e Rq {\n        let mut copied_coeffs = self.coeffs;\n        for elem in copied_coeffs.iter_mut() {\n            *elem *= *other;\n        }\n        Rq::new(copied_coeffs)\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n\n    pub fn generate_rq_from_zq_vector(vec: Vec\u003cZq\u003e) -\u003e Rq {\n        let mut temp = [Zq::ZERO; Rq::DEGREE];\n        // Process excess terms with sign adjustment\n        for i in (0..vec.len()).rev() {\n            let m = i / Rq::DEGREE;\n            let r = i % Rq::DEGREE;\n            let sign = if m % 2 == 0 { 1 } else { -1 };\n            if sign == 1 {\n                temp[r] += vec[i];\n            } else {\n                temp[r] -= vec[i];\n            }\n        }\n        Rq::new(temp)\n    }\n\n    mod helper {\n        use super::*;\n        pub fn padded(prefix: \u0026[Zq]) -\u003e [Zq; Rq::DEGREE] {\n            assert!(\n                prefix.len() \u003c= Rq::DEGREE,\n                \"too many coefficients for degree {}\",\n                Rq::DEGREE\n            );\n\n            let mut out = [Zq::ZERO; Rq::DEGREE];\n            out[..prefix.len()].copy_from_slice(prefix);\n            out\n        }\n\n        pub fn rq_from(prefix: \u0026[Zq]) -\u003e Rq {\n            Rq {\n                coeffs: padded(prefix),\n            }\n        }\n    }\n\n    // Test new() and polynomial creation\n    #[test]\n    fn test_new_and_create_poly() {\n        let coeffs = [Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)];\n        let poly = helper::rq_from(\u0026coeffs);\n        assert_eq!(poly.coeffs, helper::padded(\u0026coeffs));\n\n        // Direct conversion\n        let coeffs2 = [Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)];\n        let poly_from_vec_direct: Rq = generate_rq_from_zq_vector(coeffs.to_vec());\n        assert_eq!(poly_from_vec_direct.coeffs, helper::padded(\u0026coeffs2));\n    }\n\n    #[test]\n    fn test_into_coeffs_returns_correct() {\n        let mut coeffs = [Zq::ZERO; Rq::DEGREE];\n        coeffs[0] = Zq::ONE;\n        coeffs[0] = Zq::new(20);\n        coeffs[0] = Zq::new(3121);\n        coeffs[0] = Zq::new(40);\n        let poly: Rq = generate_rq_from_zq_vector(coeffs.to_vec());\n\n        let result = Rq::into_coeffs(poly); // or whatever constructor you have\n        assert_eq!(result, coeffs);\n    }\n\n    // Test addition of polynomials\n    #[test]\n    fn test_add() {\n        // Within bounds\n        let poly1: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let poly2: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(4), Zq::new(3), Zq::new(2), Zq::ONE]);\n        let result = \u0026poly1 + \u0026poly2;\n        assert_eq!(\n            result.coeffs,\n            helper::padded(\u0026[Zq::new(5), Zq::new(5), Zq::new(5), Zq::new(5)])\n        );\n\n        // Outside of bounds\n        let poly3: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let poly4: Rq =\n            generate_rq_from_zq_vector(vec![Zq::NEG_ONE, Zq::new(3), Zq::NEG_ONE, Zq::ONE]);\n        let result2 = \u0026poly3 + \u0026poly4;\n        assert_eq!(\n            result2.coeffs,\n            helper::padded(\u0026[Zq::ZERO, Zq::new(5), Zq::new(2), Zq::new(5)])\n        );\n        // Addition with zero polynomial\n        let poly5: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let poly6: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO]);\n        let result3 = \u0026poly5 + \u0026poly6;\n        assert_eq!(\n            result3.coeffs,\n            helper::padded(\u0026[Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)])\n        );\n        // Addition with high coefficients\n        let poly7: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::NEG_ONE]);\n        let poly8: Rq =\n            generate_rq_from_zq_vector(vec![Zq::NEG_ONE, Zq::NEG_ONE, Zq::NEG_ONE, Zq::NEG_ONE]);\n        let result3 = \u0026poly7 + \u0026poly8;\n        assert_eq!(\n            result3.coeffs,\n            helper::padded(\u0026[Zq::ZERO, Zq::ONE, Zq::new(2), -Zq::new(2)])\n        );\n    }\n\n    // Test multiplication of polynomials\n    #[test]\n    fn test_mul() {\n        // Multiplication with wrapping\n        let poly1: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::new(2)]);\n        let poly2: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE]);\n        let result = \u0026poly1 * \u0026poly2;\n        assert_eq!(\n            result.coeffs,\n            helper::padded(\u0026[Zq::new(1), Zq::new(2), Zq::new(3), Zq::new(2)])\n        );\n\n        // Multiplication with zero polynomial\n        let poly3: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::new(2)]);\n        let poly4: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO]);\n        let result2 = \u0026poly3 * \u0026poly4;\n        assert_eq!(\n            result2.coeffs,\n            helper::padded(\u0026[Zq::ZERO, Zq::ZERO, Zq::ZERO])\n        );\n\n        // Needs to be revised later\n        // // Multiplication with wrapping higher order\n        // let poly5: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::new(2)]);\n        // let poly6: Rq = vec![Zq::ONE, Zq::ONE, Zq::new(7), Zq::new(5)].into();\n        // let result3 = poly5 * poly6;\n        // assert_eq!(\n        //     result3.coeffs,\n        //     helper::padded(\u0026[Zq::new(u32::MAX - 12), Zq::new(u32::MAX - 16), Zq::ZERO])\n        // );\n    }\n\n    // Test subtraction of polynomials\n    #[test]\n    fn test_sub() {\n        // within bounds\n        let poly1: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(5), Zq::new(10), Zq::new(15), Zq::new(20)]);\n        let poly2: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(2), Zq::new(4), Zq::new(6), Zq::new(8)]);\n        let result = \u0026poly1 - \u0026poly2;\n        assert_eq!(\n            result.coeffs,\n            helper::padded(\u0026[Zq::new(3), Zq::new(6), Zq::new(9), Zq::new(12)])\n        );\n\n        // Outside of bounds\n        let poly3: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::new(3), Zq::new(2)]);\n        let poly4: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(2), Zq::new(4), Zq::new(6), Zq::new(8)]);\n        let result2 = \u0026poly3 - \u0026poly4;\n        assert_eq!(\n            result2.coeffs,\n            helper::padded(\u0026[\n                Zq::ZERO - Zq::new(1),\n                Zq::ZERO - Zq::new(3),\n                Zq::ZERO - Zq::new(3),\n                Zq::ZERO - Zq::new(6),\n            ])\n        );\n        // Subtraction with zero polynomial\n        let poly5: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let poly6: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO]);\n        let result3 = \u0026poly6 - \u0026poly5;\n        let result4 = \u0026poly5 - \u0026poly6;\n        assert_eq!(\n            result3.coeffs,\n            helper::padded(\u0026[\n                Zq::ZERO - Zq::new(1),\n                Zq::ZERO - Zq::new(2),\n                Zq::ZERO - Zq::new(3),\n                Zq::ZERO - Zq::new(4),\n            ])\n        );\n        assert_eq!(\n            result4.coeffs,\n            helper::padded(\u0026[Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)])\n        );\n    }\n\n    // Test scalar multiplication\n    #[test]\n    fn test_scalar_mul() {\n        let poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let result = \u0026poly * \u0026Zq::new(2);\n        assert_eq!(\n            result.coeffs,\n            helper::padded(\u0026[Zq::new(2), Zq::new(4), Zq::new(6), Zq::new(8)])\n        );\n    }\n\n    // Test coefficient extraction\n    #[test]\n    fn test_get_coefficient() {\n        let poly: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ZERO, Zq::new(5), Zq::NEG_ONE]);\n        let vec = helper::padded(\u0026[Zq::ONE, Zq::ZERO, Zq::new(5), Zq::NEG_ONE]).to_vec();\n        assert!(poly.get_coefficients().to_vec() == vec);\n\n        let poly_zero: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO]);\n        let vec_zero = helper::padded(\u0026[Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO]).to_vec();\n        assert!(poly_zero.get_coefficients().to_vec() == vec_zero);\n    }\n\n    #[test]\n    fn test_base2_decomposition() {\n        // Test case 1: Base 2 decomposition\n        let poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(5), Zq::new(3), Zq::new(7), Zq::new(1)]);\n        let parts = poly.decompose(Zq::TWO, 2);\n\n        // Part 0: remainders mod 2 (no centering needed for base 2)\n        assert_eq!(\n            parts[0].coeffs,\n            helper::padded(\u0026[\n                Zq::ONE, // 5 mod 2 = 1\n                Zq::ONE, // 3 mod 2 = 1\n                Zq::ONE, // 7 mod 2 = 1\n                Zq::ONE, // 1 mod 2 = 1\n            ])\n        );\n\n        // Part 1: quotients after division by 2\n        assert_eq!(\n            parts[1].coeffs,\n            helper::padded(\u0026[\n                Zq::new(2), // 5 div 2 = 2\n                Zq::ONE,    // 3 div 2 = 1\n                Zq::new(3), // 7 div 2 = 3\n                Zq::ZERO,   // 1 div 2 = 0\n            ])\n        );\n\n        // Verify Base 2 reconstruction coefficient by coefficient\n        for i in 0..4 {\n            let expected = poly.coeffs[i];\n            let actual = parts[0].coeffs[i] + parts[1].coeffs[i] * Zq::TWO;\n            assert_eq!(actual, expected, \"Base 2: Coefficient {} mismatch\", i);\n        }\n    }\n\n    #[test]\n    fn test_base3_decomposition() {\n        // Test case: Base 3 decomposition with centering\n        let specific_poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(8), Zq::new(11), Zq::new(4), Zq::new(15)]);\n        let parts = specific_poly.decompose(Zq::new(3), 2);\n\n        // Part 0: centered remainders mod 3\n        assert_eq!(\n            parts[0].coeffs,\n            helper::padded(\u0026[\n                Zq::NEG_ONE, // 8 mod 3 = 2 -\u003e -1 (centered)\n                Zq::NEG_ONE, // 11 mod 3 = 2 -\u003e -1 (centered)\n                Zq::ONE,     // 4 mod 3 = 1 -\u003e 1 (centered)\n                Zq::ZERO,    // 15 mod 3 = 0 -\u003e 0 (centered)\n            ])\n        );\n\n        // Part 1: quotients\n        assert_eq!(\n            parts[1].coeffs,\n            helper::padded(\u0026[\n                Zq::new(3), // (8 + 1) div 3 = 3\n                Zq::new(4), // (11 + 1) div 3 = 4\n                Zq::ONE,    // 4 div 3 = 1\n                Zq::new(5), // 15 div 3 = 5\n            ])\n        );\n\n        // Verify Base 3 reconstruction coefficient by coefficient\n        for i in 0..4 {\n            let expected = specific_poly.coeffs[i];\n            let p0 = parts[0].coeffs[i];\n            let p1 = parts[1].coeffs[i];\n            let actual = p0 + p1 * Zq::new(3);\n            assert_eq!(actual, expected, \"Base 3: Coefficient {} mismatch\", i);\n        }\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        // Test zero polynomial\n        let zero_poly: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO; 4]);\n        let parts = zero_poly.decompose(Zq::TWO, 2);\n        assert!(\n            // Check any polynomial is zero\n            parts\n                .iter()\n                .all(|p| p.get_coefficients().iter().all(|\u0026coeff| coeff == Zq::ZERO)),\n            \"Zero polynomial decomposition failed\"\n        );\n\n        // Test single part decomposition\n        let simple_poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let parts = simple_poly.decompose(Zq::TWO, 1);\n        assert_eq!(parts.len(), 1, \"Single part decomposition length incorrect\");\n        assert_eq!(\n            parts[0], simple_poly,\n            \"Single part decomposition value incorrect\"\n        );\n    }\n\n    #[test]\n    fn test_large_base_decomposition() {\n        // Test decomposition with larger bases (8 and 16)\n        let poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(120), Zq::new(33), Zq::new(255), Zq::new(19)]);\n\n        // Base 8 decomposition\n        let parts_base8 = poly.decompose(Zq::new(8), 2);\n\n        // Part 0: centered remainders mod 8\n        assert_eq!(\n            parts_base8[0].coeffs,\n            helper::padded(\u0026[\n                Zq::ZERO,    // 120 mod 8 = 0 -\u003e 0 (centered)\n                Zq::ONE,     // 33 mod 8 = 1 -\u003e 1 (centered)\n                Zq::NEG_ONE, // 255 mod 8 = 7 -\u003e -1 (centered)\n                Zq::new(3),  // 19 mod 8 = 3 -\u003e 3 (centered)\n            ])\n        );\n\n        // Part 1: quotients\n        assert_eq!(\n            parts_base8[1].coeffs,\n            helper::padded(\u0026[\n                Zq::new(15), // 120 div 8 = 15\n                Zq::new(4),  // 33 div 8 = 4\n                Zq::new(32), // (255 + 1) div 8 = 32\n                Zq::new(2),  // 19 div 8 = 2\n            ])\n        );\n\n        // Verify reconstruction coefficient by coefficient\n        for i in 0..4 {\n            let expected = poly.coeffs[i];\n            let p0 = parts_base8[0].coeffs[i];\n            let p1 = parts_base8[1].coeffs[i];\n            let actual = p0 + p1 * Zq::new(8);\n            assert_eq!(actual, expected, \"Base 8: Coefficient {} mismatch\", i);\n        }\n\n        // Base 16 decomposition\n        let parts_base16 = poly.decompose(Zq::new(16), 2);\n\n        // Verify reconstruction for base 16\n        for i in 0..4 {\n            let expected = poly.coeffs[i];\n            let p0 = parts_base16[0].coeffs[i];\n            let p1 = parts_base16[1].coeffs[i];\n            let actual = p0 + p1 * Zq::new(16);\n            assert_eq!(actual, expected, \"Base 16: Coefficient {} mismatch\", i);\n        }\n    }\n\n    #[test]\n    fn test_multi_part_decomposition() {\n        // Test with more than 2 parts\n        let poly: Rq = generate_rq_from_zq_vector(vec![\n            Zq::new(123),\n            Zq::new(456),\n            Zq::new(789),\n            Zq::new(101112),\n        ]);\n\n        // Decompose into 3 parts with base 4\n        let parts = poly.decompose(Zq::new(4), 3);\n        assert_eq!(parts.len(), 3, \"Should have 3 parts\");\n\n        // Test reconstruction with all 3 parts\n        let reconstructed =\n            \u0026(\u0026parts[0] + \u0026(\u0026(\u0026parts[1] * \u0026Zq::new(4)) + \u0026(\u0026parts[2] * \u0026Zq::new(16)))); // 4²\n\n        // Verify reconstruction coefficient by coefficient\n        for i in 0..4 {\n            assert_eq!(\n                reconstructed.coeffs[i], poly.coeffs[i],\n                \"3-part base 4: Coefficient {} mismatch\",\n                i\n            );\n        }\n    }\n\n    #[test]\n    fn test_centering_properties() {\n        // Test that centering works correctly for various values\n        // Using base 5 which has half_base = 2\n        let values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let poly: Rq =\n            generate_rq_from_zq_vector(values.iter().map(|\u0026v| Zq::new(v)).collect::\u003cVec\u003cZq\u003e\u003e());\n\n        let parts = poly.decompose(Zq::new(5), 2);\n\n        // Expected centered values for each coefficient:\n        // 0 mod 5 = 0 -\u003e 0\n        // 1 mod 5 = 1 -\u003e 1\n        // 2 mod 5 = 2 -\u003e 2 (at threshold)\n        // 3 mod 5 = 3 -\u003e -2 (centered)\n        // 4 mod 5 = 4 -\u003e -1 (centered)\n        // 5 mod 5 = 0 -\u003e 0\n        // ... and so on\n        let expected_centered = [\n            Zq::ZERO,    // 0 centered\n            Zq::ONE,     // 1 centered\n            Zq::new(2),  // 2 centered (at threshold)\n            -Zq::new(2), // 3 centered to -2\n            -Zq::ONE,    // 4 centered to -1\n            Zq::ZERO,    // 5 centered\n            Zq::ONE,     // 6 centered\n            Zq::new(2),  // 7 centered\n            -Zq::new(2), // 8 centered to -2\n            -Zq::ONE,    // 9 centered to -1\n            Zq::ZERO,    // 10 centered\n        ];\n\n        for (i, \u0026expected) in expected_centered.iter().enumerate() {\n            assert_eq!(\n                parts[0].coeffs[i], expected,\n                \"Base 5 centering: Coefficient {} incorrectly centered\",\n                i\n            );\n        }\n    }\n\n    #[test]\n    fn test_extreme_values() {\n        // Test with values near the extremes of the Zq range\n        let poly: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::NEG_ONE, -Zq::ONE]);\n\n        // Decompose with base 3\n        let parts = poly.decompose(Zq::new(3), 2);\n\n        // Verify reconstruction\n        let reconstructed = \u0026parts[0] + \u0026(\u0026parts[1] * \u0026Zq::new(3));\n\n        for i in 0..3 {\n            assert_eq!(\n                reconstructed.coeffs[i], poly.coeffs[i],\n                \"Extreme values: Coefficient {} mismatch\",\n                i\n            );\n        }\n\n        // Corrected test for high value divisibility\n        // u32::MAX = 4294967295, which equals 1431655765 * 3 + 0\n        // So u32::MAX mod 3 = 0, which remains 0 (no centering needed)\n        assert_eq!(parts[0].coeffs[1], -Zq::new(1)); // Remainder after division by 3\n        assert_eq!(parts[1].coeffs[1], Zq::ZERO); // Quotient\n\n        // Check u32::MAX - 1 as well\n        // 4294967294 mod 3 = 1, which remains 1 (no centering needed since 1 \u003c= half_base)\n        assert_eq!(parts[0].coeffs[2], Zq::NEG_ONE); // u32::MAX - 1 is the third coefficient\n        assert_eq!(parts[1].coeffs[2], Zq::ZERO); // Should be same quotient\n    }\n\n    #[test]\n    fn test_decomposition_properties() {\n        // Test the algebraic property that all coefficients in first part should be small\n        let poly: Rq = generate_rq_from_zq_vector(vec![\n            Zq::new(100),\n            Zq::new(200),\n            Zq::new(300),\n            Zq::new(400),\n            Zq::new(500),\n            Zq::new(600),\n            Zq::new(700),\n            Zq::new(800),\n        ]);\n\n        for base in [2, 3, 4, 5, 8, 10, 16].iter() {\n            let parts = poly.decompose(Zq::new(*base), 2);\n            let half_base = Zq::new(*base).scale_by(Zq::TWO);\n\n            // Check that all coefficients in first part are properly \"small\"\n            for coeff in parts[0].coeffs.iter() {\n                // In centered representation, all coefficients should be \u003c= half_base\n                let abs_coeff = if *coeff \u003e Zq::new(u32::MAX / 2) {\n                    Zq::ZERO - *coeff // Handle negative values (represented as large positive ones)\n                } else {\n                    *coeff\n                };\n\n                assert!(\n                    abs_coeff \u003c= half_base,\n                    \"Base {}: First part coefficient {} exceeds half-base {}\",\n                    base,\n                    coeff,\n                    half_base\n                );\n            }\n\n            // Verify reconstruction\n            let reconstructed = \u0026parts[0] + \u0026(\u0026parts[1] * \u0026Zq::new(*base));\n            assert_eq!(reconstructed, poly, \"Base {}: Reconstruction failed\", base);\n        }\n    }\n\n    #[test]\n    fn test_conjugate_automorphism() {\n        use crate::core::inner_product::compute_linear_combination;\n\n        let poly1 = helper::rq_from(\u0026[Zq::ONE, Zq::TWO, Zq::new(3)]);\n        let poly2 = helper::rq_from(\u0026[Zq::new(4), Zq::new(5), Zq::new(6)]);\n        let inner_12 =\n            compute_linear_combination(poly1.get_coefficients(), poly2.get_coefficients());\n        let conjugated_1 = poly1.conjugate_automorphism();\n        let inner_conjugated_12 = \u0026conjugated_1 * \u0026poly2;\n\n        assert_eq!(inner_conjugated_12.coeffs.len(), Rq::DEGREE);\n        assert_eq!(inner_conjugated_12.get_coefficients()[0], Zq::new(32));\n        assert_eq!(inner_conjugated_12.get_coefficients()[1], Zq::new(17));\n        assert_eq!(inner_conjugated_12.get_coefficients()[2], Zq::new(6));\n\n        // ct\u003c\\sigma_{-1}(poly1), poly2\u003e ?= \u003cpoly1, poly2\u003e\n        let ct_inner_conjugated_12 = inner_conjugated_12.get_coefficients()[0];\n        assert_eq!(ct_inner_conjugated_12, inner_12);\n    }\n\n    // Test the square of the norm\n    #[test]\n    fn test_norm() {\n        let poly1 = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ZERO, Zq::new(5), Zq::NEG_ONE]);\n        let poly2 = generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::ZERO, Zq::new(5), Zq::ONE]);\n        let poly3 = generate_rq_from_zq_vector(vec![Zq::new(5), Zq::ONE, -Zq::new(6), Zq::ZERO]);\n        let poly4 = Rq::zero();\n\n        assert_eq!(poly1.l2_norm_squared(), Zq::new(27));\n        assert_eq!(poly2.l2_norm_squared(), Zq::new(26));\n        assert_eq!(poly3.l2_norm_squared(), Zq::new(62));\n        assert_eq!(poly4.l2_norm_squared(), Zq::ZERO);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":456620}},{"line":43,"address":[],"length":0,"stats":{"Line":579}},{"line":45,"address":[],"length":0,"stats":{"Line":579}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":279184}},{"line":65,"address":[],"length":0,"stats":{"Line":279184}},{"line":69,"address":[],"length":0,"stats":{"Line":2239}},{"line":70,"address":[],"length":0,"stats":{"Line":2239}},{"line":71,"address":[],"length":0,"stats":{"Line":2239}},{"line":72,"address":[],"length":0,"stats":{"Line":147774}},{"line":77,"address":[],"length":0,"stats":{"Line":4051}},{"line":78,"address":[],"length":0,"stats":{"Line":4051}},{"line":79,"address":[],"length":0,"stats":{"Line":4051}},{"line":80,"address":[],"length":0,"stats":{"Line":263315}},{"line":81,"address":[],"length":0,"stats":{"Line":259264}},{"line":82,"address":[],"length":0,"stats":{"Line":129987}},{"line":84,"address":[],"length":0,"stats":{"Line":129277}},{"line":91,"address":[],"length":0,"stats":{"Line":8153}},{"line":92,"address":[],"length":0,"stats":{"Line":8153}},{"line":94,"address":[],"length":0,"stats":{"Line":529945}},{"line":95,"address":[],"length":0,"stats":{"Line":521792}},{"line":96,"address":[],"length":0,"stats":{"Line":521792}},{"line":104,"address":[],"length":0,"stats":{"Line":117}},{"line":105,"address":[],"length":0,"stats":{"Line":234}},{"line":106,"address":[],"length":0,"stats":{"Line":117}},{"line":107,"address":[],"length":0,"stats":{"Line":117}},{"line":109,"address":[],"length":0,"stats":{"Line":117}},{"line":111,"address":[],"length":0,"stats":{"Line":213}},{"line":113,"address":[],"length":0,"stats":{"Line":13632}},{"line":120,"address":[],"length":0,"stats":{"Line":117}},{"line":121,"address":[],"length":0,"stats":{"Line":117}},{"line":125,"address":[],"length":0,"stats":{"Line":11521}},{"line":126,"address":[],"length":0,"stats":{"Line":11521}},{"line":128,"address":[],"length":0,"stats":{"Line":11521}},{"line":130,"address":[],"length":0,"stats":{"Line":11521}},{"line":131,"address":[],"length":0,"stats":{"Line":11521}},{"line":133,"address":[],"length":0,"stats":{"Line":737344}},{"line":134,"address":[],"length":0,"stats":{"Line":11521}},{"line":135,"address":[],"length":0,"stats":{"Line":11521}},{"line":136,"address":[],"length":0,"stats":{"Line":11521}},{"line":141,"address":[],"length":0,"stats":{"Line":11521}},{"line":152,"address":[],"length":0,"stats":{"Line":191}},{"line":153,"address":[],"length":0,"stats":{"Line":191}},{"line":154,"address":[],"length":0,"stats":{"Line":191}},{"line":155,"address":[],"length":0,"stats":{"Line":191}},{"line":156,"address":[],"length":0,"stats":{"Line":191}},{"line":159,"address":[],"length":0,"stats":{"Line":191}},{"line":161,"address":[],"length":0,"stats":{"Line":12415}},{"line":162,"address":[],"length":0,"stats":{"Line":12224}},{"line":163,"address":[],"length":0,"stats":{"Line":24448}},{"line":164,"address":[],"length":0,"stats":{"Line":3903}},{"line":166,"address":[],"length":0,"stats":{"Line":8321}},{"line":168,"address":[],"length":0,"stats":{"Line":12224}},{"line":169,"address":[],"length":0,"stats":{"Line":12224}},{"line":170,"address":[],"length":0,"stats":{"Line":12224}},{"line":176,"address":[],"length":0,"stats":{"Line":191}},{"line":179,"address":[],"length":0,"stats":{"Line":191}},{"line":181,"address":[],"length":0,"stats":{"Line":12606}},{"line":182,"address":[],"length":0,"stats":{"Line":12606}},{"line":189,"address":[],"length":0,"stats":{"Line":62600}},{"line":190,"address":[],"length":0,"stats":{"Line":62600}},{"line":191,"address":[],"length":0,"stats":{"Line":4069000}},{"line":192,"address":[],"length":0,"stats":{"Line":62600}},{"line":193,"address":[],"length":0,"stats":{"Line":62600}},{"line":197,"address":[],"length":0,"stats":{"Line":62600}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":206,"address":[],"length":0,"stats":{"Line":260}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":17499}},{"line":220,"address":[],"length":0,"stats":{"Line":17499}},{"line":221,"address":[],"length":0,"stats":{"Line":17499}},{"line":222,"address":[],"length":0,"stats":{"Line":1137435}},{"line":223,"address":[],"length":0,"stats":{"Line":71675904}},{"line":224,"address":[],"length":0,"stats":{"Line":36397920}},{"line":225,"address":[],"length":0,"stats":{"Line":36397920}},{"line":227,"address":[],"length":0,"stats":{"Line":35277984}},{"line":232,"address":[],"length":0,"stats":{"Line":1137435}},{"line":235,"address":[],"length":0,"stats":{"Line":17499}},{"line":242,"address":[],"length":0,"stats":{"Line":47358}},{"line":243,"address":[],"length":0,"stats":{"Line":47358}},{"line":244,"address":[],"length":0,"stats":{"Line":3078270}},{"line":247,"address":[],"length":0,"stats":{"Line":47358}}],"covered":86,"coverable":86},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","rq_matrix.rs"],"content":"use crate::{core::inner_product, ring::rq_vector::RqVector};\nuse rand::{CryptoRng, Rng};\nuse std::ops::Mul;\n\nuse super::{rq::Rq, zq::Zq};\n\n/// Matrix of polynomials in Rq\n#[derive(Debug, Clone)]\npub struct RqMatrix {\n    elements: Vec\u003cRqVector\u003e,\n    is_symmetric: bool,\n}\n\nimpl RqMatrix {\n    /// Constructor for the Matrix of polynomials in Rq\n    pub fn new(elements: Vec\u003cRqVector\u003e, is_symmetric: bool) -\u003e Self {\n        RqMatrix {\n            elements,\n            is_symmetric,\n        }\n    }\n\n    pub fn zero(row_len: usize, col_len: usize) -\u003e Self {\n        RqMatrix::new(vec![RqVector::zero(col_len); row_len], false)\n    }\n\n    pub fn symmetric_zero(size: usize) -\u003e Self {\n        Self {\n            elements: (0..size).map(|row| RqVector::zero(row + 1)).collect(),\n            is_symmetric: true,\n        }\n    }\n\n    pub fn get_row_len(\u0026self) -\u003e usize {\n        self.elements.len()\n    }\n\n    pub fn get_col_len(\u0026self) -\u003e usize {\n        let last_row = self.get_row_len() - 1;\n        self.elements[last_row].get_length()\n    }\n\n    pub fn get_cell(\u0026self, row: usize, col: usize) -\u003e \u0026Rq {\n        if !self.is_symmetric || row \u003e= col {\n            \u0026self.elements[row].get_elements()[col]\n        } else {\n            \u0026self.elements[col].get_elements()[row]\n        }\n    }\n\n    pub fn set_sell(\u0026mut self, row: usize, col: usize, value: Rq) {\n        self.elements[row].set(col, value);\n    }\n\n    /// Create a random matrix of polynomials\n    pub fn random\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, row_len: usize, col_len: usize) -\u003e Self {\n        Self {\n            elements: (0..row_len)\n                .map(|_| RqVector::random(rng, col_len))\n                .collect(),\n            is_symmetric: false,\n        }\n    }\n\n    /// Create a random symmetric matrix of polynomials\n    pub fn symmetric_random\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, row_len: usize) -\u003e Self {\n        Self {\n            elements: (0..row_len)\n                .map(|row| RqVector::random(rng, row + 1))\n                .collect(),\n            is_symmetric: true,\n        }\n    }\n\n    pub fn get_elements(\u0026self) -\u003e \u0026[RqVector] {\n        \u0026self.elements\n    }\n\n    pub fn decompose_each_cell(\u0026self, base: Zq, num_parts: usize) -\u003e RqVector {\n        let mut decomposed_vec = Vec::new();\n        for ring_vector in self.get_elements() {\n            for ring in ring_vector.get_elements() {\n                decomposed_vec.extend(ring.decompose(base, num_parts));\n            }\n        }\n        RqVector::new(decomposed_vec)\n    }\n}\n\nimpl FromIterator\u003cRqVector\u003e for RqMatrix {\n    fn from_iter\u003cT: IntoIterator\u003cItem = RqVector\u003e\u003e(iter: T) -\u003e Self {\n        let mut elements = Vec::new();\n        for item in iter {\n            elements.push(item);\n        }\n        RqMatrix::new(elements, false)\n    }\n}\n\n// Implement matrix-vector multiplication for reference to matrix\nimpl Mul\u003c\u0026RqVector\u003e for \u0026RqMatrix {\n    type Output = RqVector;\n\n    fn mul(self, rhs: \u0026RqVector) -\u003e Self::Output {\n        let mut result = RqVector::zero(self.elements.len());\n\n        for (i, row) in self.elements.iter().enumerate() {\n            result.set(\n                i,\n                inner_product::compute_linear_combination(row.get_elements(), rhs.get_elements()),\n            );\n        }\n        result\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use rand::rng;\n\n    use super::*;\n    use crate::ring::rq::tests::generate_rq_from_zq_vector;\n    use crate::ring::rq::Rq;\n    use crate::ring::zq::Zq;\n\n    #[test]\n    #[cfg(not(feature = \"skip-slow-tests\"))]\n    fn rqmatrix_fits_stack() {\n        let mut rng = rand::rng();\n        let _: RqMatrix = RqMatrix::random(\u0026mut rng, 256, 1 \u003c\u003c 10);\n    }\n\n    #[test]\n    fn test_set_sell() {\n        let mut matrix = RqMatrix::zero(10, 18);\n        matrix.set_sell(4, 9, Rq::new([Zq::new(10); Rq::DEGREE]));\n        matrix.set_sell(8, 1, Rq::new([Zq::new(3); Rq::DEGREE]));\n\n        for (i, vector) in matrix.get_elements().iter().enumerate() {\n            for (j, poly) in vector.get_elements().iter().enumerate() {\n                if (i == 4) \u0026\u0026 (j == 9) {\n                    assert_eq!(poly, \u0026Rq::new([Zq::new(10); Rq::DEGREE]))\n                } else if (i == 8) \u0026\u0026 (j == 1) {\n                    assert_eq!(poly, \u0026Rq::new([Zq::new(3); Rq::DEGREE]))\n                } else {\n                    assert_eq!(poly, \u0026Rq::zero())\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn test_symmetric_matrix() {\n        let symmetric_matrix = RqMatrix::symmetric_random(\u0026mut rng(), 12);\n        assert_eq!(symmetric_matrix.get_row_len(), 12);\n        assert_eq!(symmetric_matrix.get_col_len(), 12);\n        for i in 0..symmetric_matrix.get_row_len() {\n            assert_eq!(symmetric_matrix.get_elements()[i].get_length(), i + 1);\n        }\n        for i in 0..symmetric_matrix.get_row_len() {\n            for j in 0..symmetric_matrix.get_col_len() {\n                assert_eq!(\n                    symmetric_matrix.get_cell(i, j),\n                    symmetric_matrix.get_cell(j, i)\n                )\n            }\n        }\n    }\n\n    #[test]\n    fn test_rq_matrix_from_iterator() {\n        let expected = vec![\n            RqVector::random(\u0026mut rng(), 5),\n            RqVector::random(\u0026mut rng(), 5),\n            RqVector::random(\u0026mut rng(), 5),\n            RqVector::random(\u0026mut rng(), 5),\n        ];\n        let polynomial_matrix = expected.clone().into_iter();\n        let result: RqMatrix = polynomial_matrix.collect();\n\n        assert_eq!(result.get_elements(), \u0026expected);\n    }\n\n    #[test]\n    fn test_zero_matrix() {\n        /// Check if Polynomial == 0\n        pub fn is_polynomial_zero(poly: \u0026Rq) -\u003e bool {\n            poly.get_coefficients()\n                .iter()\n                .all(|\u0026coeff| coeff == Zq::ZERO)\n        }\n\n        let matrix = RqMatrix::zero(10, 20);\n        assert_eq!(matrix.get_row_len(), 10);\n        assert_eq!(matrix.get_col_len(), 20);\n        for row in matrix.get_elements() {\n            for cell in row.get_elements() {\n                assert!(is_polynomial_zero(cell));\n            }\n        }\n    }\n\n    #[test]\n    fn test_rqmartrix_mul() {\n        let poly1: Rq = generate_rq_from_zq_vector(vec![Zq::new(8), Zq::new(6)]);\n        let poly2: Rq = generate_rq_from_zq_vector(vec![-Zq::new(5), -Zq::new(5)]);\n        let poly3: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ZERO]);\n        let poly4: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::new(4)]);\n        let matrix_1: RqMatrix = RqMatrix::new(vec![RqVector::from(vec![poly1, poly2])], false);\n        let vec_1: RqVector = RqVector::from(vec![poly3, poly4]);\n\n        let result_1 = matrix_1.mul(\u0026vec_1);\n        let expected_poly_1 =\n            generate_rq_from_zq_vector(vec![Zq::new(8), -Zq::new(14), -Zq::new(20)]);\n        let expected_1 = RqVector::from(vec![expected_poly_1]);\n        assert_eq!(result_1, expected_1);\n\n        let poly5: Rq = generate_rq_from_zq_vector(vec![-Zq::new(7), Zq::new(7)]);\n        let poly6: Rq = generate_rq_from_zq_vector(vec![-Zq::new(3), Zq::ZERO]);\n        let poly7: Rq = generate_rq_from_zq_vector(vec![Zq::new(8), -Zq::new(2)]);\n        let poly8: Rq = generate_rq_from_zq_vector(vec![-Zq::new(4), Zq::new(4)]);\n        let poly9: Rq = generate_rq_from_zq_vector(vec![Zq::NEG_ONE, -Zq::new(2)]);\n        let poly10: Rq = generate_rq_from_zq_vector(vec![-Zq::new(3), -Zq::new(3)]);\n        let matrix_2: RqMatrix = RqMatrix::new(\n            vec![\n                RqVector::from(vec![poly5, poly6]),\n                RqVector::from(vec![poly7, poly8]),\n            ],\n            false,\n        );\n        let vec_2: RqVector = RqVector::from(vec![poly9, poly10]);\n\n        let result_2 = matrix_2.mul(\u0026vec_2);\n        let expected_poly_2_1 =\n            generate_rq_from_zq_vector(vec![Zq::new(16), Zq::new(16), -Zq::new(14)]);\n        let expected_poly_2_2 =\n            generate_rq_from_zq_vector(vec![Zq::new(4), -Zq::new(14), -Zq::new(8)]);\n        let expected_2 = RqVector::from(vec![expected_poly_2_1, expected_poly_2_2]);\n        assert_eq!(result_2, expected_2);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":90}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":6}},{"line":29,"address":[],"length":0,"stats":{"Line":30}},{"line":34,"address":[],"length":0,"stats":{"Line":382}},{"line":35,"address":[],"length":0,"stats":{"Line":382}},{"line":38,"address":[],"length":0,"stats":{"Line":255}},{"line":39,"address":[],"length":0,"stats":{"Line":255}},{"line":40,"address":[],"length":0,"stats":{"Line":255}},{"line":43,"address":[],"length":0,"stats":{"Line":729}},{"line":44,"address":[],"length":0,"stats":{"Line":1458}},{"line":45,"address":[],"length":0,"stats":{"Line":498}},{"line":47,"address":[],"length":0,"stats":{"Line":231}},{"line":51,"address":[],"length":0,"stats":{"Line":80}},{"line":52,"address":[],"length":0,"stats":{"Line":80}},{"line":56,"address":[],"length":0,"stats":{"Line":6}},{"line":58,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":21}},{"line":68,"address":[],"length":0,"stats":{"Line":21}},{"line":75,"address":[],"length":0,"stats":{"Line":88}},{"line":76,"address":[],"length":0,"stats":{"Line":88}},{"line":79,"address":[],"length":0,"stats":{"Line":9}},{"line":80,"address":[],"length":0,"stats":{"Line":9}},{"line":81,"address":[],"length":0,"stats":{"Line":36}},{"line":82,"address":[],"length":0,"stats":{"Line":72}},{"line":86,"address":[],"length":0,"stats":{"Line":9}},{"line":91,"address":[],"length":0,"stats":{"Line":42}},{"line":92,"address":[],"length":0,"stats":{"Line":42}},{"line":93,"address":[],"length":0,"stats":{"Line":15012}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":42}},{"line":104,"address":[],"length":0,"stats":{"Line":225}},{"line":105,"address":[],"length":0,"stats":{"Line":225}},{"line":107,"address":[],"length":0,"stats":{"Line":1957}},{"line":113,"address":[],"length":0,"stats":{"Line":225}}],"covered":35,"coverable":36},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","rq_vector.rs"],"content":"use crate::ring::rq::Rq;\nuse crate::ring::zq::Zq;\nuse core::ops::Mul;\nuse rand::{CryptoRng, Rng};\nuse std::ops::Add;\n\n/// Vector of polynomials in Rq\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RqVector {\n    elements: Vec\u003cRq\u003e,\n}\n\nimpl RqVector {\n    pub fn new(elements: Vec\u003cRq\u003e) -\u003e Self {\n        Self { elements }\n    }\n\n    pub fn new_from_zq_vector(elements: Vec\u003cZq\u003e) -\u003e Self {\n        let mut result = Vec::new();\n        debug_assert!(elements.len() % Rq::DEGREE == 0);\n        elements.chunks_exact(Rq::DEGREE).for_each(|chunk| {\n            result.push(Rq::new(chunk.try_into().unwrap()));\n        });\n\n        RqVector { elements: result }\n    }\n\n    /// Create a zero vector\n    pub fn zero(length: usize) -\u003e Self {\n        Self {\n            elements: vec![Rq::zero(); length],\n        }\n    }\n\n    pub fn set(\u0026mut self, index: usize, val: Rq) {\n        self.elements[index] = val;\n    }\n\n    pub fn get_length(\u0026self) -\u003e usize {\n        self.elements.len()\n    }\n\n    pub fn get_elements(\u0026self) -\u003e \u0026Vec\u003cRq\u003e {\n        \u0026self.elements\n    }\n\n    /// Create a random vector\n    pub fn random\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, length: usize) -\u003e Self {\n        Self {\n            elements: (0..length).map(|_| Rq::random(rng)).collect(),\n        }\n    }\n\n    pub fn random_with_bound\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, length: usize, bound: u32) -\u003e Self {\n        Self {\n            elements: (0..length)\n                .map(|_| Rq::random_with_bound(rng, bound))\n                .collect(),\n        }\n    }\n\n    /// Function to concatenate coefficients from multiple Rq into a Vec\u003cZq\u003e\n    pub fn concatenate_coefficients(\u0026self) -\u003e Vec\u003cZq\u003e {\n        let total_coeffs = self.elements.len() * Rq::DEGREE;\n        let mut concatenated_coeffs: Vec\u003cZq\u003e = Vec::with_capacity(total_coeffs);\n        // Iterate over each Rq, extracting the coefficients and concatenating them\n        for rq in \u0026self.elements {\n            let coeffs = rq.get_coefficients();\n            concatenated_coeffs.extend_from_slice(coeffs);\n        }\n        concatenated_coeffs\n    }\n\n    // Compute the squared norm of a vector of polynomials\n    pub fn l2_norm_squared(\u0026self) -\u003e Zq {\n        self.elements\n            .iter()\n            .map(|poly| poly.l2_norm_squared()) // Collect coefficients from all polynomials\n            .sum()\n    }\n\n    pub fn decompose(\u0026self, b: Zq, parts: usize) -\u003e Vec\u003cRqVector\u003e {\n        self.get_elements()\n            .iter()\n            .map(|i| RqVector::new(Rq::decompose(i, b, parts)))\n            .collect()\n    }\n}\n\nimpl Add\u003c\u0026RqVector\u003e for \u0026RqVector {\n    type Output = RqVector;\n    // add two poly vectors\n    fn add(self, other: \u0026RqVector) -\u003e RqVector {\n        self.get_elements()\n            .iter()\n            .zip(other.get_elements())\n            .map(|(a, b)| a + b)\n            .collect()\n    }\n}\n\nimpl FromIterator\u003cRq\u003e for RqVector {\n    fn from_iter\u003cT: IntoIterator\u003cItem = Rq\u003e\u003e(iter: T) -\u003e Self {\n        let mut elements = Vec::new();\n        for item in iter {\n            elements.push(item);\n        }\n        RqVector::new(elements)\n    }\n}\n\n/// Create a new vector from a `Vec` of elements\nimpl From\u003cVec\u003cRq\u003e\u003e for RqVector {\n    fn from(elements: Vec\u003cRq\u003e) -\u003e Self {\n        Self { elements }\n    }\n}\n\nimpl Mul\u003c\u0026Rq\u003e for \u0026RqVector {\n    type Output = RqVector;\n    // A poly vector multiple by a PolyRing\n    fn mul(self, other: \u0026Rq) -\u003e RqVector {\n        self.get_elements().iter().map(|s| s * other).collect()\n    }\n}\n\nimpl Mul\u003c\u0026Zq\u003e for \u0026RqVector {\n    type Output = RqVector;\n    // A poly vector multiple by a PolyRing\n    fn mul(self, other: \u0026Zq) -\u003e RqVector {\n        self.get_elements().iter().map(|s| s * other).collect()\n    }\n}\n\nimpl Mul\u003cZq\u003e for \u0026RqVector {\n    type Output = RqVector;\n    // A poly vector multiple by a PolyRing\n    fn mul(self, other: Zq) -\u003e RqVector {\n        self.get_elements().iter().map(|s| s * \u0026other).collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use rand::rng;\n\n    use super::*;\n    use crate::{core::inner_product, ring::rq::tests::generate_rq_from_zq_vector};\n\n    #[test]\n    fn test_rqvector_from_iterator() {\n        let expected = vec![\n            Rq::random(\u0026mut rng()),\n            Rq::random(\u0026mut rng()),\n            Rq::random(\u0026mut rng()),\n        ];\n        let vector_of_polynomials = expected.clone().into_iter();\n        let result: RqVector = vector_of_polynomials.collect();\n\n        assert_eq!(result.get_elements(), \u0026expected);\n    }\n\n    #[test]\n    fn test_rq_vector_multiplication_with_zq() {\n        let poly1: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(22)]);\n        let poly2: Rq = generate_rq_from_zq_vector(vec![Zq::new(17), Zq::new(12)]);\n        let rq_vector = RqVector::from(vec![poly1, poly2]);\n        let result = \u0026rq_vector * Zq::new(3);\n\n        assert_eq!(\n            result.get_elements()[0],\n            generate_rq_from_zq_vector(vec![Zq::new(3), Zq::new(66)])\n        );\n        assert_eq!(\n            result.get_elements()[1],\n            generate_rq_from_zq_vector(vec![Zq::new(51), Zq::new(36)])\n        );\n\n        #[allow(clippy::op_ref)]\n        let result2 = \u0026rq_vector * \u0026Zq::new(3);\n        assert_eq!(\n            result2.get_elements()[0],\n            generate_rq_from_zq_vector(vec![Zq::new(3), Zq::new(66)])\n        );\n        assert_eq!(\n            result2.get_elements()[1],\n            generate_rq_from_zq_vector(vec![Zq::new(51), Zq::new(36)])\n        );\n    }\n\n    #[test]\n    fn test_rqvector_mul() {\n        let poly1: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2)]);\n        let poly2: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(4)]);\n        let vec_1: RqVector = RqVector::from(vec![poly1]);\n        let vec_2: RqVector = RqVector::from(vec![poly2]);\n        let result =\n            inner_product::compute_linear_combination(vec_1.get_elements(), vec_2.get_elements());\n        let poly_exp: Rq = generate_rq_from_zq_vector(vec![Zq::new(1), Zq::new(6), Zq::new(8)]);\n        assert_eq!(result, poly_exp);\n\n        let poly3: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let poly4: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let vec_3: RqVector = RqVector::from(vec![poly3]);\n        let vec_4: RqVector = RqVector::from(vec![poly4]);\n        let result_1 =\n            inner_product::compute_linear_combination(vec_3.get_elements(), vec_4.get_elements());\n        let poly_exp_1: Rq = generate_rq_from_zq_vector(vec![\n            Zq::new(1),\n            Zq::new(2),\n            Zq::new(3),\n            Zq::new(4),\n            Zq::new(3),\n            Zq::new(2),\n            Zq::new(1),\n        ]);\n        assert_eq!(result_1, poly_exp_1);\n\n        let poly5: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let poly6: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let poly7: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let poly8: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let vec_5: RqVector = RqVector::from(vec![poly5, poly6]);\n        let vec_6: RqVector = RqVector::from(vec![poly7, poly8]);\n        let result_2 =\n            inner_product::compute_linear_combination(vec_5.get_elements(), vec_6.get_elements());\n        let poly_exp_2: Rq = generate_rq_from_zq_vector(vec![\n            Zq::new(2),\n            Zq::new(4),\n            Zq::new(6),\n            Zq::new(8),\n            Zq::new(6),\n            Zq::new(4),\n            Zq::new(2),\n        ]);\n        assert_eq!(result_2, poly_exp_2);\n    }\n\n    // Test the square of the norm\n    #[test]\n    fn test_norm() {\n        let poly1 = generate_rq_from_zq_vector(vec![\n            Zq::ONE,\n            Zq::ZERO,\n            Zq::new(5),\n            Zq::NEG_ONE - Zq::new(1),\n        ]);\n        let poly2 = generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::ZERO, Zq::new(5), Zq::ONE]);\n        let poly_vec1: RqVector = vec![poly1.clone(), poly2.clone()].into();\n        assert_eq!(\n            poly_vec1.l2_norm_squared(),\n            poly1.l2_norm_squared() + poly2.l2_norm_squared()\n        );\n\n        let zero_vec: RqVector = RqVector::zero(4);\n        assert_eq!(zero_vec.l2_norm_squared(), Zq::ZERO);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":21450}},{"line":18,"address":[],"length":0,"stats":{"Line":5120}},{"line":19,"address":[],"length":0,"stats":{"Line":5120}},{"line":20,"address":[],"length":0,"stats":{"Line":10240}},{"line":21,"address":[],"length":0,"stats":{"Line":320000}},{"line":22,"address":[],"length":0,"stats":{"Line":314880}},{"line":29,"address":[],"length":0,"stats":{"Line":253}},{"line":31,"address":[],"length":0,"stats":{"Line":253}},{"line":35,"address":[],"length":0,"stats":{"Line":1813}},{"line":36,"address":[],"length":0,"stats":{"Line":1813}},{"line":39,"address":[],"length":0,"stats":{"Line":598}},{"line":40,"address":[],"length":0,"stats":{"Line":598}},{"line":43,"address":[],"length":0,"stats":{"Line":36040}},{"line":44,"address":[],"length":0,"stats":{"Line":36040}},{"line":48,"address":[],"length":0,"stats":{"Line":209}},{"line":50,"address":[],"length":0,"stats":{"Line":1513}},{"line":54,"address":[],"length":0,"stats":{"Line":109}},{"line":56,"address":[],"length":0,"stats":{"Line":109}},{"line":63,"address":[],"length":0,"stats":{"Line":2055}},{"line":64,"address":[],"length":0,"stats":{"Line":2055}},{"line":65,"address":[],"length":0,"stats":{"Line":2055}},{"line":67,"address":[],"length":0,"stats":{"Line":532045}},{"line":71,"address":[],"length":0,"stats":{"Line":2055}},{"line":75,"address":[],"length":0,"stats":{"Line":242}},{"line":76,"address":[],"length":0,"stats":{"Line":242}},{"line":78,"address":[],"length":0,"stats":{"Line":8631}},{"line":82,"address":[],"length":0,"stats":{"Line":10}},{"line":83,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":49}},{"line":93,"address":[],"length":0,"stats":{"Line":9441}},{"line":94,"address":[],"length":0,"stats":{"Line":9441}},{"line":96,"address":[],"length":0,"stats":{"Line":9441}},{"line":97,"address":[],"length":0,"stats":{"Line":66085}},{"line":103,"address":[],"length":0,"stats":{"Line":21297}},{"line":104,"address":[],"length":0,"stats":{"Line":21297}},{"line":105,"address":[],"length":0,"stats":{"Line":235947}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":21297}},{"line":114,"address":[],"length":0,"stats":{"Line":117}},{"line":122,"address":[],"length":0,"stats":{"Line":90}},{"line":123,"address":[],"length":0,"stats":{"Line":627}},{"line":130,"address":[],"length":0,"stats":{"Line":9397}},{"line":131,"address":[],"length":0,"stats":{"Line":65776}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":4}}],"covered":44,"coverable":45},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","zq.rs"],"content":"use core::ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign};\nuse rand::distr::uniform::{Error, SampleBorrow, SampleUniform, UniformInt, UniformSampler};\nuse rand::prelude::*;\nuse std::fmt;\nuse std::iter::Sum;\n/// Represents an element in the ring Z/qZ where q = 2^32.\n/// Uses native u32 operations with automatic modulo reduction through wrapping arithmetic.\n#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Default)]\npub struct Zq {\n    /// Stored value is always in [0, q-1] due to u32's wrapping behavior\n    value: u32,\n}\n\nimpl Zq {\n    /// Modulus q = 2^32 - 1\n    #[allow(clippy::as_conversions)]\n    pub const Q: u64 = u32::MAX as u64;\n    /// Zero element (additive identity)\n    pub const ZERO: Self = Self::new(0);\n    /// Multiplicative identity\n    pub const ONE: Self = Self::new(1);\n    /// Two\n    pub const TWO: Self = Self::new(2);\n    /// Maximum element\n    pub const NEG_ONE: Self = Self::new(u32::MAX - 1);\n\n    /// Creates a new Zq element from a raw u32 value.\n    /// No explicit modulo needed as u32 automatically wraps\n    pub const fn new(value: u32) -\u003e Self {\n        Self { value }\n    }\n\n    pub fn to_u128(\u0026self) -\u003e u128 {\n        u128::from(self.value)\n    }\n\n    pub const fn is_zero(\u0026self) -\u003e bool {\n        self.value == 0\n    }\n\n    pub fn get_value(\u0026self) -\u003e u32 {\n        self.value\n    }\n\n    /// Returns the centered representative modulo the given bound\n    /// Result is guaranteed to be in (-bound/2, bound/2]\n    ///\n    /// # Panics\n    ///\n    /// Panics if `bound` is zero.\n    pub(crate) fn centered_mod(\u0026self, bound: Self) -\u003e Self {\n        assert!(\n            bound != Zq::ZERO,\n            \"cannot get centered representative modulo for zero bound\"\n        );\n        let bounded_coeff = Self::new(self.value % bound.value);\n        let half_bound = bound.scale_by(Self::TWO);\n\n        if bounded_coeff \u003e half_bound {\n            bounded_coeff - bound\n        } else {\n            bounded_coeff\n        }\n    }\n\n    /// Scales by other Zq.\n    ///\n    /// Effectively it is a floor division of internal values.\n    /// But for the ring of integers there is no defined division\n    /// operation.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `bound` is zero.\n    pub(crate) fn scale_by(\u0026self, rhs: Self) -\u003e Self {\n        assert!(rhs != Zq::ZERO, \"cannot scale by zero\");\n        Self::new(self.value / rhs.value)\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn add_op(self, rhs: Zq) -\u003e Zq {\n        let sum = (self.value as u64 + rhs.value as u64) % Zq::Q;\n        Zq::new(sum as u32)\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn sub_op(self, rhs: Zq) -\u003e Zq {\n        let sub = (self.value as u64 + Zq::Q - rhs.value as u64) % Zq::Q;\n        Zq::new(sub as u32)\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn mul_op(self, b: Zq) -\u003e Zq {\n        let prod = (self.value as u64 * b.value as u64) % Zq::Q;\n        Zq::new(prod as u32)\n    }\n}\n\n// Macro to generate arithmetic trait implementations\nmacro_rules! impl_arithmetic {\n    ($trait:ident, $assign_trait:ident, $method:ident, $assign_method:ident, $op:ident) =\u003e {\n        impl $trait for Zq {\n            type Output = Self;\n\n            fn $method(self, rhs: Self) -\u003e Self::Output {\n                self.$op(rhs)\n            }\n        }\n\n        impl $assign_trait for Zq {\n            fn $assign_method(\u0026mut self, rhs: Self) {\n                *self = self.$op(rhs);\n            }\n        }\n\n        impl $trait\u003cZq\u003e for \u0026Zq {\n            type Output = Zq;\n\n            fn $method(self, rhs: Zq) -\u003e Self::Output {\n                self.$op(rhs)\n            }\n        }\n\n        impl $trait\u003c\u0026Zq\u003e for \u0026Zq {\n            type Output = Zq;\n\n            fn $method(self, rhs: \u0026Zq) -\u003e Self::Output {\n                self.$op(*rhs)\n            }\n        }\n    };\n}\n\nimpl_arithmetic!(Add, AddAssign, add, add_assign, add_op);\nimpl_arithmetic!(Sub, SubAssign, sub, sub_assign, sub_op);\nimpl_arithmetic!(Mul, MulAssign, mul, mul_assign, mul_op);\n\n// Implement the Neg trait for Zq.\nimpl Neg for Zq {\n    type Output = Zq;\n\n    /// Returns the additive inverse of the field element.\n    ///\n    /// Wrap around (q - a) mod q.\n    fn neg(self) -\u003e Zq {\n        // If the value is zero, its inverse is itself.\n        if self.value == 0 {\n            self\n        } else {\n            #[allow(clippy::as_conversions)]\n            Zq::new(Zq::Q as u32 - self.get_value())\n        }\n    }\n}\n\nimpl fmt::Display for Zq {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        // Shows value with modulus for clarity\n        write!(f, \"{} (mod {})\", self.value, Zq::Q)\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\npub struct UniformZq(UniformInt\u003cu32\u003e);\n\nimpl UniformSampler for UniformZq {\n    type X = Zq;\n\n    fn new\u003cB1, B2\u003e(low: B1, high: B2) -\u003e Result\u003cSelf, Error\u003e\n    where\n        B1: SampleBorrow\u003cSelf::X\u003e + Sized,\n        B2: SampleBorrow\u003cSelf::X\u003e + Sized,\n    {\n        UniformInt::\u003cu32\u003e::new(low.borrow().value, high.borrow().value).map(UniformZq)\n    }\n    fn new_inclusive\u003cB1, B2\u003e(low: B1, high: B2) -\u003e Result\u003cSelf, Error\u003e\n    where\n        B1: SampleBorrow\u003cSelf::X\u003e + Sized,\n        B2: SampleBorrow\u003cSelf::X\u003e + Sized,\n    {\n        UniformInt::\u003cu32\u003e::new_inclusive(low.borrow().value, high.borrow().value).map(UniformZq)\n    }\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e Self::X {\n        Self::X::new(self.0.sample(rng))\n    }\n}\n\nimpl SampleUniform for Zq {\n    type Sampler = UniformZq;\n}\n\nimpl Sum for Zq {\n    // Accumulate using the addition operator\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\n    where\n        I: Iterator\u003cItem = Zq\u003e,\n    {\n        iter.fold(Zq::ZERO, |acc, x| acc + x)\n    }\n}\n\npub fn add_assign_two_zq_vectors(first: \u0026mut [Zq], second: Vec\u003cZq\u003e) {\n    first\n        .iter_mut()\n        .zip(second)\n        .for_each(|(first_coeff, second_coeff)| *first_coeff += second_coeff);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_basic_arithmetic() {\n        let a = Zq::new(5);\n        let b = Zq::new(3);\n\n        // Addition\n        assert_eq!((a + b).value, 8, \"5 + 3 should be 8\");\n        // Subtraction\n        assert_eq!((a - b).value, 2, \"5 - 3 should be 2\");\n        // Multiplication\n        assert_eq!((a * b).value, 15, \"5 * 3 should be 15\");\n    }\n\n    #[test]\n    fn test_wrapping_arithmetic() {\n        let a = Zq::NEG_ONE;\n        let b = Zq::ONE;\n\n        assert_eq!((a + b).value, 0, \"u32::MAX + 1 should wrap to 0\");\n        assert_eq!((b - a).value, 2, \"1 - u32::MAX should wrap to 2 (mod 2^32)\");\n    }\n\n    #[test]\n    fn test_subtraction_edge_cases() {\n        let max = Zq::NEG_ONE;\n        let one = Zq::ONE;\n        let two = Zq::TWO;\n\n        assert_eq!((one - max).value, 2);\n        assert_eq!((two - max).value, 3);\n        assert_eq!((max - max).value, 0);\n    }\n\n    #[test]\n    fn test_multiplication_wrapping() {\n        let a = Zq::new(1 \u003c\u003c 31);\n        let two = Zq::TWO;\n\n        // Multiplication wraps when exceeding u32 range\n        assert_eq!((a * two).value, 1, \"2^31 * 2 should wrap to 1\");\n    }\n\n    #[test]\n    fn test_assignment_operators() {\n        let mut a = Zq::new(5);\n        let b = Zq::new(3);\n\n        a += b;\n        assert_eq!(a.value, 8, \"5 += 3 should be 8\");\n\n        a -= b;\n        assert_eq!(a.value, 5, \"8 -= 3 should be 5\");\n\n        a *= b;\n        assert_eq!(a.value, 15, \"5 *= 3 should be 15\");\n    }\n\n    #[test]\n    fn test_conversion_from_u32() {\n        let a: Zq = Zq::new(5);\n        assert_eq!(a.value, 5, \"Conversion from u32 should preserve value\");\n    }\n\n    #[test]\n    fn test_negative_arithmetic() {\n        let small = Zq::new(3);\n        let large = Zq::new(5);\n\n        // Test underflow handling (3 - 5 in u32 terms)\n        let result = small - large;\n        assert_eq!(result.value, u32::MAX - 2, \"3 - 5 should wrap to 2^32 - 2\");\n\n        // Test compound negative operations\n        let mut x = Zq::new(10);\n        x -= Zq::new(15);\n        assert_eq!(x.value, u32::MAX - 5, \"10 -= 15 should wrap to 2^32 - 5\");\n\n        // Test negative equivalent value in multiplication\n        let a = Zq::NEG_ONE; // Represents -1 in mod 2^32 arithmetic\n        let b = Zq::TWO;\n        assert_eq!(\n            (a * b).value,\n            u32::MAX - 2,\n            \"(-1) * 2 should be -2 ≡ 2^32 - 2\"\n        );\n    }\n\n    #[test]\n    fn test_display_implementation() {\n        let a = Zq::new(5);\n        let max = Zq::NEG_ONE;\n        assert_eq!(format!(\"{}\", a), format!(\"5 (mod {})\", Zq::Q));\n        assert_eq!(format!(\"{}\", max), format!(\"4294967294 (mod {})\", Zq::Q));\n    }\n\n    #[test]\n    fn test_maximum_element() {\n        dbg!(Zq::NEG_ONE);\n        dbg!(Zq::ZERO);\n        dbg!(Zq::ONE);\n        dbg!(Zq::ZERO - Zq::ONE);\n        assert_eq!(Zq::NEG_ONE, Zq::ZERO - Zq::ONE);\n    }\n\n    #[test]\n    fn test_ord() {\n        let a = Zq::new(100);\n        let b = Zq::new(200);\n        let c = Zq::new(100);\n        let d = Zq::new(400);\n\n        let res_1 = a.cmp(\u0026b);\n        let res_2 = a.cmp(\u0026c);\n        let res_3 = d.cmp(\u0026b);\n        assert!(res_1.is_lt());\n        assert!(res_2.is_eq());\n        assert!(res_3.is_gt());\n        assert_eq!(a, c);\n        assert!(a \u003c b);\n        assert!(d \u003e b);\n    }\n\n    #[test]\n    fn test_neg() {\n        let a = Zq::new(100);\n        let b = Zq::ZERO;\n        let neg_a: Zq = -a;\n        let neg_b: Zq = -b;\n\n        assert_eq!(neg_a + a, Zq::ZERO);\n        assert_eq!(neg_b, Zq::ZERO);\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":179008293}},{"line":33,"address":[],"length":0,"stats":{"Line":16163}},{"line":34,"address":[],"length":0,"stats":{"Line":16163}},{"line":37,"address":[],"length":0,"stats":{"Line":19}},{"line":38,"address":[],"length":0,"stats":{"Line":19}},{"line":41,"address":[],"length":0,"stats":{"Line":55699845}},{"line":42,"address":[],"length":0,"stats":{"Line":55699845}},{"line":51,"address":[],"length":0,"stats":{"Line":1057728}},{"line":52,"address":[],"length":0,"stats":{"Line":1057728}},{"line":53,"address":[],"length":0,"stats":{"Line":1057728}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":1057728}},{"line":57,"address":[],"length":0,"stats":{"Line":1057728}},{"line":59,"address":[],"length":0,"stats":{"Line":1057728}},{"line":60,"address":[],"length":0,"stats":{"Line":526232}},{"line":62,"address":[],"length":0,"stats":{"Line":531496}},{"line":75,"address":[],"length":0,"stats":{"Line":1083591}},{"line":76,"address":[],"length":0,"stats":{"Line":1083591}},{"line":77,"address":[],"length":0,"stats":{"Line":1083591}},{"line":81,"address":[],"length":0,"stats":{"Line":76789502}},{"line":82,"address":[],"length":0,"stats":{"Line":76789502}},{"line":83,"address":[],"length":0,"stats":{"Line":76789502}},{"line":87,"address":[],"length":0,"stats":{"Line":1660080}},{"line":88,"address":[],"length":0,"stats":{"Line":1660080}},{"line":89,"address":[],"length":0,"stats":{"Line":1660080}},{"line":93,"address":[],"length":0,"stats":{"Line":76530043}},{"line":94,"address":[],"length":0,"stats":{"Line":76530043}},{"line":95,"address":[],"length":0,"stats":{"Line":76530043}},{"line":105,"address":[],"length":0,"stats":{"Line":78421901}},{"line":106,"address":[],"length":0,"stats":{"Line":78421901}},{"line":111,"address":[],"length":0,"stats":{"Line":75828587}},{"line":112,"address":[],"length":0,"stats":{"Line":75828587}},{"line":119,"address":[],"length":0,"stats":{"Line":725823}},{"line":120,"address":[],"length":0,"stats":{"Line":725823}},{"line":127,"address":[],"length":0,"stats":{"Line":3314}},{"line":128,"address":[],"length":0,"stats":{"Line":3314}},{"line":145,"address":[],"length":0,"stats":{"Line":133734}},{"line":147,"address":[],"length":0,"stats":{"Line":133734}},{"line":148,"address":[],"length":0,"stats":{"Line":202}},{"line":151,"address":[],"length":0,"stats":{"Line":133532}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":6297}},{"line":181,"address":[],"length":0,"stats":{"Line":6297}},{"line":183,"address":[],"length":0,"stats":{"Line":402928}},{"line":184,"address":[],"length":0,"stats":{"Line":402928}},{"line":194,"address":[],"length":0,"stats":{"Line":10192}},{"line":198,"address":[],"length":0,"stats":{"Line":1124039}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":6}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":206,"address":[],"length":0,"stats":{"Line":1548}}],"covered":51,"coverable":54},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","mod.rs"],"content":"pub mod sponges;\nuse crate::{\n    core::jl::Projection,\n    ring::{rq::Rq, rq_matrix::RqMatrix, rq_vector::RqVector, zq::Zq},\n};\npub use sponges::Sponge;\n\npub struct LabradorTranscript\u003cS: Sponge\u003e {\n    sponge: S,\n    pub u1: RqVector,\n    pub vector_p: Vec\u003cZq\u003e,\n    pub b_ct_aggr: RqVector,\n    pub u2: RqVector,\n    pub z: RqVector,\n    pub t: RqMatrix,\n    pub g: RqMatrix,\n    pub h: RqMatrix,\n}\n\nimpl\u003cS: Sponge\u003e LabradorTranscript\u003cS\u003e {\n    pub fn new(sponge: S) -\u003e Self {\n        Self {\n            sponge,\n            u1: RqVector::new(Vec::new()),\n            vector_p: Vec::new(),\n            b_ct_aggr: RqVector::new(Vec::new()),\n            u2: RqVector::new(Vec::new()),\n            z: RqVector::new(Vec::new()),\n            t: RqMatrix::new(vec![RqVector::new(Vec::new())], false),\n            g: RqMatrix::new(vec![RqVector::new(Vec::new())], true),\n            h: RqMatrix::new(vec![RqVector::new(Vec::new())], true),\n        }\n    }\n\n    pub fn set_u1(\u0026mut self, u1: RqVector) {\n        self.absorb_u1(\u0026u1);\n        self.u1 = u1;\n    }\n\n    pub fn absorb_u1(\u0026mut self, u1: \u0026RqVector) {\n        self.sponge.absorb_rq(u1.get_elements());\n    }\n\n    pub fn set_vector_p(\u0026mut self, p: Vec\u003cZq\u003e) {\n        self.absorb_vector_p(\u0026p);\n        self.vector_p = p;\n    }\n\n    pub fn absorb_vector_p(\u0026mut self, p: \u0026[Zq]) {\n        self.sponge.absorb_zq(p);\n    }\n\n    pub fn set_vector_b_ct_aggr(\u0026mut self, input: RqVector) {\n        self.absorb_vector_b_ct_aggr(\u0026input);\n        self.b_ct_aggr = input;\n    }\n\n    pub fn absorb_vector_b_ct_aggr(\u0026mut self, input: \u0026RqVector) {\n        self.sponge.absorb_rq(input.get_elements());\n    }\n\n    pub fn set_u2(\u0026mut self, u2: RqVector) {\n        self.absorb_u2(\u0026u2);\n        self.u2 = u2;\n    }\n\n    pub fn absorb_u2(\u0026mut self, u2: \u0026RqVector) {\n        self.sponge.absorb_rq(u2.get_elements());\n    }\n\n    pub fn set_recursive_part(\u0026mut self, z: RqVector, t: RqMatrix, g: RqMatrix, h: RqMatrix) {\n        self.z = z;\n        self.t = t;\n        self.g = g;\n        self.h = h;\n    }\n\n    pub fn generate_projections(\n        \u0026mut self,\n        security_parameter: usize,\n        rank: usize,\n        multiplicity: usize,\n    ) -\u003e Projection {\n        // r vectors, each of length 256 * nD\n        let row_size = 2 * security_parameter;\n        let col_size = rank * Rq::DEGREE;\n\n        let matrices = (0..multiplicity)\n            .map(|_| {\n                let linear_projection_randomness = self.sponge.squeeze_zq(row_size * col_size);\n                linear_projection_randomness\n                    .chunks_exact(col_size)\n                    .map(|chunk| {\n                        let coeffs = chunk\n                            .iter()\n                            .map(|elem| {\n                                if elem.get_value() \u003c 2_u32.pow(30) {\n                                    Zq::NEG_ONE\n                                } else if elem.get_value() \u003c 2_u32.pow(31) {\n                                    Zq::ONE\n                                } else {\n                                    Zq::ZERO\n                                }\n                            })\n                            .collect();\n                        RqVector::new_from_zq_vector(coeffs)\n                    })\n                    .collect()\n            })\n            .collect();\n        Projection::new(matrices, security_parameter)\n    }\n\n    pub fn generate_vector_psi(\n        \u0026mut self,\n        number_of_vectors: usize,\n        vector_length: usize,\n    ) -\u003e Vec\u003cVec\u003cZq\u003e\u003e {\n        let elements = self.sponge.squeeze_zq(number_of_vectors * vector_length);\n        elements\n            .chunks_exact(vector_length)\n            .map(|chunk| chunk.into())\n            .collect()\n    }\n\n    pub fn generate_vector_omega(\n        \u0026mut self,\n        number_of_vectors: usize,\n        security_parameter: usize,\n    ) -\u003e Vec\u003cVec\u003cZq\u003e\u003e {\n        let elements = self\n            .sponge\n            .squeeze_zq(number_of_vectors * 2 * security_parameter);\n        elements\n            .chunks_exact(2 * security_parameter)\n            .map(|chunk| chunk.into())\n            .collect()\n    }\n\n    pub fn generate_rq_vector(\u0026mut self, vector_length: usize) -\u003e RqVector {\n        RqVector::new(self.sponge.squeeze_rq(vector_length))\n    }\n\n    pub fn generate_challenges(\u0026mut self, op_norm: f64, multiplicity: usize) -\u003e RqVector {\n        let mut result = Vec::new();\n        loop {\n            let candidate = self.sample_challenge();\n            if candidate.operator_norm() \u003c op_norm {\n                result.push(candidate);\n                if result.len() \u003e= multiplicity {\n                    return RqVector::new(result);\n                }\n            }\n        }\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn sample_challenge(\u0026mut self) -\u003e Rq {\n        let mut coeffs = [Zq::ZERO; Rq::DEGREE];\n        let random_bits = self.sponge.squeeze_bits(10 + 31);\n        // Add 31 coefficients, each either +1 or -1.\n        for (item, random_bit) in coeffs.iter_mut().zip(\u0026random_bits).take(31) {\n            *item = if *random_bit { Zq::new(1) } else { -Zq::new(1) };\n        }\n        // Add 10 coefficients, each either +2 or -2.\n        for (item, random_bit) in coeffs.iter_mut().zip(random_bits).skip(31).take(10) {\n            *item = if random_bit { Zq::new(2) } else { -Zq::new(2) };\n        }\n\n        // ------------------ 3. Shuffle using Fisher–Yates approach ---------\n        for i in (1..Rq::DEGREE).rev() {\n            let random_bytes = self.sponge.squeeze_bytes(4);\n            let random_index = u32::from_le_bytes(random_bytes.try_into().unwrap());\n            let random_index = (random_index as usize) % (i + 1); // uniform in 0..i\n            coeffs.swap(i, random_index);\n        }\n        Rq::new(coeffs)\n    }\n}\n\n#[cfg(test)]\nmod tests_generate_pi {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_projection_matrix_has_correct_size() {\n        let (security_parameter, rank, multiplicity) = (128, 20, 9);\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let projections = transcript.generate_projections(security_parameter, rank, multiplicity);\n        assert_eq!(projections.get_projection_matrices().len(), multiplicity); // number_of_project_matrices\n        assert_eq!(\n            projections.get_projection_matrices()[0].get_row_len(),\n            2 * security_parameter\n        );\n        assert_eq!(projections.get_projection_matrices()[0].get_col_len(), rank);\n    }\n\n    // Test the distribution of values in the random matrix\n    #[test]\n    #[allow(clippy::as_conversions)]\n    fn test_projection_matrix_is_random() {\n        let (security_parameter, rank, multiplicity) = (128, 1000, 1);\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let projections = transcript.generate_projections(security_parameter, rank, multiplicity);\n\n        for projection_matrix in projections.get_projection_matrices() {\n            let mut counts = [0.0, 0.0, 0.0]; // -1, 0, 1\n            for row in projection_matrix.get_elements() {\n                for cell in row.concatenate_coefficients() {\n                    match cell {\n                        Zq::ZERO =\u003e counts[1] += 1.0,\n                        Zq::ONE =\u003e counts[2] += 1.0,\n                        Zq::NEG_ONE =\u003e counts[0] += 1.0,\n                        _ =\u003e panic!(\"Should not occur\"),\n                    }\n                }\n            }\n            // Number of elements in the matrix as f64 (256x4x1000)\n            #[allow(clippy::as_conversions)]\n            let total: f64 = (256 * Rq::DEGREE * rank) as f64;\n            println!(\"this is the total amount of elements{}\", total);\n            let expected = [0.25, 0.5, 0.25];\n            for i in 0..3 {\n                let actual = counts[i] / total;\n                println!(\"This is the actual value {}\", actual);\n                assert!(\n                    //Since its a statistical test some small error tolerance is allowed\n                    (actual - expected[i]).abs() \u003c 0.005,\n                    \"Values are not within expected proportions\"\n                );\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod test_generate_psi {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_generate_vector_psi_has_correct_size() {\n        let (k_range, l_range) = (20, 12);\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let result = transcript.generate_vector_psi(k_range, l_range);\n        assert_eq!(result.len(), k_range); // number_of_project_matrices\n        assert_eq!(result[0].len(), l_range);\n    }\n\n    // TODO: Testing randomness of the distribution is needed.\n}\n\n#[cfg(test)]\nmod test_generate_omega {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_generate_vector_omega_has_correct_size() {\n        let (security_parameter, k_range) = (128, 20);\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let result = transcript.generate_vector_omega(k_range, security_parameter);\n        assert_eq!(result.len(), k_range); // number_of_project_matrices\n        assert_eq!(result[0].len(), 256);\n    }\n\n    // TODO: Testing randomness of the distribution is needed.\n}\n\n#[cfg(test)]\nmod test_generate_rq {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_generate_rq_has_correct_size() {\n        let k_range = 20;\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let result = transcript.generate_rq_vector(k_range);\n        assert_eq!(result.get_elements().len(), k_range); // number_of_project_matrices\n    }\n\n    // TODO: Testing randomness of the distribution is needed.\n}\n\n#[cfg(test)]\nmod test_generate_challenges {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_generate_challenges_has_correct_size() {\n        let multiplicity = 9;\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let result = transcript.generate_challenges(15.0, multiplicity);\n        assert_eq!(result.get_elements().len(), multiplicity); // number_of_project_matrices\n    }\n\n    /// Test Challenge Set:\n    /// const 71 and const 15 are from Challenge Space, paper page 6.\n    /// l2 norm \u003c= 71\n    /// operator norm \u003c= 15\n    #[test]\n    fn test_challenge_set() {\n        let op_norm = 15.0;\n        let multiplicity = 9;\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n\n        let challenge_set = transcript.generate_challenges(15.0, multiplicity);\n\n        for i in 0..multiplicity {\n            // l2 norm 71 is from paper page 6, Challenge Space.\n            use crate::core::inner_product::compute_linear_combination;\n            assert_eq!(\n                compute_linear_combination(\n                    challenge_set.get_elements()[i].get_coefficients(),\n                    challenge_set.get_elements()[i].get_coefficients()\n                ),\n                Zq::new(71)\n            );\n            assert!(challenge_set.get_elements()[i].operator_norm() \u003c= op_norm);\n        }\n\n        for i in 0..multiplicity {\n            for j in 0..multiplicity {\n                if i != j {\n                    assert_ne!(\n                        challenge_set.get_elements()[i],\n                        challenge_set.get_elements()[j]\n                    );\n                }\n            }\n        }\n    }\n\n    // TODO: Testing randomness of the distribution is needed.\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":11}},{"line":24,"address":[],"length":0,"stats":{"Line":11}},{"line":25,"address":[],"length":0,"stats":{"Line":11}},{"line":26,"address":[],"length":0,"stats":{"Line":11}},{"line":27,"address":[],"length":0,"stats":{"Line":11}},{"line":28,"address":[],"length":0,"stats":{"Line":11}},{"line":29,"address":[],"length":0,"stats":{"Line":11}},{"line":30,"address":[],"length":0,"stats":{"Line":11}},{"line":31,"address":[],"length":0,"stats":{"Line":11}},{"line":35,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":26}},{"line":90,"address":[],"length":0,"stats":{"Line":20}},{"line":91,"address":[],"length":0,"stats":{"Line":20}},{"line":92,"address":[],"length":0,"stats":{"Line":20}},{"line":93,"address":[],"length":0,"stats":{"Line":5140}},{"line":94,"address":[],"length":0,"stats":{"Line":5120}},{"line":95,"address":[],"length":0,"stats":{"Line":5120}},{"line":96,"address":[],"length":0,"stats":{"Line":20157440}},{"line":97,"address":[],"length":0,"stats":{"Line":20152320}},{"line":98,"address":[],"length":0,"stats":{"Line":5037947}},{"line":99,"address":[],"length":0,"stats":{"Line":15114373}},{"line":100,"address":[],"length":0,"stats":{"Line":5042027}},{"line":102,"address":[],"length":0,"stats":{"Line":10072346}},{"line":105,"address":[],"length":0,"stats":{"Line":5120}},{"line":106,"address":[],"length":0,"stats":{"Line":5120}},{"line":108,"address":[],"length":0,"stats":{"Line":20}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":40}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":40}},{"line":140,"address":[],"length":0,"stats":{"Line":7}},{"line":141,"address":[],"length":0,"stats":{"Line":7}},{"line":144,"address":[],"length":0,"stats":{"Line":5}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":182}},{"line":148,"address":[],"length":0,"stats":{"Line":182}},{"line":149,"address":[],"length":0,"stats":{"Line":27}},{"line":150,"address":[],"length":0,"stats":{"Line":27}},{"line":151,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":182}},{"line":159,"address":[],"length":0,"stats":{"Line":182}},{"line":160,"address":[],"length":0,"stats":{"Line":182}},{"line":162,"address":[],"length":0,"stats":{"Line":5824}},{"line":163,"address":[],"length":0,"stats":{"Line":5642}},{"line":166,"address":[],"length":0,"stats":{"Line":2002}},{"line":167,"address":[],"length":0,"stats":{"Line":1820}},{"line":171,"address":[],"length":0,"stats":{"Line":11648}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":182}}],"covered":85,"coverable":89},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","mod.rs"],"content":"use crate::ring::{rq::Rq, zq::Zq};\n\npub trait Sponge {\n    fn default() -\u003e Self;\n    fn absorb_zq(\u0026mut self, input: \u0026[Zq]);\n    fn absorb_rq(\u0026mut self, input: \u0026[Rq]);\n    fn squeeze_zq(\u0026mut self, output_length: usize) -\u003e Vec\u003cZq\u003e;\n    fn squeeze_rq(\u0026mut self, output_length: usize) -\u003e Vec\u003cRq\u003e;\n    fn squeeze_bits(\u0026mut self, bit_length: usize) -\u003e Vec\u003cbool\u003e;\n    fn squeeze_bytes(\u0026mut self, byte_length: usize) -\u003e Vec\u003cu8\u003e;\n}\n\npub mod shake;\n// pub mod poseidon;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","poseidon","instance.rs"],"content":"use crate::zq::Zq;\n\nuse super::{permutation::PoseidonPermutation, sponge::PoseidonSponge};\n\n// ===========================================================================\n// Poseidon parameter set – hard-coded for Fiat–Shamir transcripts\n// ===========================================================================\n//\n// The ARK (add-round-key) and MDS matrices below were *generated once* and are\n// embedded so that every prover/verifier derives the **same** challenges.\nconst WIDTH: usize = 9;\nconst RATE: usize = 1;\nconst OUTPUT_LEN: usize = 1;\nconst ROUNDS: usize = 28;\nconst PARTIAL_ROUNDS: usize = 20;\nconst ALPHA: u64 = 3;\n// Hard‑coded round constants (ARK) and MDS matrix.  Generated off‑line.\nconst ARK: [[Zq; WIDTH]; ROUNDS] = [\n    [\n        Zq::new(2773654128),\n        Zq::new(2698871901),\n        Zq::new(1186535217),\n        Zq::new(2276367172),\n        Zq::new(460986456),\n        Zq::new(1130506256),\n        Zq::new(1436990685),\n        Zq::new(3571618093),\n        Zq::new(1928846831),\n    ],\n    [\n        Zq::new(784272210),\n        Zq::new(2362493121),\n        Zq::new(3754859051),\n        Zq::new(1152838762),\n        Zq::new(1277027414),\n        Zq::new(4290089713),\n        Zq::new(750711681),\n        Zq::new(3735304872),\n        Zq::new(2484390012),\n    ],\n    [\n        Zq::new(3022291695),\n        Zq::new(1296513440),\n        Zq::new(2666656071),\n        Zq::new(1392772787),\n        Zq::new(3924839390),\n        Zq::new(3434015439),\n        Zq::new(3547712534),\n        Zq::new(3119852137),\n        Zq::new(3798005745),\n    ],\n    [\n        Zq::new(2375363973),\n        Zq::new(1758886039),\n        Zq::new(2041597959),\n        Zq::new(3263939143),\n        Zq::new(1885616341),\n        Zq::new(1813930986),\n        Zq::new(203888102),\n        Zq::new(1528124030),\n        Zq::new(56779178),\n    ],\n    [\n        Zq::new(3755261782),\n        Zq::new(706143006),\n        Zq::new(2082983570),\n        Zq::new(352354306),\n        Zq::new(2353150435),\n        Zq::new(3650061737),\n        Zq::new(3893118498),\n        Zq::new(183150537),\n        Zq::new(2228089161),\n    ],\n    [\n        Zq::new(922618003),\n        Zq::new(3292151780),\n        Zq::new(236167017),\n        Zq::new(2617694273),\n        Zq::new(2876369390),\n        Zq::new(4265817939),\n        Zq::new(1383107438),\n        Zq::new(286389424),\n        Zq::new(3869373395),\n    ],\n    [\n        Zq::new(1955724147),\n        Zq::new(1111197896),\n        Zq::new(633124926),\n        Zq::new(2523587424),\n        Zq::new(4135563482),\n        Zq::new(3059457948),\n        Zq::new(2282176497),\n        Zq::new(1783995730),\n        Zq::new(3403269348),\n    ],\n    [\n        Zq::new(508988721),\n        Zq::new(301251615),\n        Zq::new(4208429837),\n        Zq::new(2847939307),\n        Zq::new(3727165119),\n        Zq::new(3625918486),\n        Zq::new(3478562333),\n        Zq::new(1459737698),\n        Zq::new(100323470),\n    ],\n    [\n        Zq::new(3179318671),\n        Zq::new(1533355377),\n        Zq::new(2704441550),\n        Zq::new(2362155401),\n        Zq::new(4225681297),\n        Zq::new(621873557),\n        Zq::new(1849485098),\n        Zq::new(4012360807),\n        Zq::new(3322683455),\n    ],\n    [\n        Zq::new(271837745),\n        Zq::new(1175116485),\n        Zq::new(1502825906),\n        Zq::new(113799952),\n        Zq::new(710728204),\n        Zq::new(930285870),\n        Zq::new(936814998),\n        Zq::new(3142336897),\n        Zq::new(1195857553),\n    ],\n    [\n        Zq::new(3229477597),\n        Zq::new(3874900104),\n        Zq::new(633468355),\n        Zq::new(664022320),\n        Zq::new(1037768339),\n        Zq::new(24745787),\n        Zq::new(1390286585),\n        Zq::new(2050114210),\n        Zq::new(3461313472),\n    ],\n    [\n        Zq::new(2038116502),\n        Zq::new(2756126285),\n        Zq::new(314702156),\n        Zq::new(198049006),\n        Zq::new(3362107641),\n        Zq::new(804124193),\n        Zq::new(1347345692),\n        Zq::new(3778418349),\n        Zq::new(1603517811),\n    ],\n    [\n        Zq::new(246075735),\n        Zq::new(2910920140),\n        Zq::new(2101057122),\n        Zq::new(2041317133),\n        Zq::new(2883309822),\n        Zq::new(4019460306),\n        Zq::new(2468923228),\n        Zq::new(964910736),\n        Zq::new(1333043724),\n    ],\n    [\n        Zq::new(293190938),\n        Zq::new(3902017027),\n        Zq::new(549889505),\n        Zq::new(4272274465),\n        Zq::new(3832846664),\n        Zq::new(2204806555),\n        Zq::new(3020552376),\n        Zq::new(3447507883),\n        Zq::new(855953368),\n    ],\n    [\n        Zq::new(2079971112),\n        Zq::new(2508401160),\n        Zq::new(3834351883),\n        Zq::new(1427569236),\n        Zq::new(3358408800),\n        Zq::new(2439693552),\n        Zq::new(4054927129),\n        Zq::new(4053693217),\n        Zq::new(723473858),\n    ],\n    [\n        Zq::new(1025339977),\n        Zq::new(585257694),\n        Zq::new(3070506491),\n        Zq::new(3175819591),\n        Zq::new(1392016786),\n        Zq::new(1516602977),\n        Zq::new(3228410444),\n        Zq::new(3130776340),\n        Zq::new(3165959881),\n    ],\n    [\n        Zq::new(3842311420),\n        Zq::new(2262157250),\n        Zq::new(3756225800),\n        Zq::new(2582280172),\n        Zq::new(1270243441),\n        Zq::new(2052508852),\n        Zq::new(4271664205),\n        Zq::new(620984828),\n        Zq::new(3325253760),\n    ],\n    [\n        Zq::new(548636457),\n        Zq::new(1164607978),\n        Zq::new(3027080685),\n        Zq::new(1908414320),\n        Zq::new(1208816014),\n        Zq::new(671096184),\n        Zq::new(4042441851),\n        Zq::new(2000153875),\n        Zq::new(2975622655),\n    ],\n    [\n        Zq::new(2588519128),\n        Zq::new(1500421688),\n        Zq::new(280920169),\n        Zq::new(1425318099),\n        Zq::new(173722839),\n        Zq::new(1354484516),\n        Zq::new(1969077869),\n        Zq::new(2165032598),\n        Zq::new(2764691127),\n    ],\n    [\n        Zq::new(3889006152),\n        Zq::new(676568773),\n        Zq::new(1097350839),\n        Zq::new(3748044660),\n        Zq::new(3451456889),\n        Zq::new(1469067299),\n        Zq::new(1196266786),\n        Zq::new(3351660008),\n        Zq::new(3216956496),\n    ],\n    [\n        Zq::new(2920308927),\n        Zq::new(1964475343),\n        Zq::new(1208178427),\n        Zq::new(1685596759),\n        Zq::new(3452869029),\n        Zq::new(574413953),\n        Zq::new(1372297329),\n        Zq::new(1642685791),\n        Zq::new(1521032998),\n    ],\n    [\n        Zq::new(1396137219),\n        Zq::new(3249324467),\n        Zq::new(1491626859),\n        Zq::new(1222034466),\n        Zq::new(3741121943),\n        Zq::new(2630086446),\n        Zq::new(4101711170),\n        Zq::new(3962365070),\n        Zq::new(630331971),\n    ],\n    [\n        Zq::new(3756693713),\n        Zq::new(1976849786),\n        Zq::new(1599868415),\n        Zq::new(4193484663),\n        Zq::new(3575428569),\n        Zq::new(2614894763),\n        Zq::new(721681014),\n        Zq::new(3645252436),\n        Zq::new(96433812),\n    ],\n    [\n        Zq::new(1889643081),\n        Zq::new(178898262),\n        Zq::new(2836025067),\n        Zq::new(1086358336),\n        Zq::new(3421342207),\n        Zq::new(1160658413),\n        Zq::new(3078690548),\n        Zq::new(1734238039),\n        Zq::new(1684918153),\n    ],\n    [\n        Zq::new(4186013047),\n        Zq::new(1024422138),\n        Zq::new(4025507495),\n        Zq::new(2413389692),\n        Zq::new(614405915),\n        Zq::new(2631560766),\n        Zq::new(4144324857),\n        Zq::new(2400759460),\n        Zq::new(1279501883),\n    ],\n    [\n        Zq::new(1791688840),\n        Zq::new(2006611136),\n        Zq::new(3093261711),\n        Zq::new(1016157743),\n        Zq::new(11561707),\n        Zq::new(1430464813),\n        Zq::new(73038415),\n        Zq::new(2025372355),\n        Zq::new(2402576570),\n    ],\n    [\n        Zq::new(2758798058),\n        Zq::new(2132722282),\n        Zq::new(1698416471),\n        Zq::new(3578176273),\n        Zq::new(550672905),\n        Zq::new(70724481),\n        Zq::new(3070901761),\n        Zq::new(306186726),\n        Zq::new(2828652630),\n    ],\n    [\n        Zq::new(1005410618),\n        Zq::new(1376511878),\n        Zq::new(4093260411),\n        Zq::new(3950256285),\n        Zq::new(1890541837),\n        Zq::new(1315511419),\n        Zq::new(3327986955),\n        Zq::new(1322306885),\n        Zq::new(1270447424),\n    ],\n];\nconst MDS: [[Zq; WIDTH]; WIDTH] = [\n    [\n        Zq::new(3997651091),\n        Zq::new(658253063),\n        Zq::new(2095400994),\n        Zq::new(440926105),\n        Zq::new(1796368741),\n        Zq::new(1961349520),\n        Zq::new(540996892),\n        Zq::new(35935778),\n        Zq::new(732075401),\n    ],\n    [\n        Zq::new(1743127377),\n        Zq::new(3247221626),\n        Zq::new(4148659237),\n        Zq::new(2205285832),\n        Zq::new(3910687740),\n        Zq::new(2853895742),\n        Zq::new(1662369266),\n        Zq::new(241107308),\n        Zq::new(4022943497),\n    ],\n    [\n        Zq::new(2071371317),\n        Zq::new(4222913952),\n        Zq::new(1163051760),\n        Zq::new(3185249567),\n        Zq::new(4114377118),\n        Zq::new(1048229747),\n        Zq::new(658207529),\n        Zq::new(1971020081),\n        Zq::new(4001507915),\n    ],\n    [\n        Zq::new(4278306557),\n        Zq::new(2902580578),\n        Zq::new(1382067936),\n        Zq::new(3738299059),\n        Zq::new(1548047067),\n        Zq::new(1128497469),\n        Zq::new(2358825001),\n        Zq::new(567535302),\n        Zq::new(4263023986),\n    ],\n    [\n        Zq::new(188724725),\n        Zq::new(890882199),\n        Zq::new(2995073197),\n        Zq::new(3520401121),\n        Zq::new(2334136676),\n        Zq::new(1039560330),\n        Zq::new(3354448203),\n        Zq::new(2456760197),\n        Zq::new(860596610),\n    ],\n    [\n        Zq::new(1063803022),\n        Zq::new(4115470744),\n        Zq::new(2914526459),\n        Zq::new(995387934),\n        Zq::new(47066002),\n        Zq::new(3823938923),\n        Zq::new(329509446),\n        Zq::new(2091055303),\n        Zq::new(2927144621),\n    ],\n    [\n        Zq::new(1222968641),\n        Zq::new(3572964758),\n        Zq::new(532234855),\n        Zq::new(1137915407),\n        Zq::new(902452800),\n        Zq::new(1725021750),\n        Zq::new(3941355778),\n        Zq::new(816646153),\n        Zq::new(2658636777),\n    ],\n    [\n        Zq::new(2652215134),\n        Zq::new(3067867604),\n        Zq::new(1764433633),\n        Zq::new(3289297051),\n        Zq::new(3187448683),\n        Zq::new(3735943544),\n        Zq::new(3993652112),\n        Zq::new(2905114558),\n        Zq::new(477157260),\n    ],\n    [\n        Zq::new(3093659876),\n        Zq::new(479575061),\n        Zq::new(3390824282),\n        Zq::new(3037823443),\n        Zq::new(1492293764),\n        Zq::new(3797464643),\n        Zq::new(3579348020),\n        Zq::new(2374361921),\n        Zq::new(842530663),\n    ],\n];\n\n/// Convenience type aliases for the fixed permutation + sponge\ntype Perm = PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e;\ntype Sponge = PoseidonSponge\u003cOUTPUT_LEN, RATE, WIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e;\n\n/// A **Fiat–Shamir transcript** based on Poseidon.\n///\n/// The transcript collects field elements via [`absorb_element`].  When a new\n/// challenge is required, [`get_scalar_challenge`] returns the Poseidon hash of\n/// the current buffer, interpreted as a scalar in the same field `Zq`.\n///\n/// The internal message buffer is **not** cleared after squeezing, allowing the\n/// caller to derive *multiple* independent challenges sequentially by first\n/// appending the previous challenge back into the transcript (standard\n/// practice in many proof systems).\npub struct Transcript {\n    buf: Vec\u003cZq\u003e,\n}\n\nimpl Default for Transcript {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Transcript {\n    /// Creates an **empty** transcript.\n    pub fn new() -\u003e Self {\n        Self { buf: Vec::new() }\n    }\n\n    /// Appends a field element to the transcript.  Elements are stored in the\n    /// order they are seen and fed verbatim to the Poseidon sponge.\n    pub fn absorb_element(\u0026mut self, elem: Zq) {\n        self.buf.push(elem);\n    }\n\n    /// Generates a *scalar* challenge and **appends it** to the transcript so\n    /// that subsequent challenges are bound to the previous ones.\n    pub fn get_scalar_challenge(\u0026mut self) -\u003e Zq {\n        let permutation = Perm::new_with_ark_mds(ARK, MDS);\n        let mut sponge = Sponge::new(self.buf.clone(), permutation);\n        let challenge = sponge.compute_hash()[0];\n        self.buf.push(challenge);\n        challenge\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Transcript;\n    use crate::zq::Zq;\n\n    #[test]\n    fn test_transcript() {\n        let mut transcript = Transcript::new();\n        transcript.absorb_element(Zq::new(12));\n        transcript.absorb_element(Zq::new(12312));\n        transcript.absorb_element(Zq::new(111));\n        let _result = transcript.get_scalar_challenge();\n        // result == 3770429813\n    }\n\n    #[test]\n    fn test_challenge_is_appended_to_transcript() {\n        let mut t = Transcript::new();\n        t.absorb_element(Zq::new(42));\n        let c1 = t.get_scalar_challenge();\n        let c2 = t.get_scalar_challenge();\n        assert_ne!(c1, c2);\n    }\n\n    /// Two transcripts with identical message sequences must agree on the\n    /// challenge value.\n    #[test]\n    fn test_two_transcripts_agree() {\n        let mut t1 = Transcript::new();\n        let mut t2 = Transcript::new();\n        for \u0026x in \u0026[1u32, 2, 3, 5, 8] {\n            t1.absorb_element(Zq::new(x));\n            t2.absorb_element(Zq::new(x));\n        }\n        assert_eq!(t1.get_scalar_challenge(), t2.get_scalar_challenge());\n    }\n\n    /// Changing *one* absorbed element should almost certainly alter the\n    /// challenge (collision resistance is probabilistic; here we just assert\n    /// inequality for this specific test vector).\n    #[test]\n    fn test_challenge_changes_with_input() {\n        let mut t1 = Transcript::new();\n        let mut t2 = Transcript::new();\n        t1.absorb_element(Zq::new(99));\n        t2.absorb_element(Zq::new(100));\n        assert_ne!(t1.get_scalar_challenge(), t2.get_scalar_challenge());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","poseidon","permutation.rs"],"content":"use crate::zq::Zq;\nuse blake2::Blake2b256;\nuse blake2::Digest;\nuse rand::distr::{Distribution, Uniform};\nuse rand::{random, rng, CryptoRng};\n\n/// A configurable implementation of the *Poseidon* permutation.\n///\n/// The permutation operates over a fixed–width state `WIDTH` of field\n/// elements [`Zq`], runs for `ROUNDS` total rounds, of which\n/// `PARTIAL_ROUNDS` are **partial rounds** (S-box is applied to **only one**\n/// state word, and uses an S-box of the form \\(x \\mapsto x^{ALPHA}\\).\n///\n/// # Type Parameters\n/// * `WIDTH` – Number of field elements in the internal state.\n/// * `ROUNDS` – Total rounds executed by [`permute`]; including partial rounds.\n/// * `PARTIAL_ROUNDS` – Number of *partial* rounds; the remaining\n///   \\(ROUNDS-\\text{PARTIAL_ROUNDS}\\) are *full* rounds.\n/// * `ALPHA` – Exponent used by the power S-box.\n///\n/// The round constants (ARK) and MDS matrix are generated from fresh randomness at construction time.\npub struct PoseidonPermutation\u003c\n    const WIDTH: usize,\n    const ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n    const ALPHA: u64,\n\u003e {\n    /// Current permutation state.\n    pub state: [Zq; WIDTH],\n    /// Round keys (ARK) – `ROUNDS × WIDTH` matrix.\n    pub ark: [[Zq; WIDTH]; ROUNDS],\n    /// MDS matrix (`WIDTH × WIDTH`) used to mix the state every round.\n    pub mds: [[Zq; WIDTH]; WIDTH],\n}\n\nimpl\u003cconst WIDTH: usize, const ROUNDS: usize, const PARTIAL_ROUNDS: usize, const ALPHA: u64\u003e Default\n    for PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cconst WIDTH: usize, const ROUNDS: usize, const PARTIAL_ROUNDS: usize, const ALPHA: u64\u003e\n    PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e\n{\n    /// Constructs a fresh permutation instance with **zero** initial state and\n    /// randomly generated ARK and MDS parameters.\n    ///\n    /// ARK and MDS generation works for testing porpuses,\n    /// but their correctness and security needs careful consideration.\n    pub fn new() -\u003e Self {\n        Self {\n            state: [Zq::ZERO; WIDTH],\n            ark: Self::generate_round_constants(),\n            mds: Self::generate_mds_matrix(rng()),\n        }\n    }\n\n    /// Constructs a permutation whose *parameterisation* (ARK \u0026 MDS) is fully\n    /// specified by the caller.\n    ///\n    /// This constructor is the preferred choice for reproducible behaviour in\n    /// tests or when deploying standard Poseidon instances.\n    pub fn new_with_ark_mds(ark: [[Zq; WIDTH]; ROUNDS], mds: [[Zq; WIDTH]; WIDTH]) -\u003e Self {\n        Self {\n            state: [Zq::ZERO; WIDTH],\n            ark,\n            mds,\n        }\n    }\n\n    // Generates ARK matrix\n    fn generate_round_constants() -\u003e [[Zq; WIDTH]; ROUNDS] {\n        // Create a matrix to store constants for each round and state position\n        let mut ark = [[Zq::new(0); WIDTH]; ROUNDS];\n\n        // Iterate over the rows (rounds)\n        for row in ark.iter_mut().take(ROUNDS) {\n            // Iterate over the states in the current row using `iter_mut` for mutable access\n            for state in row.iter_mut().take(WIDTH) {\n                // 4 random bytes to use as input (seed)\n                let seed: [u8; 4] = random();\n\n                // Hasher based on Blake2b\n                let mut hasher = Blake2b256::new();\n                hasher.update(seed);\n\n                // Get the hash output\n                let hash_result: [u8; 32] = hasher.finalize().into();\n\n                // Take the first 4 bytes of the hash\n                let hash_bytes: [u8; 4] = hash_result[..4]\n                    .try_into()\n                    .expect(\"can cast a slice into an array\");\n\n                // Convert those 4 bytes into a u32 value\n                let constant = u32::from_le_bytes(hash_bytes);\n\n                // Store the constant in the matrix\n                *state = Zq::new(constant);\n            }\n        }\n        ark\n    }\n\n    /// Generates an MDS (Maximum Distance Separable) matrix using a Cauchy matrix\n    fn generate_mds_matrix\u003cR: CryptoRng\u003e(mut rng: R) -\u003e [[Zq; WIDTH]; WIDTH] {\n        let uniform = Uniform::new_inclusive(Zq::ZERO, Zq::MAX).unwrap();\n\n        let mut x_vals = Vec::new();\n        let mut y_vals = Vec::new();\n\n        // Sample unique x values\n        while x_vals.len() \u003c WIDTH {\n            let candidate = uniform.sample(\u0026mut rng);\n            if !x_vals.contains(\u0026candidate) {\n                x_vals.push(candidate);\n            }\n        }\n\n        // Sample unique y values with additional constraint\n        while y_vals.len() \u003c WIDTH {\n            let candidate = uniform.sample(\u0026mut rng);\n            let valid =\n                !y_vals.contains(\u0026candidate) \u0026\u0026 !x_vals.iter().any(|x| *x + candidate == Zq::ZERO);\n            if valid {\n                y_vals.push(candidate);\n            }\n        }\n\n        // Construct the Cauchy matrix\n        let mut matrix = [[Zq::ZERO; WIDTH]; WIDTH];\n\n        for (i, \u0026x_val) in x_vals.iter().enumerate() {\n            for (j, \u0026y_val) in y_vals.iter().enumerate() {\n                let denom = x_val + y_val;\n                matrix[i][j] = denom.inv().expect(\"Inverse must exist here\");\n            }\n        }\n\n        matrix\n    }\n\n    // Adds the *round constants* (`ARK`) for the given round number to the\n    /// current state **in‑place**.\n    fn apply_round_constants(\u0026mut self, round_num: usize) {\n        for (i, elem) in self.state.iter_mut().enumerate() {\n            *elem += self.ark[round_num][i];\n        }\n    }\n\n    /// Applies the S‑box \\(x \\mapsto x^{ALPHA}\\) to the state.\n    ///\n    /// * When `is_full_round == true` the exponentiation is applied to **every**\n    ///   lane.\n    /// * Otherwise *only the first* state element (`state[0]`) is transformed –\n    ///   this corresponds to a **partial round** in the Poseidon/Hades design.\n    fn apply_s_box(\u0026mut self, is_full_round: bool) {\n        if is_full_round {\n            for elem in \u0026mut self.state {\n                *elem = elem.pow(ALPHA);\n            }\n        } else {\n            self.state[0] = self.state[0].pow(ALPHA);\n        }\n    }\n\n    /// Multiplies the state by the MDS matrix.\n    fn apply_mds(\u0026mut self) {\n        let mut old_state = self.state;\n        // Matrix multiplication with the state for diffusion\n        for (i, _cur) in self.state.iter().enumerate() {\n            let mut sum: Zq = Zq::ZERO;\n            for (j, elem) in self.state.iter().enumerate() {\n                // matrix multiplication\n                sum += *elem * self.mds[i][j];\n            }\n            old_state[i] = sum;\n        }\n        self.state = old_state;\n    }\n\n    /// Executes the complete Poseidon permutation on the internal state.\n    ///\n    /// Each round performs, in order:\n    /// 1. Add‑round‑constants (ARK)\n    /// 2. S‑box (either full or partial)\n    /// 3. MDS multiplication\n    pub fn permute(\u0026mut self) {\n        let full_rounds_half = (ROUNDS - PARTIAL_ROUNDS) / 2;\n        // --- first half of full rounds --------------------------------------------------------\n        for i in 0..full_rounds_half {\n            self.apply_round_constants(i);\n            self.apply_s_box(true);\n            self.apply_mds();\n        }\n        // --- partial rounds -------------------------------------------------------------------\n        for i in full_rounds_half..(full_rounds_half + PARTIAL_ROUNDS) {\n            self.apply_round_constants(i);\n            self.apply_s_box(false); // Apply the S-box to the first element only\n            self.apply_mds();\n        }\n        // --- second half of full rounds -------------------------------------------------------\n        for i in (full_rounds_half + PARTIAL_ROUNDS)..(ROUNDS) {\n            self.apply_round_constants(i);\n            self.apply_s_box(true);\n            self.apply_mds();\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::poseidon::permutation::PoseidonPermutation;\n    use crate::zq::Zq;\n\n    type Permutation1 = PoseidonPermutation\u003c6, 41, 6, 3\u003e;\n    type Permutation2 = PoseidonPermutation\u003c6, 6, 6, 3\u003e;\n    type Permutation3 = PoseidonPermutation\u003c2, 2, 0, 1\u003e;\n    type Permutation4 = PoseidonPermutation\u003c2, 3, 1, 2\u003e;\n\n    #[test]\n    fn test_correct_permutation_config() {\n        let permutation = Permutation1::new();\n        assert_eq!(permutation.state.len(), 6);\n    }\n\n    #[test]\n    fn test_s_box_partial_round_alpha_3() {\n        // Arrange\n        let mut permutation = Permutation1::new();\n        for (ctr, elem) in permutation.state.iter_mut().enumerate() {\n            *elem = Zq::new(ctr as u32 + 10);\n        }\n\n        // Act\n        permutation.apply_s_box(false);\n\n        // Assert\n        assert_eq!(permutation.state[0], Zq::new(10).pow(3));\n        for i in 1..(permutation.state.len()) {\n            assert_eq!(permutation.state[i], Zq::new(i as u32 + 10));\n        }\n    }\n\n    #[test]\n    fn test_s_box_full_round_alpha_3() {\n        // Arrange\n        let mut permutation = Permutation1::new();\n        for (ctr, elem) in permutation.state.iter_mut().enumerate() {\n            *elem = Zq::new(ctr as u32 + 10);\n        }\n\n        // Act\n        permutation.apply_s_box(true);\n\n        // Assert\n        for (index, elem) in permutation.state.iter().enumerate() {\n            assert_eq!(elem, \u0026Zq::new(index as u32 + 10).pow(3));\n        }\n    }\n\n    #[test]\n    fn test_apply_ark() {\n        // Arrange\n        let mut permutation = Permutation2::new();\n        permutation.ark = [\n            [\n                Zq::new(0),\n                Zq::new(1),\n                Zq::new(2),\n                Zq::new(3),\n                Zq::new(4),\n                Zq::new(5),\n            ],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n        ];\n\n        // Act\n        permutation.apply_round_constants(0);\n\n        // Assert\n        for (idx, elem) in permutation.state.iter().enumerate() {\n            assert_eq!(elem, \u0026Zq::new(idx as u32));\n        }\n    }\n\n    #[test]\n    fn test_apply_mds_all_one_matrix() {\n        // Arrange\n        let mut permutation = Permutation1::new();\n        permutation.mds = [\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n        ];\n        for (i, elem) in permutation.state.iter_mut().enumerate() {\n            *elem = Zq::new((i + 1) as u32); // state = [1,2,3,4,5,6]\n        }\n\n        // Act\n        permutation.apply_mds();\n\n        // Assert\n        let expected = Zq::new(21);\n        for elem in \u0026permutation.state {\n            assert_eq!(elem, \u0026expected);\n        }\n    }\n\n    /// permute: ALPHA = 1 (identity S-box) and identity MDS.\n    /// With two full rounds and *no* partial rounds the permutation\n    /// should simply add the round constants twice.\n    #[test]\n    fn test_permute_with_identity_mds_s_box() {\n        // Arrange\n        let mut permutation = Permutation3::new();\n        permutation.ark = [[Zq::new(5), Zq::new(7)], [Zq::new(11), Zq::new(13)]];\n        permutation.mds = [[Zq::new(1), Zq::new(0)], [Zq::new(0), Zq::new(1)]];\n\n        // Act\n        permutation.permute();\n\n        // Assert\n        assert_eq!(permutation.state[0], Zq::new(16)); // 5+11\n        assert_eq!(permutation.state[1], Zq::new(20)); // 7+13\n    }\n\n    /// permute: ALPHA = 2 (square), **one partial round**.\n    /// Identity MDS and zero ARK so the result depends *only*\n    /// on the S-box schedule:\n    ///\n    ///   initial:     (2,3)\n    ///   round-0 F:   ( 4,  9)\n    ///   round-1 P:   (16,  9)\n    ///   round-2 F:   (256, 81)\n    #[test]\n    fn test_permute_partial_round_sbox() {\n        // Arrange\n        let mut permutation = Permutation4::new();\n        permutation.ark = [[Zq::ZERO; 2]; 3];\n        permutation.mds = [[Zq::new(1), Zq::new(0)], [Zq::new(0), Zq::new(1)]];\n        permutation.state[0] = Zq::new(2);\n        permutation.state[1] = Zq::new(3);\n\n        // Act\n        permutation.permute();\n\n        // Assert\n        assert_eq!(permutation.state[0], Zq::new(256));\n        assert_eq!(permutation.state[1], Zq::new(81));\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":69},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","poseidon","sponge.rs"],"content":"use super::permutation::PoseidonPermutation;\nuse crate::zq::Zq;\n\n/// Errors that can occur while manipulating the underlying Poseidon state during\n/// **absorption**.\n#[derive(Debug)]\npub enum PoseidonError {\n    /// Attempted to write to an index outside the state array.\n    OutOfBounds(usize),\n    /// Called with an *empty* input vector when one was expected.\n    EmptyInput,\n}\n\n/// Errors returned by [`PoseidonSponge::squeeze`] when the caller’s request\n/// is incompatible with the sponge *rate*.\n#[derive(Debug, thiserror::Error)]\npub enum SpongeError {\n    /// The requested number of field elements exceeds the sponge rate.\n    #[error(\"Squeeze request of {requested} exceeds rate {rate}\")]\n    OversizedSqueeze { requested: usize, rate: usize },\n}\n\n/// Generic Poseidon **sponge construction**.\n///\n/// The sponge is parameterised over\n/// * `OUTPUT_LENGTH` – number of field elements returned by [`compute_hash`].\n/// * `RATE` – how many of the `WIDTH` state words are exposed during\n///   *absorb*/*squeeze* (i.e. *capacity* = `WIDTH - RATE`).\n/// * `WIDTH`, `ROUNDS`, `PARTIAL_ROUNDS`, `ALPHA` – forwarded to\n///   [`PoseidonPermutation`].\n///\n/// **Usage pattern**:\n/// 1. Create with [`new`], providing the message as `Vec\u003cZq\u003e` and a\n///    permutation instance.\n/// 2. Call [`compute_hash`] to obtain the digest.\npub struct PoseidonSponge\u003c\n    const OUTPUT_LENGTH: usize,\n    const RATE: usize,\n    const WIDTH: usize,\n    const ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n    const ALPHA: u64,\n\u003e {\n    /// Buffer holding the message to be absorbed.\n    input: Vec\u003cZq\u003e,\n    /// Output of length `OUTPUT_LENGTH`; initialised to all‑zero.\n    output: [Zq; OUTPUT_LENGTH],\n    /// Internal Poseidon permutation instance.\n    permutation: PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e,\n}\n\nimpl\u003c\n        const OUTPUT_LENGTH: usize,\n        const RATE: usize,\n        const WIDTH: usize,\n        const ROUNDS: usize,\n        const PARTIAL_ROUNDS: usize,\n        const ALPHA: u64,\n    \u003e PoseidonSponge\u003cOUTPUT_LENGTH, RATE, WIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e\n{\n    /// Constructs a new sponge with the provided *message* and *permutation\n    /// parameters*.\n    pub fn new(\n        input: Vec\u003cZq\u003e,\n        permutation: PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e,\n    ) -\u003e Self {\n        Self {\n            input,\n            output: [Zq::ZERO; OUTPUT_LENGTH],\n            permutation,\n        }\n    }\n\n    /// **Absorb** the message into the sponge state according to the Poseidon\n    /// rate/capacity split, forwarding to [`PoseidonPermutation::permute`] each\n    /// time the rate section is filled. Returns an error only in pathological\n    /// circumstances (e.g. writing out of bounds if `RATE`/`WIDTH` are\n    /// miss‑configured).\n    fn absorb(\u0026mut self) -\u003e Result\u003c(), PoseidonError\u003e {\n        let mut remaining = self.input.clone();\n        let mut position = 0;\n\n        while !remaining.is_empty() {\n            let available_space = RATE - position;\n            let elements_to_absorb = remaining.len().min(available_space);\n            let elements_to_process = \u0026remaining[..elements_to_absorb];\n\n            for (i, elem) in elements_to_process.iter().enumerate() {\n                let target_index = WIDTH - RATE + position + i;\n                if target_index \u003e= self.permutation.state.len() {\n                    return Err(PoseidonError::OutOfBounds(target_index));\n                }\n                self.permutation.state[target_index] += *elem;\n            }\n\n            remaining = (remaining[elements_to_absorb..]).to_vec();\n\n            if remaining.is_empty() {\n                self.permutation.permute();\n                return Ok(());\n            }\n            self.permutation.permute();\n            position = 0;\n        }\n\n        Ok(())\n    }\n\n    /// **Squeeze** `OUTPUT_LENGTH` field elements from the sponge. This is\n    /// cached so that subsequent calls return the same slice without\n    /// recomputation.\n    fn squeeze(\u0026mut self) -\u003e Result\u003c[Zq; OUTPUT_LENGTH], SpongeError\u003e {\n        // Check if the requested number of elements exceeds the rate.\n        if OUTPUT_LENGTH \u003e RATE {\n            return Err(SpongeError::OversizedSqueeze {\n                requested: OUTPUT_LENGTH,\n                rate: RATE,\n            });\n        }\n\n        let mut output = [Zq::ZERO; OUTPUT_LENGTH];\n        let mut remaining_elements = output.as_mut_slice();\n        let mut squeeze_index = 0;\n        // Loop until we return the expected amount\n        loop {\n            if squeeze_index + remaining_elements.len() \u003c= RATE {\n                remaining_elements.copy_from_slice(\n                    \u0026self.permutation.state[WIDTH - RATE + squeeze_index\n                        ..WIDTH - RATE + remaining_elements.len() + squeeze_index],\n                );\n                return Ok(output);\n            }\n            // Reset squeeze index in case we need to squeeze again to fill the output\n            let num_elements_squeezed = RATE - squeeze_index;\n            remaining_elements[..num_elements_squeezed].copy_from_slice(\n                \u0026self.permutation.state[WIDTH - RATE + squeeze_index\n                    ..WIDTH - RATE + num_elements_squeezed + squeeze_index],\n            );\n\n            remaining_elements = \u0026mut remaining_elements[num_elements_squeezed..];\n            self.permutation.permute();\n            squeeze_index = 0;\n        }\n    }\n\n    /// Computes (and caches) the Poseidon hash of the input message. Repeated\n    /// calls are **free** after the first one.\n    pub fn compute_hash(\u0026mut self) -\u003e \u0026[Zq] {\n        if self.output.iter().all(|\u0026x| x == Zq::ZERO) {\n            self.absorb().expect(\"absorb failed\");\n            self.output = self.squeeze().expect(\"squeeze failed\");\n        }\n        \u0026self.output\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{PoseidonPermutation, PoseidonSponge};\n    use crate::zq::Zq;\n\n    #[test]\n    fn test_absorb_fills_rate_then_permute() {\n        // Arrange\n        // WIDTH = 4, RATE = 2 → capacity = 2\n        let mut permutation = PoseidonPermutation::\u003c4, 2, 0, 1\u003e::new();\n        permutation.mds = [[Zq::ZERO; 4]; 4];\n        for i in 0..4 {\n            permutation.mds[i][i] = Zq::ONE;\n        }\n        permutation.ark = [[Zq::ZERO; 4]; 2];\n        let msg = vec![Zq::new(5), Zq::new(7)];\n        let mut sponge = PoseidonSponge::\u003c1, 2, 4, 2, 0, 1\u003e::new(msg, permutation);\n\n        // absorb is implicit inside compute_hash\n        sponge.absorb().unwrap();\n\n        // After absorption the last `RATE` lanes should hold the message as we\n        // used an identity permutation.\n        assert_eq!(sponge.permutation.state[2], Zq::new(5));\n        assert_eq!(sponge.permutation.state[3], Zq::new(7));\n    }\n}\n","traces":[{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","shake","mod.rs"],"content":"use sha3::{\n    digest::{ExtendableOutput, Update, XofReader},\n    Shake256,\n};\n\nuse crate::ring::{rq::Rq, zq::Zq};\nuse crate::transcript::Sponge;\n\npub struct ShakeSponge {\n    hasher: Shake256,\n}\n\nimpl Sponge for ShakeSponge {\n    fn default() -\u003e Self {\n        Self {\n            hasher: Shake256::default(),\n        }\n    }\n    fn absorb_zq(\u0026mut self, input: \u0026[Zq]) {\n        // Convert Rq ector to u8\n        let mut u8_version_input: Vec\u003cu8\u003e = Vec::new();\n        for coeff in input {\n            u8_version_input.extend_from_slice(\u0026coeff.get_value().to_be_bytes());\n        }\n        self.hasher.update(\u0026u8_version_input);\n    }\n\n    fn absorb_rq(\u0026mut self, input: \u0026[Rq]) {\n        // Convert Rq ector to u8\n        let mut u8_version_input: Vec\u003cu8\u003e = Vec::new();\n        for rq in input {\n            for coeff in rq.get_coefficients() {\n                u8_version_input.extend_from_slice(\u0026coeff.get_value().to_be_bytes());\n            }\n        }\n        self.hasher.update(\u0026u8_version_input);\n    }\n\n    fn squeeze_bits(\u0026mut self, bit_length: usize) -\u003e Vec\u003cbool\u003e {\n        let byte_len = bit_length.div_ceil(8);\n        let mut reader = self.hasher.clone().finalize_xof();\n        let mut output_buffer = vec![u8::default(); byte_len];\n        reader.read(\u0026mut output_buffer);\n\n        let mut result = Vec::with_capacity(bit_length);\n        for byte in \u0026output_buffer {\n            let mut mask = 1u8;\n            for _ in 0..8 {\n                if result.len() == bit_length {\n                    break;\n                }\n                result.push(byte \u0026 mask != 0);\n                mask \u003c\u003c= 1;\n            }\n        }\n        self.hasher.update(\u0026output_buffer);\n        result\n    }\n\n    fn squeeze_zq(\u0026mut self, output_length: usize) -\u003e Vec\u003cZq\u003e {\n        let mut reader = self.hasher.clone().finalize_xof();\n        let mut output_buffer = vec![u8::default(); output_length * 4];\n        reader.read(\u0026mut output_buffer);\n\n        let zq_values: Vec\u003cZq\u003e = output_buffer\n            .chunks_exact(4)\n            .map(|chunk| {\n                u32::from_le_bytes(chunk.try_into().expect(\"Could not convert 4 u8 to one u32\"))\n            })\n            .map(Zq::new)\n            .collect();\n\n        self.absorb_zq(\u0026zq_values);\n        zq_values\n    }\n\n    fn squeeze_rq(\u0026mut self, output_length: usize) -\u003e Vec\u003cRq\u003e {\n        let mut reader = self.hasher.clone().finalize_xof();\n        let mut output_buffer = vec![u8::default(); output_length * Rq::DEGREE * 4];\n        reader.read(\u0026mut output_buffer);\n\n        let zq_values: Vec\u003cZq\u003e = output_buffer\n            .chunks_exact(4)\n            .map(|chunk| {\n                u32::from_le_bytes(chunk.try_into().expect(\"Could not convert 4 u8 to one u32\"))\n            })\n            .map(Zq::new)\n            .collect();\n\n        let result: Vec\u003cRq\u003e = zq_values\n            .chunks_exact(Rq::DEGREE)\n            .map(|chunk| {\n                let rq_input: [Zq; Rq::DEGREE] =\n                    chunk.try_into().expect(\"Chunk size is Rq::DEGREE\");\n                Rq::new(rq_input)\n            })\n            .collect();\n\n        self.absorb_rq(\u0026result);\n        result\n    }\n\n    fn squeeze_bytes(\u0026mut self, byte_length: usize) -\u003e Vec\u003cu8\u003e {\n        let mut reader = self.hasher.clone().finalize_xof();\n        let mut output_buffer = vec![u8::default(); byte_length];\n        reader.read(\u0026mut output_buffer);\n        self.hasher.update(\u0026output_buffer);\n        output_buffer\n    }\n}\n\n#[cfg(test)]\nmod test_sponge_correctness {\n    use super::*;\n    use crate::ring::zq::UniformZq;\n    use rand::{distr::uniform::UniformSampler, rng};\n\n    fn random_zq_vector(n: usize) -\u003e Vec\u003cZq\u003e {\n        let uniform = UniformZq::new_inclusive(Zq::ZERO, Zq::NEG_ONE).unwrap();\n        (0..n).map(|_| uniform.sample(\u0026mut rng())).collect()\n    }\n\n    #[test]\n    fn test_zq_sponge_execution() {\n        let mut sponge = ShakeSponge::default();\n        let polynomial_1 = Rq::new([Zq::new(2); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(5); Rq::DEGREE]);\n        let polynomial_3 = Rq::new([Zq::new(1); Rq::DEGREE]);\n\n        sponge.absorb_rq(\u0026[polynomial_1, polynomial_2, polynomial_3]);\n        let result = sponge.squeeze_rq(1);\n        assert_eq!(result.len(), 1);\n    }\n\n    #[test]\n    fn test_rq_sponge_execution() {\n        let mut sponge = ShakeSponge::default();\n        let input: Vec\u003cZq\u003e = random_zq_vector(64);\n        sponge.absorb_zq(\u0026input);\n        let result = sponge.squeeze_rq(1);\n        assert_eq!(result.len(), 1);\n    }\n\n    #[test]\n    fn test_zq_squeeze_output_size() {\n        let mut sponge = ShakeSponge::default();\n        let input: Vec\u003cZq\u003e = random_zq_vector(64);\n        sponge.absorb_zq(\u0026input);\n        let result = sponge.squeeze_zq(1000);\n        assert_eq!(result.len(), 1000);\n    }\n\n    #[test]\n    fn test_rq_squeeze_output_size() {\n        let mut sponge = ShakeSponge::default();\n        let polynomial_1 = Rq::new([Zq::new(2); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(5); Rq::DEGREE]);\n        let polynomial_3 = Rq::new([Zq::new(1); Rq::DEGREE]);\n\n        sponge.absorb_rq(\u0026[polynomial_1, polynomial_2, polynomial_3]);\n        let result = sponge.squeeze_rq(1000);\n        assert_eq!(result.len(), 1000);\n    }\n\n    #[test]\n    fn test_absorb_zq_is_deterministic() {\n        let input: Vec\u003cZq\u003e = random_zq_vector(64);\n        let mut s1 = ShakeSponge::default();\n        let mut s2 = ShakeSponge::default();\n        s1.absorb_zq(\u0026input);\n        s2.absorb_zq(\u0026input);\n        let out1 = s1.squeeze_zq(8);\n        let out2 = s2.squeeze_zq(8);\n        assert_eq!(out1, out2);\n    }\n\n    #[test]\n    fn test_absorb_rq_is_deterministic() {\n        let polynomial_1 = Rq::new([Zq::new(54821); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(2131213); Rq::DEGREE]);\n        let polynomial_3 = Rq::new([Zq::new(9891741); Rq::DEGREE]);\n\n        let mut sponge1 = ShakeSponge::default();\n        sponge1.absorb_rq(\u0026[\n            polynomial_1.clone(),\n            polynomial_2.clone(),\n            polynomial_3.clone(),\n        ]);\n\n        let mut sponge2 = ShakeSponge::default();\n        sponge2.absorb_rq(\u0026[polynomial_1, polynomial_2, polynomial_3]);\n        assert_eq!(sponge1.squeeze_rq(1), sponge2.squeeze_rq(1))\n    }\n\n    #[test]\n    fn test_zq_successive_squeezes_is_unique() {\n        let mut s = ShakeSponge::default();\n        let input: Vec\u003cZq\u003e = random_zq_vector(32);\n        s.absorb_zq(\u0026input);\n        let o1 = s.squeeze_zq(8);\n        let o2 = s.squeeze_zq(8);\n        assert_ne!(o1, o2);\n    }\n\n    #[test]\n    fn test_rq_successive_squeezes_is_unique() {\n        let polynomial_1 = Rq::new([Zq::new(54821); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(2131213); Rq::DEGREE]);\n\n        let mut sponge = ShakeSponge::default();\n        sponge.absorb_rq(\u0026[polynomial_1, polynomial_2]);\n        let result1 = sponge.squeeze_rq(1);\n        let result2 = sponge.squeeze_rq(1);\n        assert_ne!(result1, result2)\n    }\n\n    #[test]\n    fn test_zq_output_can_be_large() {\n        let mut s = ShakeSponge::default();\n        let input: Vec\u003cZq\u003e = random_zq_vector(16);\n        s.absorb_zq(\u0026input);\n        let out = s.squeeze_zq(1000);\n        assert_eq!(out.len(), 1000);\n    }\n\n    #[test]\n    fn test_rq_output_can_be_large() {\n        let polynomial_1 = Rq::new([Zq::new(54821); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(2131213); Rq::DEGREE]);\n\n        let mut sponge = ShakeSponge::default();\n        sponge.absorb_rq(\u0026[polynomial_1, polynomial_2]);\n\n        assert_eq!(sponge.squeeze_rq(1000).len(), 1000);\n    }\n\n    #[test]\n    fn test_squeeze_message_order() {\n        let polynomial_1 = Rq::new([Zq::new(54821); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(2131213); Rq::DEGREE]);\n\n        let mut sponge1 = ShakeSponge::default();\n        sponge1.absorb_rq(\u0026[polynomial_1.clone(), polynomial_2.clone()]);\n\n        let mut sponge2 = ShakeSponge::default();\n        sponge2.absorb_rq(\u0026[polynomial_2, polynomial_1]);\n        assert_ne!(sponge1.squeeze_rq(1), sponge2.squeeze_rq(1))\n    }\n\n    #[test]\n    fn test_different_inputs_diff_outputs() {\n        let input1: Vec\u003cZq\u003e = random_zq_vector(64);\n        let input2: Vec\u003cZq\u003e = random_zq_vector(64);\n        let mut s1 = ShakeSponge::default();\n        let mut s2 = ShakeSponge::default();\n        s1.absorb_zq(\u0026input1);\n        s2.absorb_zq(\u0026input2);\n        let o1 = s1.squeeze_zq(8);\n        let o2 = s2.squeeze_zq(8);\n        assert_ne!(o1, o2);\n    }\n\n    /// Edge case: zero‑length squeeze should not panic and must return empty vecs.\n    #[test]\n    fn zero_length_squeeze() {\n        let mut s = ShakeSponge::default();\n        assert!(s.squeeze_zq(0).is_empty());\n        assert!(s.squeeze_rq(0).is_empty());\n    }\n\n    #[test]\n    fn squeeze_bits_deterministic_and_length() {\n        let mut s1 = ShakeSponge::default();\n        let mut s2 = ShakeSponge::default();\n        s1.absorb_zq(\u0026[Zq::new(41)]);\n        s2.absorb_zq(\u0026[Zq::new(41)]);\n\n        let b1 = s1.squeeze_bits(123);\n        let b2 = s2.squeeze_bits(123);\n        assert_eq!(b1, b2); // deterministic\n        assert_eq!(b1.len(), 123); // exact length\n    }\n}\n\n#[cfg(test)]\nmod test_sponge_randomness {\n    // We should test squeeze outputs are random-looking\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":30}},{"line":16,"address":[],"length":0,"stats":{"Line":30}},{"line":19,"address":[],"length":0,"stats":{"Line":50}},{"line":21,"address":[],"length":0,"stats":{"Line":50}},{"line":22,"address":[],"length":0,"stats":{"Line":40328174}},{"line":25,"address":[],"length":0,"stats":{"Line":50}},{"line":28,"address":[],"length":0,"stats":{"Line":36}},{"line":30,"address":[],"length":0,"stats":{"Line":36}},{"line":31,"address":[],"length":0,"stats":{"Line":4272}},{"line":32,"address":[],"length":0,"stats":{"Line":135552}},{"line":36,"address":[],"length":0,"stats":{"Line":36}},{"line":39,"address":[],"length":0,"stats":{"Line":184}},{"line":40,"address":[],"length":0,"stats":{"Line":184}},{"line":41,"address":[],"length":0,"stats":{"Line":184}},{"line":42,"address":[],"length":0,"stats":{"Line":184}},{"line":43,"address":[],"length":0,"stats":{"Line":184}},{"line":45,"address":[],"length":0,"stats":{"Line":184}},{"line":46,"address":[],"length":0,"stats":{"Line":2432}},{"line":48,"address":[],"length":0,"stats":{"Line":8832}},{"line":49,"address":[],"length":0,"stats":{"Line":7892}},{"line":50,"address":[],"length":0,"stats":{"Line":184}},{"line":52,"address":[],"length":0,"stats":{"Line":7708}},{"line":53,"address":[],"length":0,"stats":{"Line":7708}},{"line":56,"address":[],"length":0,"stats":{"Line":184}},{"line":57,"address":[],"length":0,"stats":{"Line":184}},{"line":60,"address":[],"length":0,"stats":{"Line":37}},{"line":61,"address":[],"length":0,"stats":{"Line":37}},{"line":62,"address":[],"length":0,"stats":{"Line":37}},{"line":63,"address":[],"length":0,"stats":{"Line":37}},{"line":65,"address":[],"length":0,"stats":{"Line":37}},{"line":67,"address":[],"length":0,"stats":{"Line":20162897}},{"line":68,"address":[],"length":0,"stats":{"Line":20162860}},{"line":70,"address":[],"length":0,"stats":{"Line":37}},{"line":73,"address":[],"length":0,"stats":{"Line":37}},{"line":74,"address":[],"length":0,"stats":{"Line":37}},{"line":77,"address":[],"length":0,"stats":{"Line":18}},{"line":78,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":18}},{"line":80,"address":[],"length":0,"stats":{"Line":18}},{"line":82,"address":[],"length":0,"stats":{"Line":18}},{"line":84,"address":[],"length":0,"stats":{"Line":131538}},{"line":85,"address":[],"length":0,"stats":{"Line":131520}},{"line":87,"address":[],"length":0,"stats":{"Line":18}},{"line":90,"address":[],"length":0,"stats":{"Line":18}},{"line":91,"address":[],"length":0,"stats":{"Line":18}},{"line":92,"address":[],"length":0,"stats":{"Line":2073}},{"line":93,"address":[],"length":0,"stats":{"Line":2055}},{"line":94,"address":[],"length":0,"stats":{"Line":2055}},{"line":95,"address":[],"length":0,"stats":{"Line":2055}},{"line":99,"address":[],"length":0,"stats":{"Line":18}},{"line":100,"address":[],"length":0,"stats":{"Line":18}},{"line":103,"address":[],"length":0,"stats":{"Line":11466}},{"line":104,"address":[],"length":0,"stats":{"Line":11466}},{"line":105,"address":[],"length":0,"stats":{"Line":11466}},{"line":106,"address":[],"length":0,"stats":{"Line":11466}},{"line":107,"address":[],"length":0,"stats":{"Line":11466}},{"line":108,"address":[],"length":0,"stats":{"Line":11466}}],"covered":57,"coverable":57},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","verifier.rs"],"content":"#![allow(clippy::result_large_err)]\n\nuse thiserror::Error;\n\nuse crate::commitments::common_instances::AjtaiInstances;\nuse crate::commitments::outer_commitments::{self, DecompositionParameters};\nuse crate::core::aggregate::{FunctionsAggregation, ZeroConstantFunctionsAggregation};\nuse crate::core::inner_product;\nuse crate::relation::env_params;\nuse crate::relation::{env_params::EnvironmentParameters, statement::Statement};\nuse crate::ring::rq::Rq;\nuse crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\nuse crate::transcript::{LabradorTranscript, Sponge};\n\n#[derive(Debug, Error)]\npub enum VerifierError {\n    #[error(\"matrix not symmetric at ({i},{j}): expected {expected:?}, found {found:?}\")]\n    NotSymmetric {\n        i: usize,\n        j: usize,\n        expected: Rq,\n        found: Rq,\n    },\n    #[error(\"B0 mismatch at index {index}: expected {expected}, computed {computed}\")]\n    B0Mismatch {\n        index: usize,\n        expected: Zq,\n        computed: Zq,\n    },\n    #[error(\"‖z‖² = {norm} exceeds allowed bound {allowed}\")]\n    NormSumExceeded { norm: Zq, allowed: Zq },\n    #[error(\"A·z check failed: expected {expected:?}, computed {computed:?}\")]\n    AzError {\n        computed: RqVector,\n        expected: RqVector,\n    },\n    #[error(\"⟨z,z⟩ mismatch: expected {expected:?}, computed {computed:?}\")]\n    ZInnerError { computed: Rq, expected: Rq },\n    #[error(\"φ(z) mismatch: expected {expected:?}, computed {computed:?}\")]\n    PhiError { computed: Rq, expected: Rq },\n    #[error(\"relation check failed\")]\n    RelationCheckFailed,\n    #[error(\"outer commitment mismatch: expected {expected:?}, computed {computed:?}\")]\n    OuterCommitError {\n        computed: RqVector,\n        expected: RqVector,\n    },\n    #[error(transparent)]\n    DecompositionError(#[from] outer_commitments::DecompositionError),\n}\npub struct LabradorVerifier\u003c'a\u003e {\n    params: \u0026'a EnvironmentParameters,\n    crs: \u0026'a AjtaiInstances,\n    st: \u0026'a Statement,\n    // Aggregation instances\n    constant_aggregator: ZeroConstantFunctionsAggregation\u003c'a\u003e,\n    funcs_aggregator: FunctionsAggregation\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e LabradorVerifier\u003c'a\u003e {\n    pub fn new(\n        params: \u0026'a EnvironmentParameters,\n        crs: \u0026'a AjtaiInstances,\n        st: \u0026'a Statement,\n    ) -\u003e Self {\n        Self {\n            params,\n            crs,\n            st,\n            constant_aggregator: ZeroConstantFunctionsAggregation::new(params),\n            funcs_aggregator: FunctionsAggregation::new(params),\n        }\n    }\n\n    /// All check conditions are from page 18\n    pub fn verify\u003cS: Sponge\u003e(\n        \u0026mut self,\n        proof: \u0026LabradorTranscript\u003cS\u003e,\n    ) -\u003e Result\u003cbool, VerifierError\u003e {\n        let mut transcript = LabradorTranscript::new(S::default());\n\n        transcript.absorb_u1(\u0026proof.u1);\n        let projections = transcript.generate_projections(\n            env_params::SECURITY_PARAMETER,\n            self.params.rank,\n            self.params.multiplicity,\n        );\n        transcript.absorb_vector_p(\u0026proof.vector_p);\n        let size_of_psi = usize::div_ceil(env_params::SECURITY_PARAMETER, self.params.log_q);\n        let size_of_omega = size_of_psi;\n        let psi = transcript.generate_vector_psi(size_of_psi, self.params.constraint_l);\n        let omega = transcript.generate_vector_omega(size_of_omega, env_params::SECURITY_PARAMETER);\n        transcript.absorb_vector_b_ct_aggr(\u0026proof.b_ct_aggr);\n        let vector_alpha = transcript.generate_rq_vector(self.params.constraint_k);\n        let size_of_beta = size_of_psi;\n        let vector_beta = transcript.generate_rq_vector(size_of_beta);\n        transcript.absorb_u2(\u0026proof.u2);\n        let challenges =\n            transcript.generate_challenges(env_params::OPERATOR_NORM, self.params.multiplicity);\n\n        // check b_0^{''(k)} ?= \u003comega^(k),p\u003e + \\sum(psi_l^(k) * b_0^{'(l)})\n        Self::check_b_0_aggr(self, proof, self.params, \u0026psi, \u0026omega)?;\n\n        // 3. line 14: check norm_sum(z, t, g, h) \u003c= (beta')^2\n\n        // decompose z into z = z^(0) + z^(1) * b, only two parts.\n        let z_ij = RqVector::decompose(\u0026proof.z, self.params.b, 2);\n        let t_ij: Vec\u003cVec\u003cRqVector\u003e\u003e = proof\n            .t\n            .get_elements()\n            .iter()\n            .map(|i| RqVector::decompose(i, self.params.b, self.params.t_1))\n            .collect();\n        let g_ij: Vec\u003cVec\u003cRqVector\u003e\u003e = proof\n            .g\n            .get_elements()\n            .iter()\n            .map(|i| RqVector::decompose(i, self.params.b, self.params.t_2))\n            .collect();\n        let h_ij: Vec\u003cVec\u003cRqVector\u003e\u003e = proof\n            .h\n            .get_elements()\n            .iter()\n            .map(|i| RqVector::decompose(i, self.params.b, self.params.t_1))\n            .collect();\n        let norm_z_ij = z_ij\n            .iter()\n            .fold(Zq::ZERO, |acc, p| acc + p.l2_norm_squared());\n        let norm_t_ij = Self::norm_squared(\u0026t_ij);\n        let norm_g_ij = Self::norm_squared(\u0026g_ij);\n        let norm_h_ij = Self::norm_squared(\u0026h_ij);\n        let norm_sum = norm_z_ij + norm_t_ij + norm_g_ij + norm_h_ij;\n\n        if norm_sum \u003e self.params.beta * self.params.beta {\n            return Err(VerifierError::NormSumExceeded {\n                norm: norm_sum,\n                allowed: self.params.beta * self.params.beta,\n            });\n        }\n\n        // 4. line 15: check Az ?= c_1 * t_1 + ... + c_r * t_r\n        let az = self.crs.commitment_scheme_a.matrix() * \u0026proof.z;\n        let ct_sum = inner_product::compute_linear_combination(\n            proof.t.get_elements(),\n            challenges.get_elements(),\n        );\n        if az != ct_sum {\n            return Err(VerifierError::AzError {\n                computed: az,\n                expected: ct_sum,\n            });\n        }\n\n        // 5. lne 16: check \u003cz, z\u003e ?= \\sum(g_ij * c_i * c_j)\n\n        let z_inner = inner_product::compute_linear_combination(\n            proof.z.get_elements(),\n            proof.z.get_elements(),\n        );\n        let sum_gij_cij = Self::calculate_gh_ci_cj(\u0026proof.g, \u0026challenges, self.params.multiplicity);\n\n        if z_inner != sum_gij_cij {\n            return Err(VerifierError::ZInnerError {\n                computed: z_inner,\n                expected: sum_gij_cij,\n            });\n        }\n\n        // 6. line 17: check \\sum(\u003c\\phi_i, z\u003ec_i) ?= \\sum(h_ij * c_i * c_j)\n        self.constant_aggregator.calculate_agg_phi_double_prime(\n            \u0026self.st.phi_ct,\n            \u0026projections.get_conjugated_projection_matrices(),\n            \u0026psi,\n            \u0026omega,\n        );\n        self.funcs_aggregator.calculate_aggr_phi(\n            \u0026self.st.phi_constraint,\n            self.constant_aggregator.get_phi_double_prime(),\n            \u0026vector_alpha,\n            \u0026vector_beta,\n        );\n        let sum_phi_z_c =\n            Self::calculate_phi_z_c(self.funcs_aggregator.get_appr_phi(), \u0026challenges, \u0026proof.z);\n        let sum_hij_cij = Self::calculate_gh_ci_cj(\u0026proof.h, \u0026challenges, self.params.multiplicity);\n\n        // Left side multiple by 2 because of when we calculate h_ij, we didn't apply the division (divided by 2)\n        if \u0026sum_phi_z_c * \u0026Zq::TWO != sum_hij_cij {\n            return Err(VerifierError::PhiError {\n                computed: \u0026sum_phi_z_c * \u0026Zq::TWO,\n                expected: sum_hij_cij,\n            });\n        }\n\n        // 7. line 18: check \\sum(a_ij * g_ij) + \\sum(h_ii) - b ?= 0\n\n        self.constant_aggregator\n            .calculate_agg_a_double_prime(\u0026psi, \u0026self.st.a_ct);\n        self.funcs_aggregator.calculate_agg_a(\n            \u0026self.st.a_constraint,\n            self.constant_aggregator.get_alpha_double_prime(),\n            \u0026vector_alpha,\n            \u0026vector_beta,\n        );\n\n        self.funcs_aggregator.calculate_aggr_b(\n            \u0026self.st.b_constraint,\n            \u0026proof.b_ct_aggr,\n            \u0026vector_alpha,\n            \u0026vector_beta,\n        );\n\n        if !Self::check_relation(\n            self.funcs_aggregator.get_agg_a(),\n            self.funcs_aggregator.get_aggr_b(),\n            \u0026proof.g,\n            \u0026proof.h,\n        ) {\n            return Err(VerifierError::RelationCheckFailed);\n        }\n\n        // 8. line 19: u_1 ?= \\sum(\\sum(B_ik * t_i^(k))) + \\sum(\\sum(C_ijk * g_ij^(k)))\n\n        let u_1 = \u0026proof.u1;\n        let commitment_u1 = outer_commitments::compute_u1(\n            self.crs,\n            \u0026proof.t,\n            DecompositionParameters::new(self.params.b, self.params.t_1)?,\n            \u0026proof.g,\n            DecompositionParameters::new(self.params.b, self.params.t_2)?,\n        );\n\n        if proof.u1 != commitment_u1 {\n            return Err(VerifierError::OuterCommitError {\n                computed: u_1.clone(),\n                expected: commitment_u1,\n            });\n        }\n\n        // 9. line 20: u_2 ?= \\sum(\\sum(D_ijk * h_ij^(k)))\n        let commitment_u2 = outer_commitments::compute_u2(\n            self.crs,\n            \u0026proof.h,\n            DecompositionParameters::new(self.params.b, self.params.t_1)?,\n        );\n\n        if proof.u2 != commitment_u2 {\n            return Err(VerifierError::OuterCommitError {\n                computed: commitment_u2,\n                expected: proof.u2.clone(),\n            });\n        }\n\n        Ok(true)\n    }\n\n    /// calculate the right hand side of line 16 or line 17, \\sum(g_ij * c_i * c_j) or \\sum(h_ij * c_i * c_j)\n    fn calculate_gh_ci_cj(x_ij: \u0026RqMatrix, random_c: \u0026RqVector, r: usize) -\u003e Rq {\n        (0..r)\n            .map(|i| {\n                (0..r)\n                    .map(|j| {\n                        \u0026(x_ij.get_cell(i, j) * \u0026random_c.get_elements()[i])\n                            * \u0026random_c.get_elements()[j]\n                    })\n                    .fold(Rq::zero(), |acc, x| \u0026acc + \u0026x)\n            })\n            .fold(Rq::zero(), |acc, x| \u0026acc + \u0026x)\n    }\n\n    /// calculate the left hand side of line 17, \\sum(\u003c\\phi_z, z\u003e * c_i)\n    fn calculate_phi_z_c(phi: \u0026[RqVector], c: \u0026RqVector, z: \u0026RqVector) -\u003e Rq {\n        phi.iter()\n            .zip(c.get_elements())\n            .map(|(phi_i, c_i)| {\n                \u0026(inner_product::compute_linear_combination(phi_i.get_elements(), z.get_elements()))\n                    * c_i\n            })\n            .fold(Rq::zero(), |acc, x| \u0026acc + \u0026x)\n    }\n\n    fn norm_squared(polys: \u0026[Vec\u003cRqVector\u003e]) -\u003e Zq {\n        polys.iter().fold(Zq::ZERO, |acc, poly| {\n            acc + poly\n                .iter()\n                .fold(Zq::ZERO, |acc, p| acc + p.l2_norm_squared())\n        })\n    }\n\n    /// line 18, page 18: check if \\sum(a_{ij} * g_{ij}) + \\sum(h_{ii}) - b ?= 0\n    /// in the verifier process, page 18 from the paper.\n    ///\n    /// param: a_primes: a_{ij}^{''(k)}\n    /// param: b_primes: b^{''(k)}\n    /// param: g: g_{ij}\n    /// param: h: h_{ii}\n    ///\n    /// return: true if the relation holds, false otherwise\n    pub fn check_relation(a_primes: \u0026RqMatrix, b_primes: \u0026Rq, g: \u0026RqMatrix, h: \u0026RqMatrix) -\u003e bool {\n        let r = a_primes.get_elements().len();\n\n        let mut sum_a_primes_g = Rq::zero();\n        // walk only over the stored half: i ≤ j\n        for i in 0..r {\n            for j in 0..r {\n                sum_a_primes_g = \u0026sum_a_primes_g + \u0026(a_primes.get_cell(i, j) * g.get_cell(i, j));\n            }\n        }\n\n        let sum_h_ii = (0..r).fold(Rq::zero(), |acc, i| \u0026acc + h.get_cell(i, i));\n\n        let b_primes2 = b_primes * \u0026Zq::TWO;\n        let sum_a_primes_g2 = \u0026sum_a_primes_g * \u0026Zq::TWO;\n\n        \u0026sum_a_primes_g2 + \u0026sum_h_ii == b_primes2\n    }\n\n    fn check_b_0_aggr\u003cS: Sponge\u003e(\n        \u0026self,\n        proof: \u0026LabradorTranscript\u003cS\u003e,\n        ep: \u0026EnvironmentParameters,\n        psi: \u0026[Vec\u003cZq\u003e],\n        omega: \u0026[Vec\u003cZq\u003e],\n    ) -\u003e Result\u003cbool, VerifierError\u003e {\n        for k in 0..ep.kappa {\n            let b_0_poly = proof.b_ct_aggr.get_elements()[k].get_coefficients()[0];\n            let mut b_0: Zq = (0..ep.constraint_l)\n                .map(|l| psi[k][l] * self.st.b_0_ct[l])\n                .sum();\n\n            let inner_omega_p =\n                inner_product::compute_linear_combination(\u0026omega[k], \u0026proof.vector_p);\n            b_0 += inner_omega_p;\n            if b_0 != b_0_poly {\n                return Err(VerifierError::B0Mismatch {\n                    index: k,\n                    expected: b_0_poly,\n                    computed: b_0,\n                });\n            }\n        }\n\n        Ok(true)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::prover::LabradorProver;\n    use crate::relation::witness::Witness;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_verify() {\n        let ep_1 = EnvironmentParameters::default();\n        // generate a random witness based on ep above\n        let witness_1 = Witness::new(ep_1.rank, ep_1.multiplicity, ep_1.beta);\n        // generate public statements based on witness_1\n        let st: Statement = Statement::new(\u0026witness_1, \u0026ep_1);\n        // generate the common reference string matrices\n        let crs = AjtaiInstances::new(\u0026ep_1);\n\n        // create a new prover\n        let mut prover = LabradorProver::new(\u0026ep_1, \u0026crs, \u0026witness_1, \u0026st);\n        let proof: LabradorTranscript\u003cShakeSponge\u003e = prover.prove().unwrap();\n\n        // create a new verifier\n        let mut verifier = LabradorVerifier::new(\u0026ep_1, \u0026crs, \u0026st);\n        let result = verifier.verify(\u0026proof);\n        assert!(result.unwrap());\n    }\n}\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":3}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":5}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":6}},{"line":263,"address":[],"length":0,"stats":{"Line":24}},{"line":264,"address":[],"length":0,"stats":{"Line":18}},{"line":265,"address":[],"length":0,"stats":{"Line":18}},{"line":267,"address":[],"length":0,"stats":{"Line":30}},{"line":269,"address":[],"length":0,"stats":{"Line":10}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":4}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":278,"address":[],"length":0,"stats":{"Line":3}},{"line":280,"address":[],"length":0,"stats":{"Line":5}},{"line":283,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":12}},{"line":285,"address":[],"length":0,"stats":{"Line":9}},{"line":286,"address":[],"length":0,"stats":{"Line":9}},{"line":287,"address":[],"length":0,"stats":{"Line":42}},{"line":300,"address":[],"length":0,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":305,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":9}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":5}},{"line":313,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":316,"address":[],"length":0,"stats":{"Line":1}},{"line":319,"address":[],"length":0,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":5}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":329,"address":[],"length":0,"stats":{"Line":28}},{"line":332,"address":[],"length":0,"stats":{"Line":4}},{"line":333,"address":[],"length":0,"stats":{"Line":4}},{"line":334,"address":[],"length":0,"stats":{"Line":4}},{"line":335,"address":[],"length":0,"stats":{"Line":4}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":1}}],"covered":116,"coverable":155}]};
        var previousData = {"files":[{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","commitments","ajtai_commitment.rs"],"content":"use crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\nuse thiserror::Error;\n\n// Error types with documentation\n#[derive(Debug, Error)]\npub enum ParameterError {\n    #[error(\"parameters must be positive\")]\n    ZeroParameter,\n    #[error(\"security bound β·m^(3/2) must be less than q\")]\n    SecurityBoundViolation,\n    #[error(\"invalid witness bounds specified\")]\n    InvalidWitnessBounds(Zq),\n    #[error(\"commitment output length {0} is too large\")]\n    TooLargeCommitmentLength(usize),\n}\n\n#[derive(Debug, Error)]\npub enum CommitError {\n    #[error(\"witness coefficients exceed bound {0}\")]\n    InvalidWitnessBounds(Zq),\n    #[error(\"invalid witness vector size\")]\n    InvalidWitnessSize,\n}\n\n#[derive(Debug, Error)]\npub enum VerificationError {\n    #[error(\"witness coefficients exceed bound {0}\")]\n    InvalidWitnessBounds(Zq),\n    #[error(\"commitment does not match opening\")]\n    CommitmentMismatch,\n    #[error(\"invalid opening vector size\")]\n    InvalidOpeningSize,\n    #[error(\"invalid commitment vector size\")]\n    InvalidCommitmentSize,\n}\n\n/// Ajtai commitment scheme implementation with matrix-based operations\n#[derive(Debug)]\npub struct AjtaiScheme {\n    witness_bound: Zq,\n    random_matrix: RqMatrix,\n}\n\nimpl AjtaiScheme {\n    pub fn new(witness_bound: Zq, random_matrix: RqMatrix) -\u003e Result\u003cSelf, ParameterError\u003e {\n        if witness_bound.is_zero() {\n            return Err(ParameterError::InvalidWitnessBounds(witness_bound));\n        }\n        Self::validate_parameters(\n            witness_bound,\n            random_matrix.get_row_len(),\n            random_matrix.get_col_len(),\n        )?;\n\n        Ok(Self {\n            witness_bound,\n            random_matrix,\n        })\n    }\n\n    /// Generates commitment and opening information with bounds checking\n    pub fn commit(\u0026self, witness: \u0026RqVector) -\u003e Result\u003cRqVector, CommitError\u003e {\n        if !self.check_bounds(witness) {\n            return Err(CommitError::InvalidWitnessBounds(self.witness_bound));\n        }\n        if witness.get_length() != self.random_matrix.get_col_len() {\n            return Err(CommitError::InvalidWitnessSize);\n        }\n        let commitment = \u0026self.random_matrix * witness;\n        Ok(commitment)\n    }\n\n    /// Verifies commitment against opening information\n    pub fn verify(\n        \u0026self,\n        commitment: \u0026RqVector,\n        opening: \u0026RqVector,\n    ) -\u003e Result\u003c(), VerificationError\u003e {\n        if !self.check_bounds(opening) {\n            return Err(VerificationError::InvalidWitnessBounds(self.witness_bound));\n        }\n        if opening.get_length() != self.random_matrix.get_col_len() {\n            return Err(VerificationError::InvalidOpeningSize);\n        }\n        if commitment.get_length() != self.random_matrix.get_row_len() {\n            return Err(VerificationError::InvalidCommitmentSize);\n        }\n\n        let recomputed = \u0026self.random_matrix * opening;\n        if commitment != \u0026recomputed {\n            return Err(VerificationError::CommitmentMismatch);\n        }\n\n        Ok(())\n    }\n\n    /// Validates scheme parameters against cryptographic security requirements\n    fn validate_parameters(beta: Zq, row_len: usize, col_len: usize) -\u003e Result\u003c(), ParameterError\u003e {\n        if [row_len, col_len].contains(\u00260) {\n            return Err(ParameterError::ZeroParameter);\n        }\n        Self::verify_security_relation(beta, row_len)\n    }\n\n    /// Verifies the security relation β²m³ \u003c q² required for Ajtai's commitment scheme.\n    ///\n    /// This bound ensures the scheme's security by:\n    /// 1. Making the underlying lattice problem hard (SIS assumption)\n    /// 2. Preventing statistical attacks on the commitment\n    /// 3. Ensuring the commitment is binding under standard lattice assumptions\n    ///\n    /// The relation β²m³ \u003c q² is a necessary condition derived from the security\n    /// proof of Ajtai's commitment scheme, where:\n    /// - β bounds the size of witness coefficients\n    /// - m is the commitment output length\n    /// - q is the modulus of the underlying ring\n    fn verify_security_relation(beta: Zq, m: usize) -\u003e Result\u003c(), ParameterError\u003e {\n        // Calculate q from Zq properties\n        let q: u128 = Zq::NEG_ONE.to_u128() + 1;\n\n        // Calculate beta²\n        let beta_squared = beta\n            .to_u128()\n            .checked_pow(2)\n            .ok_or(ParameterError::SecurityBoundViolation)?;\n\n        // Calculate m³\n        let m_cubed: u128 = m\n            .checked_pow(3)\n            .ok_or(ParameterError::SecurityBoundViolation)?\n            .try_into()\n            .map_err(|_| ParameterError::TooLargeCommitmentLength(m))?;\n\n        // Calculate q²\n        let q_squared = q\n            .checked_pow(2)\n            .ok_or(ParameterError::SecurityBoundViolation)?;\n\n        // Check if beta² * m³ \u003c q²\n        // Use division instead of multiplication to avoid potential overflow\n        if beta_squared \u003e= q_squared.checked_div(m_cubed).unwrap_or(0) {\n            return Err(ParameterError::SecurityBoundViolation);\n        }\n\n        Ok(())\n    }\n\n    /// Checks polynomial coefficients against specified bound\n    fn check_bounds(\u0026self, _polynomials: \u0026RqVector) -\u003e bool {\n        // As now there are no concrete parameters, we return true.\n        true\n        // polynomials\n        //     .iter()\n        //     .all(|p| p.check_bounds(self.witness_bound))\n    }\n\n    /// Returns a reference to the internal matrix\n    pub fn matrix(\u0026self) -\u003e \u0026RqMatrix {\n        \u0026self.random_matrix\n    }\n\n    /// Returns the witness bound\n    pub fn witness_bound(\u0026self) -\u003e Zq {\n        self.witness_bound\n    }\n\n    pub fn get_row_size(\u0026self) -\u003e usize {\n        self.random_matrix.get_elements().len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::ring::rq::Rq;\n\n    const TEST_M: usize = 8;\n    const TEST_N: usize = 8;\n\n    // Test helpers\n    mod test_utils {\n        use crate::relation::witness::Witness;\n\n        use super::*;\n\n        pub fn valid_witness(scheme: \u0026AjtaiScheme) -\u003e RqVector {\n            vec![Rq::new([scheme.witness_bound(); Rq::DEGREE]); TEST_N].into()\n        }\n\n        pub fn random_valid_witness() -\u003e Vec\u003cRqVector\u003e {\n            Witness::new(TEST_N, 1, Zq::new(10000)).s\n        }\n\n        pub fn setup_scheme() -\u003e AjtaiScheme {\n            let mut rng = rand::rng();\n            let random_matrix = RqMatrix::random(\u0026mut rng, TEST_M, TEST_N);\n            AjtaiScheme::new(Zq::ONE, random_matrix).unwrap()\n        }\n    }\n\n    #[test]\n    fn rejects_invalid_parameters() {\n        assert!(AjtaiScheme::new(\n            Zq::ZERO,\n            RqMatrix::new(vec![RqVector::new(vec![Rq::zero()])], false)\n        )\n        .is_err());\n        let _ = test_utils::setup_scheme(); // Will panic if setup fails\n    }\n\n    #[test]\n    fn initializes_with_correct_bounds() {\n        let scheme = test_utils::setup_scheme();\n        assert_eq!(scheme.witness_bound(), Zq::ONE);\n    }\n\n    #[test]\n    fn completes_commitment_cycle() {\n        let scheme = test_utils::setup_scheme();\n        let witness = test_utils::valid_witness(\u0026scheme);\n\n        let commitment = scheme.commit(\u0026witness).unwrap();\n        assert!(scheme.verify(\u0026commitment, \u0026witness).is_ok());\n\n        let mut bad_opening = witness.clone();\n        let mut rng = rand::rng();\n        bad_opening.set(0, Rq::random(\u0026mut rng));\n        assert!(scheme.verify(\u0026commitment, \u0026bad_opening).is_err());\n    }\n\n    #[test]\n    fn maintains_security_properties() {\n        let scheme = test_utils::setup_scheme();\n\n        // Use random witnesses to ensure they're different\n        let witness1 = test_utils::random_valid_witness();\n        let witness2 = test_utils::random_valid_witness();\n\n        // Ensure the witnesses are actually different\n        assert_ne!(witness1, witness2, \"Test requires different witnesses\");\n\n        let c1 = scheme.commit(\u0026witness1[0]).unwrap();\n        let c2 = scheme.commit(\u0026witness2[0]).unwrap();\n        assert_ne!(\n            c1, c2,\n            \"Different witnesses should produce different commitments\"\n        );\n    }\n\n    #[test]\n    fn handles_edge_cases() {\n        let scheme = test_utils::setup_scheme();\n        let zero_witness = RqVector::zero(TEST_N);\n\n        assert!(scheme.commit(\u0026zero_witness).is_ok());\n        assert!(scheme.commit(\u0026test_utils::valid_witness(\u0026scheme)).is_ok());\n    }\n\n    #[test]\n    fn stress_test() {\n        let scheme = test_utils::setup_scheme();\n\n        (0..100).for_each(|_| {\n            let witness = test_utils::valid_witness(\u0026scheme);\n            let commitment = scheme.commit(\u0026witness).unwrap();\n            assert!(scheme.verify(\u0026commitment, \u0026witness).is_ok());\n        });\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":19}},{"line":52,"address":[],"length":0,"stats":{"Line":19}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":18}},{"line":57,"address":[],"length":0,"stats":{"Line":18}},{"line":58,"address":[],"length":0,"stats":{"Line":18}},{"line":61,"address":[],"length":0,"stats":{"Line":18}},{"line":62,"address":[],"length":0,"stats":{"Line":18}},{"line":63,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":120}},{"line":69,"address":[],"length":0,"stats":{"Line":120}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":120}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":120}},{"line":76,"address":[],"length":0,"stats":{"Line":120}},{"line":80,"address":[],"length":0,"stats":{"Line":102}},{"line":85,"address":[],"length":0,"stats":{"Line":102}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":102}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":102}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":102}},{"line":96,"address":[],"length":0,"stats":{"Line":102}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":101}},{"line":104,"address":[],"length":0,"stats":{"Line":18}},{"line":105,"address":[],"length":0,"stats":{"Line":18}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":18}},{"line":123,"address":[],"length":0,"stats":{"Line":18}},{"line":125,"address":[],"length":0,"stats":{"Line":18}},{"line":128,"address":[],"length":0,"stats":{"Line":36}},{"line":131,"address":[],"length":0,"stats":{"Line":18}},{"line":134,"address":[],"length":0,"stats":{"Line":18}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":18}},{"line":141,"address":[],"length":0,"stats":{"Line":18}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":18}},{"line":155,"address":[],"length":0,"stats":{"Line":222}},{"line":157,"address":[],"length":0,"stats":{"Line":222}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":103}},{"line":170,"address":[],"length":0,"stats":{"Line":103}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}}],"covered":39,"coverable":50},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","commitments","common_instances.rs"],"content":"use rand::rng;\n\nuse crate::commitments::ajtai_commitment::AjtaiScheme;\nuse crate::relation::env_params::EnvironmentParameters;\nuse crate::ring::rq::Rq;\nuse crate::ring::rq_matrix::RqMatrix;\n\npub struct AjtaiInstances {\n    // A \\in R_q^(k*n)\n    pub commitment_scheme_a: AjtaiScheme,\n    // B_{ik} \\in R_q^(k_1*k), for i \\in [1,r] and k \\in [0, t_1-1]\n    pub commitment_scheme_b: AjtaiScheme,\n    // C_{ijk} \\in R_q^(k_2*1), for i \\in [1,r], j \\in [i, r], and k \\in [0, t_2-1]\n    pub commitment_scheme_c: AjtaiScheme,\n    // D_{ijk} \\in R_q^(k_2*1), for i \\in [1,r], j \\in [i, r], and k \\in [0, t_1-1]\n    pub commitment_scheme_d: AjtaiScheme,\n}\n\nimpl AjtaiInstances {\n    pub fn new(ep: \u0026EnvironmentParameters) -\u003e Self {\n        Self {\n            commitment_scheme_a: AjtaiScheme::new(\n                ep.beta,\n                Self::challenge_rq_matrix(ep.kappa, ep.rank),\n            )\n            .expect(\"Invalid Parameters for commitment scheme A\"),\n            commitment_scheme_b: AjtaiScheme::new(\n                ep.gamma_1,\n                Self::challenge_rq_matrix(ep.kappa_1, ep.multiplicity * ep.t_1 * ep.kappa),\n            )\n            .expect(\"Invalid Parameters for commitment scheme B\"),\n            // Todo: gamma_1 should be changed to a valid witness bound\n            commitment_scheme_c: AjtaiScheme::new(\n                ep.gamma_1,\n                Self::challenge_rq_matrix(\n                    ep.kappa_1,\n                    ep.t_2 * ((ep.multiplicity.pow(2)) + ep.multiplicity) / 2,\n                ),\n            )\n            .expect(\"Invalid Parameters for commitment scheme C\"),\n            commitment_scheme_d: AjtaiScheme::new(\n                ep.gamma_2,\n                Self::challenge_rq_matrix(\n                    ep.kappa_2,\n                    ep.t_1 * ((ep.multiplicity.pow(2)) + ep.multiplicity) / 2,\n                ),\n            )\n            .expect(\"Invalid Parameters for commitment scheme D\"),\n        }\n    }\n\n    fn challenge_rq_matrix(row: usize, col: usize) -\u003e RqMatrix {\n        (0..row)\n            .map(|_| (0..col).map(|_| Rq::random(\u0026mut rng())).collect())\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Instant;\n\n    #[test]\n    fn test_crs() {\n        // set up example environment parameters, use default set for testing.\n        let ep_1 = EnvironmentParameters::default();\n\n        let total_start = Instant::now();\n        // generate the common reference string matrices A, B, C, D\n        let _pp = AjtaiInstances::new(\u0026ep_1);\n\n        println!(\n            \"Total time for PublicPrams::new: {:?}\",\n            total_start.elapsed()\n        );\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":12}},{"line":58,"address":[],"length":0,"stats":{"Line":1278}}],"covered":8,"coverable":8},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","commitments","mod.rs"],"content":"pub mod ajtai_commitment;\npub mod common_instances;\npub mod outer_commitments;\npub use ajtai_commitment::CommitError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","commitments","outer_commitments.rs"],"content":"use thiserror::Error;\n\nuse crate::{\n    commitments::common_instances::AjtaiInstances,\n    ring::{rq_matrix::RqMatrix, rq_vector::RqVector, zq::Zq},\n};\n\nuse super::ajtai_commitment::AjtaiScheme;\n\n#[derive(Debug, Error)]\npub enum DecompositionError {\n    #[error(\"invalid decomposition base: {0}\")]\n    InvalidBase(Zq),\n    #[error(\"invalid number of parts: {0}\")]\n    InvalidPartCount(usize),\n}\n\n/// Parameters for polynomial decomposition in hierarchical commitments\n/// The base parameter controls how coefficients are decomposed\n/// The num_parts parameter determines how many parts each coefficient is split into\n#[derive(Debug, Clone)]\npub struct DecompositionParameters {\n    base: Zq,\n    num_parts: usize,\n}\n\nimpl DecompositionParameters {\n    /// Creates new decomposition parameters with validation\n    /// - base must be greater than 1 for meaningful decomposition\n    /// - num_parts must be positive to ensure decomposition occurs\n    pub fn new(base: Zq, num_parts: usize) -\u003e Result\u003cSelf, DecompositionError\u003e {\n        if base \u003c= Zq::ONE {\n            return Err(DecompositionError::InvalidBase(base));\n        }\n        if num_parts == 0 {\n            return Err(DecompositionError::InvalidPartCount(num_parts));\n        }\n\n        Ok(Self { base, num_parts })\n    }\n\n    /// Returns the decomposition base\n    pub fn base(\u0026self) -\u003e Zq {\n        self.base\n    }\n\n    /// Returns the number of decomposition parts\n    pub fn num_parts(\u0026self) -\u003e usize {\n        self.num_parts\n    }\n}\n\nfn decompose_and_commit(\n    commitment_matrix: \u0026AjtaiScheme,\n    input: \u0026RqMatrix,\n    params: \u0026DecompositionParameters,\n) -\u003e RqVector {\n    let decomposed_input = input.decompose_each_cell(params.base, params.num_parts);\n    commitment_matrix\n        .commit(\u0026decomposed_input)\n        .expect(\"Commitment error in committing to decomposed input\")\n}\n\npub fn compute_u1(\n    crs: \u0026AjtaiInstances,\n    t: \u0026RqMatrix,\n    t_decomposition_params: DecompositionParameters,\n    g: \u0026RqMatrix,\n    g_decomposition_params: DecompositionParameters,\n) -\u003e RqVector {\n    \u0026decompose_and_commit(\u0026crs.commitment_scheme_b, t, \u0026t_decomposition_params)\n        + \u0026decompose_and_commit(\u0026crs.commitment_scheme_c, g, \u0026g_decomposition_params)\n}\n\npub fn compute_u2(\n    crs: \u0026AjtaiInstances,\n    h: \u0026RqMatrix,\n    h_decomposition_params: DecompositionParameters,\n) -\u003e RqVector {\n    decompose_and_commit(\u0026crs.commitment_scheme_d, h, \u0026h_decomposition_params)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_decomposition_parameters() {\n        assert!(DecompositionParameters::new(Zq::ZERO, 2).is_err());\n        assert!(DecompositionParameters::new(Zq::TWO, 0).is_err());\n        let params = DecompositionParameters::new(Zq::new(8), 3).unwrap();\n        assert_eq!(params.base(), Zq::new(8));\n        assert_eq!(params.num_parts(), 3);\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":30,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":11}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":3}}],"covered":34,"coverable":34},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","aggregate.rs"],"content":"use crate::relation::env_params::EnvironmentParameters;\nuse crate::ring::rq::Rq;\nuse crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\n\nuse super::inner_product;\n\n/// This struct serves as aggregation of functions with constant value 0.\npub struct ZeroConstantFunctionsAggregation\u003c'a\u003e {\n    ep: \u0026'a EnvironmentParameters,\n    a_double_prime: Vec\u003cRqMatrix\u003e,\n    phi_double_prime: Vec\u003cVec\u003cRqVector\u003e\u003e,\n}\n\nimpl\u003c'a\u003e ZeroConstantFunctionsAggregation\u003c'a\u003e {\n    pub fn new(parameters: \u0026'a EnvironmentParameters) -\u003e Self {\n        Self {\n            ep: parameters,\n            a_double_prime: vec![\n                RqMatrix::symmetric_zero(parameters.multiplicity);\n                parameters.const_agg_length\n            ],\n            phi_double_prime: vec![\n                vec![RqVector::zero(parameters.rank); parameters.multiplicity];\n                parameters.const_agg_length\n            ],\n        }\n    }\n\n    /// Calculate a_double_primes from a_prime, a_{i,j}^{''k} = \\sum_{l=1}^{L}\\psi_l^{k}a_{ij}^{'(l)}\n    ///\n    /// @param: vector_psi: \\psi_l^k\n    /// @param: a_prime: a_{ij}^{'(l)}, each a_{ij} is a ring element (PolyRing)\n    ///\n    /// @return: a_{ij}^{''(k)}, return a vector length k of matrix a_{ij}^{''}\n    pub fn calculate_agg_a_double_prime(\u0026mut self, vector_psi: \u0026[Vec\u003cZq\u003e], a_prime: \u0026[RqMatrix]) {\n        for i in 0..self.ep.multiplicity {\n            for j in 0..i + 1 {\n                let a_prime_l_vector: Vec\u003c\u0026Rq\u003e =\n                    a_prime.iter().map(|matrix| matrix.get_cell(i, j)).collect();\n\n                for (k, matrix) in self.a_double_prime.iter_mut().enumerate() {\n                    matrix.set_sell(\n                        i,\n                        j,\n                        inner_product::compute_linear_combination(\n                            \u0026a_prime_l_vector,\n                            \u0026vector_psi[k],\n                        ),\n                    );\n                }\n            }\n        }\n    }\n\n    /// calculate \\phi_{i}^{''(k)} = \\sum_{l=1}^{L}\\psi_l^{k}\\phi_{i}^{'(l)} + \\sum(\\omega_j^{k} * \\sigma_{-1} * pi_i^{j})\n    /// in the prover process, page 17 from the paper.\n    ///\n    /// @param: phi_ct: \\phi_{i}^{'(l)}\n    /// @param: pi: pi_i^{j}\n    /// @param: random_psi: \\psi_l^{k}\n    /// @param: random_omega: \\omega_j^{k}\n    ///\n    /// return: \\phi_{i}^{''(k)}\n    pub fn calculate_agg_phi_double_prime(\n        \u0026mut self,\n        phi_prime: \u0026[Vec\u003cRqVector\u003e],\n        conjugated_pi: \u0026[RqMatrix],\n        vector_psi: \u0026[Vec\u003cZq\u003e],\n        vector_omega: \u0026[Vec\u003cZq\u003e],\n    ) {\n        for i in 0..self.ep.multiplicity {\n            let phi_prime_l_vector: Vec\u003c\u0026RqVector\u003e =\n                phi_prime.iter().map(|elems| \u0026elems[i]).collect();\n            for (k, phi_k) in self.phi_double_prime.iter_mut().enumerate() {\n                phi_k[i] =\n                    inner_product::compute_linear_combination(\u0026phi_prime_l_vector, \u0026vector_psi[k]);\n            }\n        }\n\n        for (i, pi_i) in conjugated_pi.iter().enumerate() {\n            for (k, phi_k) in self.phi_double_prime.iter_mut().enumerate() {\n                phi_k[i] = \u0026phi_k[i]\n                    + \u0026inner_product::compute_linear_combination(\n                        pi_i.get_elements(),\n                        \u0026vector_omega[k],\n                    );\n            }\n        }\n    }\n\n    /// calculate b^{''(k)} = \\sum_{i,j=1}^{r} a_{ij}^{''(k)} * \u003cs_i, s_j\u003e + \\sum_{i=1}^{r} \u003c\\phi_{i}^{''(k)} * s_i\u003e\n    ///\n    /// @param: a_ct_aggr: a_{ij}^{''(k)}\n    /// @param: phi_ct_aggr: \\phi_{i}^{''(k)}\n    /// @param: witness: s_i\n    ///\n    /// @return: b^{''(k)}\n    pub fn calculate_agg_b_double_prime(\u0026mut self, witness: \u0026[RqVector]) -\u003e RqVector {\n        (0..self.ep.kappa)\n            .map(|k| {\n                (0..self.ep.multiplicity)\n                    .map(|i| {\n                        \u0026(0..self.ep.multiplicity).map(|j| {\n                    // calculate a_{ij}^{''(k)} * \u003cs_i, s_j\u003e\n                    self.a_double_prime[k].get_cell(i, j)\n                        * \u0026inner_product::compute_linear_combination(witness[i].get_elements(), witness[j].get_elements())\n                })\n                .fold(\n                    // sum over all i,j\n                    Rq::zero(),\n                    |acc, val| \u0026acc + \u0026val,\n                )\n                // add \\phi_{i}^{''(k)} * s[i]\n                + \u0026inner_product::compute_linear_combination(self.phi_double_prime[k][i].get_elements(), witness[i].get_elements())\n                    }) // sum over all i,j\n                    .fold(Rq::zero(), |acc, val| \u0026acc + \u0026val)\n            })\n            .collect()\n    }\n\n    pub fn get_alpha_double_prime(\u0026self) -\u003e \u0026[RqMatrix] {\n        \u0026self.a_double_prime\n    }\n\n    pub fn get_phi_double_prime(\u0026self) -\u003e \u0026[Vec\u003cRqVector\u003e] {\n        \u0026self.phi_double_prime\n    }\n}\n\npub struct FunctionsAggregation\u003c'a\u003e {\n    ep: \u0026'a EnvironmentParameters,\n    aggregated_a: RqMatrix,\n    aggregated_phi: Vec\u003cRqVector\u003e,\n    aggregated_b: Rq,\n}\n\nimpl\u003c'a\u003e FunctionsAggregation\u003c'a\u003e {\n    pub fn new(parameters: \u0026'a EnvironmentParameters) -\u003e Self {\n        Self {\n            ep: parameters,\n            aggregated_a: RqMatrix::symmetric_zero(parameters.multiplicity),\n            aggregated_phi: vec![RqVector::zero(parameters.rank); parameters.multiplicity],\n            aggregated_b: Rq::zero(),\n        }\n    }\n\n    /// calculate a_i = \\sum(alpha_k * a_{ij}) + \\sum(beta_k * a_{ij}^{''(k)})\n    /// equation 5, in the verifier process, page 18 from the paper.\n    ///\n    /// @param: a_constraint: a_{ij}\n    /// @param: a_ct_aggr: a_{ij}^{''(k)}\n    /// @param: random_alpha: alpha_k\n    /// @param: random_beta: beta_k\n    /// @param: ep: struct SizeParams\n    ///\n    /// @return: a_i\n    pub fn calculate_agg_a(\n        \u0026mut self,\n        a_constraint: \u0026[RqMatrix],\n        a_double_prime: \u0026[RqMatrix],\n        vector_alpha: \u0026RqVector,\n        vector_beta: \u0026RqVector,\n    ) {\n        for i in 0..self.ep.multiplicity {\n            for j in 0..i + 1 {\n                let a_constraint_k: Vec\u003c\u0026Rq\u003e = a_constraint\n                    .iter()\n                    .map(|matrix| matrix.get_cell(i, j))\n                    .collect();\n                let a_double_prime_k: Vec\u003c\u0026Rq\u003e = a_double_prime\n                    .iter()\n                    .map(|matrix| matrix.get_cell(i, j))\n                    .collect();\n                self.aggregated_a.set_sell(\n                    i,\n                    j,\n                    \u0026inner_product::compute_linear_combination::\u003c\u0026Rq, Rq, Rq\u003e(\n                        \u0026a_constraint_k,\n                        vector_alpha.get_elements(),\n                    ) + \u0026inner_product::compute_linear_combination(\n                        \u0026a_double_prime_k,\n                        vector_beta.get_elements(),\n                    ),\n                );\n            }\n        }\n    }\n\n    /// calculate phi_i = \\sum(alpha_k * \\phi_{i}^{k}) + \\sum(beta_k * \\phi_{i}^{''(k)})\n    /// equation 6, in the verifier process, page 18 from the paper.\n    ///\n    /// param: phi_constraint: \\phi_{i}^{k}\n    /// param: phi_ct_aggr: \\phi_{i}^{''(k)}\n    /// param: random_alpha: alpha_k\n    /// param: random_beta: beta_k\n    /// param: ep: struct SizeParams\n    ///\n    /// return: phi_i\n    pub fn calculate_aggr_phi(\n        \u0026mut self,\n        phi_constraint: \u0026[Vec\u003cRqVector\u003e],\n        phi_double_prime: \u0026[Vec\u003cRqVector\u003e],\n        vector_alpha: \u0026RqVector,\n        vector_beta: \u0026RqVector,\n    ) {\n        for i in 0..self.ep.multiplicity {\n            let phi_constraint_k: Vec\u003c\u0026RqVector\u003e =\n                phi_constraint.iter().map(|element| \u0026element[i]).collect();\n            let phi_double_prime_k: Vec\u003c\u0026RqVector\u003e =\n                phi_double_prime.iter().map(|element| \u0026element[i]).collect();\n            self.aggregated_phi[i] =\n                \u0026inner_product::compute_linear_combination::\u003c\u0026RqVector, RqVector, Rq\u003e(\n                    \u0026phi_constraint_k,\n                    vector_alpha.get_elements(),\n                ) + \u0026inner_product::compute_linear_combination(\n                    \u0026phi_double_prime_k,\n                    vector_beta.get_elements(),\n                );\n        }\n    }\n\n    /// calculate b_i = \\sum(alpha_k * b^{k}) + \\sum(beta_k * b^{''(k})\n    /// equation 7, in the verifier process, page 18 from the paper.\n    ///\n    /// @param: b_constraint: b^{k}\n    /// @param: b_ct_aggr: b^{''(k)}\n    /// @param: random_alpha: alpha_k\n    /// @param: random_beta: beta_k\n    /// @param: ep: struct SizeParams\n    ///\n    /// @return: b_i\n    pub fn calculate_aggr_b(\n        \u0026mut self,\n        b_constraint: \u0026RqVector,\n        b_double_prime: \u0026RqVector,\n        vector_alpha: \u0026RqVector,\n        vector_beta: \u0026RqVector,\n    ) {\n        self.aggregated_b = \u0026inner_product::compute_linear_combination(\n            b_constraint.get_elements(),\n            vector_alpha.get_elements(),\n        ) + \u0026inner_product::compute_linear_combination(\n            b_double_prime.get_elements(),\n            vector_beta.get_elements(),\n        )\n    }\n\n    pub fn get_agg_a(\u0026self) -\u003e \u0026RqMatrix {\n        \u0026self.aggregated_a\n    }\n\n    pub fn get_appr_phi(\u0026self) -\u003e \u0026[RqVector] {\n        \u0026self.aggregated_phi\n    }\n\n    pub fn get_aggr_b(\u0026self) -\u003e \u0026Rq {\n        \u0026self.aggregated_b\n    }\n}\n\n// #[cfg(test)]\n// mod tests {\n//     use super::*;\n//     use crate::prover::Challenges;\n//     use crate::verifier::LabradorVerifier;\n//     #[test]\n//     fn test_check_relation_full() {\n//         // set up example environment, use set1 for testing.\n//         let ep = EnvironmentParameters::default();\n//         // generate a random witness based on ep above\n//         let witness_1 = Witness::new(\u0026ep);\n//         // generate public statements based on witness_1\n//         let st = Statement::new(\u0026witness_1, \u0026ep);\n//         // generate random challenges\n//         let tr = Challenges::new(\u0026ep);\n//         // first aggregation\n//         let aggr_1 = AggregationOne::new(\u0026witness_1, \u0026st, \u0026ep, \u0026tr);\n//         // second aggregation\n//         let aggr_2 = AggregationTwo::new(\u0026aggr_1, \u0026st, \u0026ep, \u0026tr);\n\n//         // calculate garbage polynomial g_{ij} = \u003cs_i, s_j\u003e\n//         let g = (0..ep.multiplicity)\n//             .map(|i| {\n//                 (0..ep.multiplicity)\n//                     .map(|j| witness_1.s[i].inner_product_poly_vector(\u0026witness_1.s[j]))\n//                     .collect()\n//             })\n//             .collect();\n\n//         // calculate h_{ii}\n//         let h = (0..ep.multiplicity)\n//             .map(|i| {\n//                 (0..ep.multiplicity)\n//                     .map(|j| {\n//                         let inner_phii_sj =\n//                             aggr_2.phi_i[i].inner_product_poly_vector(\u0026witness_1.s[j]);\n//                         let inner_phij_si =\n//                             aggr_2.phi_i[j].inner_product_poly_vector(\u0026witness_1.s[i]);\n//                         \u0026inner_phii_sj + \u0026inner_phij_si\n//                     })\n//                     .collect()\n//             })\n//             .collect();\n\n//         // check aggregation relation\n//         let relation = LabradorVerifier::check_relation(\u0026aggr_2.a_i, \u0026aggr_2.b_i, \u0026g, \u0026h);\n\n//         assert!(relation);\n//     }\n// }\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":24,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":3}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":18}},{"line":42,"address":[],"length":0,"stats":{"Line":90}},{"line":44,"address":[],"length":0,"stats":{"Line":72}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":45}},{"line":78,"address":[],"length":0,"stats":{"Line":36}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":85,"address":[],"length":0,"stats":{"Line":36}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":10}},{"line":105,"address":[],"length":0,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":32}},{"line":107,"address":[],"length":0,"stats":{"Line":96}},{"line":109,"address":[],"length":0,"stats":{"Line":72}},{"line":110,"address":[],"length":0,"stats":{"Line":72}},{"line":112,"address":[],"length":0,"stats":{"Line":24}},{"line":114,"address":[],"length":0,"stats":{"Line":24}},{"line":115,"address":[],"length":0,"stats":{"Line":120}},{"line":118,"address":[],"length":0,"stats":{"Line":24}},{"line":119,"address":[],"length":0,"stats":{"Line":32}},{"line":120,"address":[],"length":0,"stats":{"Line":40}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":3}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":4}},{"line":171,"address":[],"length":0,"stats":{"Line":6}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":30}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":24}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":3}},{"line":215,"address":[],"length":0,"stats":{"Line":3}},{"line":217,"address":[],"length":0,"stats":{"Line":12}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":45}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":36}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":3}},{"line":264,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":1}}],"covered":64,"coverable":103},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","garbage_polynomials.rs"],"content":"use crate::ring::{rq_matrix::RqMatrix, rq_vector::RqVector};\n\nuse super::inner_product;\n\n/// Calculate the garbage polynomials g_{ij} = \u003cs_i, s_j\u003e\n/// Exploits symmetry by only calculating for i ≤ j since g_{ij} = g_{ji}\npub fn compute_g(witness_vector: \u0026[RqVector]) -\u003e RqMatrix {\n    let mut g_i = Vec::new();\n    for i in 0..witness_vector.len() {\n        let mut g_ij = Vec::new();\n        for j in 0..=i {\n            // Only calculate for j ≤ i (upper triangular)\n            g_ij.push(inner_product::compute_linear_combination(\n                witness_vector[i].get_elements(),\n                witness_vector[j].get_elements(),\n            ));\n        }\n        g_i.push(RqVector::new(g_ij));\n    }\n    RqMatrix::new(g_i, true)\n}\n\n/// Calculate the h_{ij} = \u003cφ_i, s_j\u003e + \u003cφ_j, s_i\u003e garbage polynomials\n/// In the paper, h_{ij} is defined with a factor of 1/2 in front\n/// However, since we're using q = 2^32, division by 2 is problematic in Z_q\n/// So we store h'_{ij} = 2*h_{ij} = \u003cφ_i, s_j\u003e + \u003cφ_j, s_i\u003e directly\n/// Exploits symmetry by only calculating for i ≤ j since h_{ij} = h_{ji}\npub fn compute_h(witness_vector: \u0026[RqVector], phi: \u0026[RqVector]) -\u003e RqMatrix {\n    let r = witness_vector.len();\n    let mut h_i = Vec::with_capacity((r * (r + 1)) / 2);\n\n    for i in 0..r {\n        let mut h_ij = Vec::new();\n        for j in 0..=i {\n            // Only calculate for j ≤ i (upper triangular)\n            let inner_phi_i_s_j = inner_product::compute_linear_combination(\n                phi[i].get_elements(),\n                witness_vector[j].get_elements(),\n            );\n            let inner_phi_j_s_i = inner_product::compute_linear_combination(\n                phi[j].get_elements(),\n                witness_vector[i].get_elements(),\n            );\n            h_ij.push(\u0026inner_phi_i_s_j + \u0026inner_phi_j_s_i);\n        }\n        h_i.push(RqVector::new(h_ij));\n    }\n    RqMatrix::new(h_i, true)\n}\n\n// Todo: Revise and complete the following\n// Implementation of the final level optimization (Section 5.6)\n// /// Uses sequentially derived challenges via Fiat-Shamir to simulate the interactive protocol\n// pub fn optimize_final_level(\n//     witnesses: \u0026[PolyVector],\n//     phi: \u0026[PolyVector],\n//     initial_seed: u64,\n// ) -\u003e (PolyRing, Vec\u003cPolyRing\u003e, Vec\u003cPolyRing\u003e) {\n//     let r = witnesses.len();\n\n//     // Calculate g_0 = Σ_i \u003cs_i, s_i\u003e (diagonal sum)\n//     let g0 = (0..r)\n//         .map(|i| witnesses[i].inner_product_poly_vector(\u0026witnesses[i]))\n//         .fold(\n//             PolyRing::zero(witnesses[0].get_elements()[0].len()),\n//             |acc, g| \u0026acc + \u0026g,\n//         );\n\n//     // Generate sequence of challenges using Fiat-Shamir\n//     let mut challenges = Vec::with_capacity(r / 2);\n//     let mut hasher = DefaultHasher::new();\n//     initial_seed.hash(\u0026mut hasher);\n//     let mut current_seed = hasher.finish();\n\n//     for _ in 0..r / 2 {\n//         let mut rng = rand::rngs::StdRng::seed_from_u64(current_seed);\n//         let challenge = PolyRing::random(\u0026mut rng, witnesses[0].get_elements()[0].len());\n//         challenges.push(challenge);\n\n//         // Update seed for next challenge\n//         let mut hasher = DefaultHasher::new();\n//         current_seed.hash(\u0026mut hasher);\n//         current_seed = hasher.finish();\n//     }\n\n//     // Calculate selected g terms: g_{2i-1} and g_{2i}\n//     let mut g_terms = Vec::new();\n//     for i in 1..=r / 2 {\n//         let idx1 = 2 * i - 2;\n//         let idx2 = 2 * i - 1;\n\n//         // Use unique challenge for each i\n//         let challenge = \u0026challenges[i - 1];\n\n//         // Add g_{2i-1}\n//         if idx2 \u003c r {\n//             // For g_{2i-1} = \u003cs_{2i-2}, c_i * s_{2i-1}\u003e\n//             let s_j_scaled = witnesses[idx2]\n//                 .iter()\n//                 .map(|p| p * challenge)\n//                 .collect::\u003cPolyVector\u003e();\n\n//             let g_2i_1 = witnesses[idx1].inner_product_poly_vector(\u0026s_j_scaled);\n//             g_terms.push(g_2i_1);\n\n//             // Add g_{2i} if we have enough witnesses\n//             if 2 * i \u003c r {\n//                 // For g_{2i} = \u003cs_{2i-1}, c_i * s_{2i}\u003e\n//                 let s_j_scaled = witnesses[2 * i]\n//                     .iter()\n//                     .map(|p| p * challenge)\n//                     .collect::\u003cPolyVector\u003e();\n\n//                 let g_2i = witnesses[idx2].inner_product_poly_vector(\u0026s_j_scaled);\n//                 g_terms.push(g_2i);\n//             }\n//         }\n//     }\n\n//     // Calculate selected h terms: h_{2i-1} and h_{2i}\n//     let mut h_terms = Vec::new();\n//     for i in 1..=r / 2 {\n//         let idx1 = 2 * i - 2;\n//         let idx2 = 2 * i - 1;\n\n//         // Use unique challenge for each i\n//         let challenge = \u0026challenges[i - 1];\n\n//         // Add h_{2i-1}\n//         if idx2 \u003c r {\n//             // For h_{2i-1} = \u003cφ_{2i-2}, c_i * s_{2i-1}\u003e + \u003cφ_{2i-1}, c_i * s_{2i-2}\u003e\n//             let s_j_scaled = witnesses[idx2]\n//                 .iter()\n//                 .map(|p| p * challenge)\n//                 .collect::\u003cPolyVector\u003e();\n\n//             let phi_i_s_j = phi[idx1].inner_product_poly_vector(\u0026s_j_scaled);\n\n//             let s_i_scaled = witnesses[idx1]\n//                 .iter()\n//                 .map(|p| p * challenge)\n//                 .collect::\u003cPolyVector\u003e();\n\n//             let phi_j_s_i = phi[idx2].inner_product_poly_vector(\u0026s_i_scaled);\n\n//             let h_2i_1 = \u0026phi_i_s_j + \u0026phi_j_s_i;\n//             h_terms.push(h_2i_1);\n\n//             // Add h_{2i} if we have enough witnesses\n//             if 2 * i \u003c r {\n//                 // For h_{2i} = \u003cφ_{2i-1}, c_i * s_{2i}\u003e + \u003cφ_{2i}, c_i * s_{2i-1}\u003e\n//                 let s_j_scaled = witnesses[2 * i]\n//                     .iter()\n//                     .map(|p| p * challenge)\n//                     .collect::\u003cPolyVector\u003e();\n\n//                 let phi_i_s_j = phi[idx2].inner_product_poly_vector(\u0026s_j_scaled);\n\n//                 let s_i_scaled = witnesses[idx2]\n//                     .iter()\n//                     .map(|p| p * challenge)\n//                     .collect::\u003cPolyVector\u003e();\n\n//                 let phi_j_s_i = phi[2 * i].inner_product_poly_vector(\u0026s_i_scaled);\n\n//                 let h_2i = \u0026phi_i_s_j + \u0026phi_j_s_i;\n//                 h_terms.push(h_2i);\n//             }\n//         }\n//     }\n\n//     (g0, g_terms, h_terms)\n// }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand::rng;\n\n    const RANK: usize = 8;\n\n    fn create_test_witnesses(count: usize) -\u003e (Vec\u003cRqVector\u003e, Vec\u003cRqVector\u003e) {\n        let witnesses = (0..count)\n            .map(|_| RqVector::random(\u0026mut rng(), RANK))\n            .collect();\n\n        let phi = (0..count)\n            .map(|_| RqVector::random(\u0026mut rng(), RANK))\n            .collect();\n\n        (witnesses, phi)\n    }\n\n    #[test]\n    fn test_g_matrix_size() {\n        let multiplicity = 3;\n        let (witnesses, _) = create_test_witnesses(multiplicity);\n        let g = compute_g(\u0026witnesses);\n\n        assert_eq!(g.get_row_len(), 3);\n        // Assert that g stores half of the matrix\n        for row in 0..multiplicity {\n            assert_eq!(g.get_elements()[row].get_length(), row + 1);\n        }\n    }\n\n    #[test]\n    fn test_g_calculation() {\n        let (witnesses, _) = create_test_witnesses(3);\n\n        let g = compute_g(\u0026witnesses);\n\n        // Verify a few specific values\n        let expected_g_01 = inner_product::compute_linear_combination(\n            witnesses[0].get_elements(),\n            witnesses[1].get_elements(),\n        );\n        let expected_g_10 = inner_product::compute_linear_combination(\n            witnesses[1].get_elements(),\n            witnesses[0].get_elements(),\n        );\n        assert_eq!(expected_g_01, expected_g_10);\n\n        let expected_g_22 = inner_product::compute_linear_combination(\n            witnesses[2].get_elements(),\n            witnesses[2].get_elements(),\n        );\n\n        assert_eq!(*g.get_cell(0, 1), expected_g_01);\n        assert_eq!(*g.get_cell(1, 0), expected_g_10);\n        assert_eq!(*g.get_cell(2, 2), expected_g_22);\n    }\n\n    #[test]\n    fn test_h_matrix_size() {\n        let multiplicity = 3;\n        let (witnesses, phi) = create_test_witnesses(multiplicity);\n        let h = compute_h(\u0026witnesses, \u0026phi);\n\n        assert_eq!(h.get_row_len(), 3);\n        // Assert that g stores half of the matrix\n        for row in 0..multiplicity {\n            assert_eq!(h.get_elements()[row].get_length(), row + 1);\n        }\n    }\n\n    #[test]\n    fn test_h_calculation() {\n        let (witnesses, phi) = create_test_witnesses(3);\n        let h = compute_h(\u0026witnesses, \u0026phi);\n\n        // Verify a specific value\n        let phi_0_s_1 = inner_product::compute_linear_combination(\n            phi[0].get_elements(),\n            witnesses[1].get_elements(),\n        );\n        let phi_1_s_0 = inner_product::compute_linear_combination(\n            phi[1].get_elements(),\n            witnesses[0].get_elements(),\n        );\n        let expected_h_01 = \u0026phi_0_s_1 + \u0026phi_1_s_0;\n\n        assert_eq!(h.get_cell(0, 1), h.get_cell(1, 0));\n        assert_eq!(expected_h_01, *h.get_cell(0, 1));\n    }\n\n    // #[test]\n    // fn test_commit_recursive() {\n    //     let commitment_scheme = create_test_commitment();\n    //     let (witnesses, phi) = create_test_witnesses(3);\n\n    //     // Create mock inner commitment parts (t and z)\n    //     let t_parts = create_test_parts(5);\n    //     let z_parts = create_test_parts(5);\n\n    //     let (recursive_commitment, recursive_witness) = commitment_scheme\n    //         .commit_recursive(\u0026witnesses, \u0026phi, \u0026t_parts, \u0026z_parts)\n    //         .unwrap();\n\n    //     // Check the output structure\n    //     assert!(!recursive_commitment.nu1.as_slice().is_empty());\n    //     assert!(!recursive_commitment.nu2.as_slice().is_empty());\n\n    //     // Check witness has appropriate parts\n    //     assert_eq!(recursive_witness.t_parts.len(), t_parts.len());\n    //     assert_eq!(recursive_witness.z_parts.len(), z_parts.len());\n    //     assert!(!recursive_witness.g_parts.is_empty());\n    //     assert!(!recursive_witness.h_parts.is_empty());\n    // }\n\n    // #[test]\n    // fn test_commit_recursive_correctness() {\n    //     let commitment_scheme = create_test_commitment();\n    //     let (witnesses, phi) = create_test_witnesses(3);\n\n    //     // Create test parts for inner commitment\n    //     let t_parts = create_test_parts(5);\n    //     let z_parts = create_test_parts(5);\n\n    //     // Get the recursive commitment and witness\n    //     let (recursive_commitment, recursive_witness) = commitment_scheme\n    //         .commit_recursive(\u0026witnesses, \u0026phi, \u0026t_parts, \u0026z_parts)\n    //         .unwrap();\n\n    //     // Manually compute the expected commitments:\n\n    //     // 1. For nu1, combine t_parts and g_parts\n    //     let mut combined_parts = recursive_witness.t_parts.clone();\n    //     combined_parts.extend(recursive_witness.g_parts.clone());\n\n    //     // 2. Create expected witnesses\n    //     let expected_nu1_witness = commitment_scheme.create_witness_from_parts(\u0026combined_parts);\n    //     let expected_nu2_witness =\n    //         commitment_scheme.create_witness_from_parts(\u0026recursive_witness.h_parts);\n\n    //     // 3. Create AjtaiCommitment instances with the correct matrices\n    //     let nu1_commitment = AjtaiCommitment::new(\n    //         commitment_scheme.params.clone(),\n    //         commitment_scheme.nu1_matrix.clone(),\n    //     )\n    //     .unwrap();\n\n    //     let nu2_commitment = AjtaiCommitment::new(\n    //         commitment_scheme.params.clone(),\n    //         commitment_scheme.nu2_matrix.clone(),\n    //     )\n    //     .unwrap();\n\n    //     // 4. Compute expected commitments\n    //     let (expected_nu1, _) = nu1_commitment.commit(expected_nu1_witness).unwrap();\n    //     let (expected_nu2, _) = nu2_commitment.commit(expected_nu2_witness).unwrap();\n\n    //     // 5. Compare expected with actual\n    //     assert_eq!(\n    //         recursive_commitment.nu1, expected_nu1,\n    //         \"nu1 commitment does not match expected value\"\n    //     );\n    //     assert_eq!(\n    //         recursive_commitment.nu2, expected_nu2,\n    //         \"nu2 commitment does not match expected value\"\n    //     );\n    // }\n\n    // #[test]\n    // fn test_decomposition_reconstruction() {\n    //     let commitment_scheme = create_test_commitment();\n    //     let mut rng = rand::rng();\n\n    //     // Create a random polynomial\n    //     let original_poly = PolyRing::random(\u0026mut rng, TEST_D);\n    //     let original_rq: Rq\u003cTEST_D\u003e = original_poly.clone().into();\n\n    //     // Test g decomposition parameters\n    //     let g_parts = commitment_scheme.decompose_polynomial(\u0026original_poly, true);\n    //     let g_base = commitment_scheme.g_decomp_params.base();\n\n    //     // Reconstruct the polynomial from parts\n    //     let mut reconstructed_g = Rq::\u003cTEST_D\u003e::zero();\n    //     let mut current_base_power = Zq::ONE; // Base^0\n\n    //     for part in \u0026g_parts {\n    //         // Add part * base^k\n    //         reconstructed_g = reconstructed_g.clone() + part.clone().scalar_mul(current_base_power);\n    //         // Multiply by base for next iteration\n    //         current_base_power *= g_base;\n    //     }\n\n    //     assert_eq!(\n    //         reconstructed_g, original_rq,\n    //         \"G decomposition reconstruction failed\"\n    //     );\n\n    //     // Test h decomposition parameters\n    //     let h_parts = commitment_scheme.decompose_polynomial(\u0026original_poly, false);\n    //     let h_base = commitment_scheme.h_decomp_params.base();\n\n    //     // Reconstruct the polynomial from parts\n    //     let mut reconstructed_h = Rq::\u003cTEST_D\u003e::zero();\n    //     let mut current_base_power = Zq::ONE; // Base^0\n\n    //     for part in \u0026h_parts {\n    //         // Add part * base^k\n    //         reconstructed_h = reconstructed_h.clone() + part.clone().scalar_mul(current_base_power);\n    //         // Multiply by base for next iteration\n    //         current_base_power *= h_base;\n    //     }\n\n    //     assert_eq!(\n    //         reconstructed_h, original_rq,\n    //         \"H decomposition reconstruction failed\"\n    //     );\n    // }\n\n    // #[test]\n    // fn test_create_witness_from_parts_edge_cases() {\n    //     let commitment_scheme = create_test_commitment();\n    //     let mut rng = rand::rng();\n\n    //     // Test case 1: parts.len() \u003c N (should pad with zeros)\n    //     let few_parts: Vec\u003cRq\u003cTEST_D\u003e\u003e = (0..TEST_N - 2)\n    //         .map(|_| Rq::\u003cTEST_D\u003e::random(\u0026mut rng))\n    //         .collect();\n\n    //     let witness_few = commitment_scheme.create_witness_from_parts(\u0026few_parts);\n\n    //     // Check length is exactly N\n    //     assert_eq!(witness_few.as_slice().len(), TEST_N);\n\n    //     // Check that last elements are zero\n    //     for i in few_parts.len()..TEST_N {\n    //         assert_eq!(witness_few[i], Rq::\u003cTEST_D\u003e::zero());\n    //     }\n\n    //     // Check original parts are preserved (with possible bounding applied)\n    //     let witness_bound = commitment_scheme.params.witness_bound();\n    //     for (i, part) in few_parts.iter().enumerate() {\n    //         let mut bounded_part_coeffs = [Zq::ZERO; TEST_D];\n    //         for (j, coeff) in part.get_coefficients().iter().enumerate().take(TEST_D) {\n    //             bounded_part_coeffs[j] = coeff.centered_mod(witness_bound);\n    //         }\n    //         let bounded_part = Rq::\u003cTEST_D\u003e::new(bounded_part_coeffs);\n    //         assert_eq!(witness_few[i], bounded_part);\n    //     }\n\n    //     // Test case 2: parts.len() \u003e N (should truncate to first N)\n    //     let many_parts: Vec\u003cRq\u003cTEST_D\u003e\u003e = (0..TEST_N + 3)\n    //         .map(|_| Rq::\u003cTEST_D\u003e::random(\u0026mut rng))\n    //         .collect();\n\n    //     let witness_many = commitment_scheme.create_witness_from_parts(\u0026many_parts);\n\n    //     // Check length is exactly N\n    //     assert_eq!(witness_many.as_slice().len(), TEST_N);\n\n    //     // Check only first N parts are included (with possible bounding applied)\n    //     let witness_bound = commitment_scheme.params.witness_bound();\n    //     for i in 0..TEST_N {\n    //         let mut bounded_part_coeffs = [Zq::ZERO; TEST_D];\n    //         for (j, coeff) in many_parts[i]\n    //             .get_coefficients()\n    //             .iter()\n    //             .enumerate()\n    //             .take(TEST_D)\n    //         {\n    //             bounded_part_coeffs[j] = coeff.centered_mod(witness_bound);\n    //         }\n    //         let bounded_part = Rq::\u003cTEST_D\u003e::new(bounded_part_coeffs);\n    //         assert_eq!(witness_many[i], bounded_part);\n    //     }\n\n    //     // Test case 3: Coefficient bounding\n    //     // Create parts with large coefficients\n    //     let large_coeff_parts: Vec\u003cRq\u003cTEST_D\u003e\u003e = (0..TEST_N)\n    //         .map(|_| {\n    //             let mut large_part = Rq::\u003cTEST_D\u003e::random(\u0026mut rng);\n    //             // Set first coefficient to a large value beyond the witness bound\n    //             if let Some(c) = large_part.iter_mut().next() {\n    //                 *c = Zq::MAX - Zq::ONE;\n    //             }\n    //             large_part\n    //         })\n    //         .collect();\n\n    //     let witness_large = commitment_scheme.create_witness_from_parts(\u0026large_coeff_parts);\n\n    //     // Check coefficients are properly bounded\n    //     for i in 0..TEST_N {\n    //         let mut bounded_part_coeffs = [Zq::ZERO; TEST_D];\n    //         for (j, coeff) in large_coeff_parts[i]\n    //             .get_coefficients()\n    //             .iter()\n    //             .enumerate()\n    //             .take(TEST_D)\n    //         {\n    //             bounded_part_coeffs[j] = coeff.centered_mod(witness_bound);\n    //         }\n    //         let bounded_part = Rq::\u003cTEST_D\u003e::new(bounded_part_coeffs);\n\n    //         assert_eq!(witness_large[i], bounded_part);\n\n    //         // Also check that large coefficients were properly bounded\n    //         for (j, coeff) in witness_large[i].get_coefficients().iter().enumerate() {\n    //             let original_coeff = large_coeff_parts[i].get_coefficients()[j];\n    //             if original_coeff \u003e witness_bound {\n    //                 assert!(*coeff \u003c= witness_bound);\n    //             }\n    //         }\n    //     }\n    // }\n\n    // #[test]\n    // #[allow(clippy::as_conversions)]\n    // fn test_optimal_parameters_accuracy() {\n    //     // Choose small, simple values for manual calculation\n    //     let n = 4; // Small dimension\n    //     let d = 4; // Small degree\n    //     let s = 2.0; // Simple standard deviation\n    //     let beta = 1.0; // Simple beta value\n\n    //     // Manually calculate the expected values according to the paper's formulas\n    //     let n_d_sqrt = (n * d) as f64; // = 4.0\n\n    //     // s_g = sqrt(n*d) * s^2 = 4.0 * 4.0 = 16.0\n    //     let s_g = n_d_sqrt * s * s;\n\n    //     // s_h = beta * sqrt(n*d) * s = 1.0 * 4.0 * 2.0 = 8.0\n    //     let s_h = beta * n_d_sqrt * s;\n\n    //     // b2 ≈ sqrt(12 * s_g) = sqrt(12 * 16.0) = sqrt(192) ≈ 13.856... =\u003e 13\n    //     let expected_b2 = (12.0 * s_g).sqrt() as u32;\n\n    //     // b1 ≈ sqrt(12 * s_h) = sqrt(12 * 8.0) = sqrt(96) ≈ 9.798... =\u003e 9\n    //     let expected_b1 = (12.0 * s_h).sqrt() as u32;\n\n    //     // For q = 2^32:\n    //     // t2 ≈ log_b2(q) = log_13(2^32) = 32/log_2(13) ≈ 32/3.7 ≈ 8.65 =\u003e 9\n    //     let expected_t2 = ((32.0 / (expected_b2 as f64).log2()).ceil() as usize).max(2);\n\n    //     // t1 ≈ log_b1(q) = log_9(2^32) = 32/log_2(9) ≈ 32/3.17 ≈ 10.09 =\u003e 11\n    //     let expected_t1 = ((32.0 / (expected_b1 as f64).log2()).ceil() as usize).max(2);\n\n    //     // Call the function under test\n    //     let params =\n    //         GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::calculate_optimal_parameters(\n    //             n, d, s, beta,\n    //         );\n\n    //     // Check results\n    //     assert!(\n    //         params.g_base.to_u128() \u003e= expected_b2 as u128 - 1\n    //             \u0026\u0026 params.g_base.to_u128() \u003c= expected_b2 as u128 + 1,\n    //         \"g_base {}, expected {}\",\n    //         params.g_base.to_u128(),\n    //         expected_b2\n    //     );\n\n    //     assert!(\n    //         params.h_base.to_u128() \u003e= expected_b1 as u128 - 1\n    //             \u0026\u0026 params.h_base.to_u128() \u003c= expected_b1 as u128 + 1,\n    //         \"h_base {}, expected {}\",\n    //         params.h_base.to_u128(),\n    //         expected_b1\n    //     );\n\n    //     // For part counts, use approximate comparison due to potential floating point differences\n    //     assert!(\n    //         params.g_parts \u003e= expected_t2 - 1 \u0026\u0026 params.g_parts \u003c= expected_t2 + 1,\n    //         \"g_parts {}, expected {}\",\n    //         params.g_parts,\n    //         expected_t2\n    //     );\n\n    //     assert!(\n    //         params.h_parts \u003e= expected_t1 - 1 \u0026\u0026 params.h_parts \u003c= expected_t1 + 1,\n    //         \"h_parts {}, expected {}\",\n    //         params.h_parts,\n    //         expected_t1\n    //     );\n    // }\n\n    // #[test]\n    // fn test_error_handling() {\n    //     let params = AjtaiParameters::new(Zq::ONE, Zq::ONE).unwrap();\n    //     let mut rng = rand::rng();\n    //     let nu1_matrix = RqMatrix::\u003cTEST_M, TEST_N, TEST_D\u003e::random(\u0026mut rng);\n    //     let nu2_matrix = RqMatrix::\u003cTEST_M, TEST_N, TEST_D\u003e::random(\u0026mut rng);\n\n    //     // Test invalid g_base (≤ 1)\n    //     let invalid_g_base = GarbageParameters {\n    //         g_base: Zq::ONE, // Invalid: base must be \u003e 1\n    //         g_parts: 2,\n    //         h_base: Zq::new(4),\n    //         h_parts: 3,\n    //     };\n\n    //     let result = GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::new(\n    //         params.clone(),\n    //         nu1_matrix.clone(),\n    //         nu2_matrix.clone(),\n    //         invalid_g_base,\n    //     );\n\n    //     assert!(result.is_err(), \"Should reject g_base ≤ 1\");\n    //     match result {\n    //         Err(HierarchicalError::InvalidBase(_)) =\u003e {} // Expected error\n    //         _ =\u003e panic!(\"Wrong error type for invalid g_base\"),\n    //     }\n\n    //     // Test invalid g_parts (0)\n    //     let invalid_g_parts = GarbageParameters {\n    //         g_base: Zq::new(8),\n    //         g_parts: 0, // Invalid: parts must be \u003e 0\n    //         h_base: Zq::new(4),\n    //         h_parts: 3,\n    //     };\n\n    //     let result = GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::new(\n    //         params.clone(),\n    //         nu1_matrix.clone(),\n    //         nu2_matrix.clone(),\n    //         invalid_g_parts,\n    //     );\n\n    //     assert!(result.is_err(), \"Should reject g_parts = 0\");\n    //     match result {\n    //         Err(HierarchicalError::InvalidPartCount(_)) =\u003e {} // Expected error\n    //         _ =\u003e panic!(\"Wrong error type for invalid g_parts\"),\n    //     }\n\n    //     // Test invalid h_base (≤ 1)\n    //     let invalid_h_base = GarbageParameters {\n    //         g_base: Zq::new(8),\n    //         g_parts: 2,\n    //         h_base: Zq::ZERO, // Invalid: base must be \u003e 0\n    //         h_parts: 3,\n    //     };\n\n    //     let result = GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::new(\n    //         params.clone(),\n    //         nu1_matrix.clone(),\n    //         nu2_matrix.clone(),\n    //         invalid_h_base,\n    //     );\n\n    //     assert!(result.is_err(), \"Should reject h_base ≤ 1\");\n    //     match result {\n    //         Err(HierarchicalError::InvalidBase(_)) =\u003e {} // Expected error\n    //         _ =\u003e panic!(\"Wrong error type for invalid h_base\"),\n    //     }\n\n    //     // Test invalid h_parts (0)\n    //     let invalid_h_parts = GarbageParameters {\n    //         g_base: Zq::new(8),\n    //         g_parts: 2,\n    //         h_base: Zq::new(4),\n    //         h_parts: 0, // Invalid: parts must be \u003e 0\n    //     };\n\n    //     let result = GarbagePolynomialCommitment::\u003cTEST_M, TEST_N, TEST_D\u003e::new(\n    //         params.clone(),\n    //         nu1_matrix.clone(),\n    //         nu2_matrix,\n    //         invalid_h_parts,\n    //     );\n\n    //     assert!(result.is_err(), \"Should reject h_parts = 0\");\n    //     match result {\n    //         Err(HierarchicalError::InvalidPartCount(_)) =\u003e {} // Expected error\n    //         _ =\u003e panic!(\"Wrong error type for invalid h_parts\"),\n    //     }\n    // }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":24,"address":[],"length":0,"stats":{"Line":16}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":24}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":16}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":24}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":4}}],"covered":14,"coverable":26},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","inner_product.rs"],"content":"use std::{\n    borrow::Borrow,\n    ops::{Add, Mul},\n};\n\npub fn compute_linear_combination\u003cE, B, C\u003e(elements: \u0026[E], challenges: \u0026[C]) -\u003e B\nwhere\n    E: Borrow\u003cB\u003e,\n    for\u003c'a\u003e \u0026'a B: Mul\u003c\u0026'a C, Output = B\u003e,\n    for\u003c'a\u003e \u0026'a B: Add\u003c\u0026'a B, Output = B\u003e,\n{\n    debug_assert_eq!(\n        elements.len(),\n        challenges.len(),\n        \"vectors must be the same length\"\n    );\n    debug_assert!(!elements.is_empty(), \"`elements` must not be empty\");\n\n    let mut zipped_iter = elements.iter().zip(challenges.iter());\n    // Must do the following as the init value in fold requires size of B\n    let (e0, c0) = zipped_iter.next().unwrap();\n    let init = e0.borrow() * c0;\n\n    zipped_iter.fold(init, |acc, (elem, c)| \u0026acc + \u0026(elem.borrow() * c))\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":2345}},{"line":12,"address":[],"length":0,"stats":{"Line":2345}},{"line":13,"address":[],"length":0,"stats":{"Line":2345}},{"line":14,"address":[],"length":0,"stats":{"Line":2345}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":4690}},{"line":19,"address":[],"length":0,"stats":{"Line":2345}},{"line":21,"address":[],"length":0,"stats":{"Line":2345}},{"line":22,"address":[],"length":0,"stats":{"Line":2345}},{"line":24,"address":[],"length":0,"stats":{"Line":30604}}],"covered":9,"coverable":10},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","jl.rs"],"content":"use crate::ring;\nuse crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\n\n// LaBRADOR: Compact Proofs for R1CS from Module-SIS | Page 5 | Proving smallness section\nconst UPPER_BOUND_FACTOR: Zq = Zq::new(128);\nconst LOWER_BOUND_FACTOR: Zq = Zq::new(30);\n\npub struct Projection {\n    random_linear_map_vector: Vec\u003cRqMatrix\u003e,\n    security_level: usize,\n}\n\nimpl Projection {\n    pub fn new(random_linear_map_vector: Vec\u003cRqMatrix\u003e, security_level: usize) -\u003e Self {\n        Self {\n            random_linear_map_vector,\n            security_level,\n        }\n    }\n\n    fn compute_projection(\u0026self, index: usize, witness: \u0026RqVector) -\u003e Vec\u003cZq\u003e {\n        let mut projection = vec![Zq::ZERO; 2 * self.security_level];\n        let coefficients = witness.concatenate_coefficients();\n        for (i, pi_ij) in self.random_linear_map_vector[index]\n            .get_elements()\n            .iter()\n            .enumerate()\n        {\n            projection[i] = pi_ij\n                .concatenate_coefficients()\n                .iter()\n                .zip(coefficients.iter())\n                .map(|(m, s)| *m * *s)\n                .sum::\u003cZq\u003e();\n        }\n        projection\n    }\n\n    pub fn compute_batch_projection(\u0026self, witness_vector: \u0026[RqVector]) -\u003e Vec\u003cZq\u003e {\n        let mut result = vec![Zq::ZERO; 2 * self.security_level];\n        for (index_i, witness) in witness_vector.iter().enumerate() {\n            ring::zq::add_assign_two_zq_vectors(\n                \u0026mut result,\n                self.compute_projection(index_i, witness),\n            );\n        }\n        result\n    }\n\n    pub fn get_projection_matrices(\u0026self) -\u003e \u0026[RqMatrix] {\n        \u0026self.random_linear_map_vector\n    }\n\n    pub fn get_conjugated_projection_matrices(\u0026self) -\u003e Vec\u003cRqMatrix\u003e {\n        self.random_linear_map_vector\n            .iter()\n            .map(|pi_i| {\n                pi_i.get_elements()\n                    .iter()\n                    .map(|pi_ij| {\n                        pi_ij\n                            .get_elements()\n                            .iter()\n                            .map(|polynomial| polynomial.conjugate_automorphism())\n                            .collect()\n                    })\n                    .collect()\n            })\n            .collect()\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn norm_squared(projection: \u0026[Zq]) -\u003e Zq {\n        projection\n            .iter()\n            .map(|coeff| {\n                coeff.centered_mod(Zq::new(Zq::Q as u32))\n                    * coeff.centered_mod(Zq::new(Zq::Q as u32))\n            })\n            .sum()\n    }\n\n    // Function to verify upper bound of projection\n    pub fn verify_projection_upper_bound(projection: \u0026[Zq], beta_squared: Zq) -\u003e bool {\n        Self::norm_squared(projection) \u003c (UPPER_BOUND_FACTOR * beta_squared)\n    }\n\n    // Function to verify lower bound of projection\n    pub fn verify_projection_lower_bound(projection: \u0026[Zq], beta_squared: Zq) -\u003e bool {\n        Self::norm_squared(projection) \u003e (LOWER_BOUND_FACTOR * beta_squared)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::relation::witness::Witness;\n    use crate::transcript::sponges::shake::ShakeSponge;\n    use crate::transcript::{LabradorTranscript, Sponge};\n    use rand::rng;\n\n    // Test that the probability of the inequality being true is close to 1/2\n    #[test]\n    #[cfg(not(feature = \"skip-slow-tests\"))]\n    fn test_projection_is_smaller_than_upper_bound() {\n        use crate::transcript::Sponge;\n\n        let (security_parameter, rank, multiplicity) = (128, 5, 1);\n        // 1000 was chosen to provide a reasonably large sample size\n\n        let trials: f64 = 1000.0;\n        let mut success_count: f64 = 0.0;\n        for _ in 0..1000 {\n            let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n            // This gives randomness to the transcript, to generate random projection matrices.\n            transcript.set_u1(RqVector::random(\u0026mut rng(), 1));\n            let projections =\n                transcript.generate_projections(security_parameter, rank, multiplicity);\n\n            let witness = RqVector::random(\u0026mut rand::rng(), rank);\n            let result = projections.compute_projection(0, \u0026witness);\n\n            let beta = witness.l2_norm_squared();\n            // Check if the norm of the projection is smaller than 128 * (squared norm of the projection of the random polynomial)\n            let test: bool = Projection::verify_projection_upper_bound(\u0026result, beta);\n            if test {\n                success_count += 1.0;\n            }\n        }\n\n        let observed_probability = success_count / trials;\n\n        // We allow some tolerance because of the statistical nature of the results.\n        let tolerance = 0.05;\n        assert!(\n            (observed_probability - 0.5).abs() \u003c tolerance,\n            \"Observed probability {} is not close to 0.5\",\n            observed_probability\n        );\n    }\n\n    // On average the projected norm squared is the same as 128 * vector norm squared\n    #[test]\n    #[cfg(not(feature = \"skip-slow-tests\"))]\n    fn test_projection_average_value() {\n        use crate::{relation::witness::Witness, transcript::Sponge};\n\n        let (security_parameter, rank, multiplicity) = (128, 3, 1);\n        let trials: u128 = 10000;\n\n        // let witness = RqVector::random_ternary(\u0026mut rand::rng(), rank);\n        let witness = Witness::new(rank, multiplicity, Zq::new(6400)).s;\n        let witness_norm = (128 * witness[0].l2_norm_squared().to_u128()) as f64;\n\n        let mut norm_sum = 0u128;\n        // Run the test multiple times to simulate the probability\n        for _ in 0..trials {\n            let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n            // This gives randomness to the transcript, to generate random projection matrices.\n            transcript.set_u1(RqVector::random(\u0026mut rng(), 1));\n            let projections =\n                transcript.generate_projections(security_parameter, rank, multiplicity);\n            let result = projections.compute_projection(0, \u0026witness[0]);\n            norm_sum += Projection::norm_squared(\u0026result).to_u128();\n        }\n\n        // Calculate the observed probability\n        let average = norm_sum as f64 / trials as f64;\n        let ratio = if witness_norm \u003c= average {\n            average / witness_norm\n        } else {\n            witness_norm / average\n        };\n\n        // we choose a small tolerance value for possible statistical error\n        let tolerance_percent: f64 = 1.01;\n        assert!(\n            ratio \u003c tolerance_percent,\n            \"Average norm value {} is not equal to {}.\",\n            average,\n            witness_norm,\n        );\n    }\n\n    // Test lower bound verification\n    #[test]\n    fn test_lower_bound() {\n        let (security_parameter, rank, multiplicity) = (128, 5, 1);\n\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        transcript.set_u1(RqVector::random(\u0026mut rng(), 1));\n        let projections = transcript.generate_projections(security_parameter, rank, multiplicity);\n        let witness = Witness::new(rank, multiplicity, Zq::new(6400)).s;\n\n        let beta = witness[0].l2_norm_squared();\n        // Check if the norm of the projection is bigger than 30 * (squared norm of the projection of the random polynomial)\n        assert!(Projection::verify_projection_lower_bound(\n            \u0026projections.compute_projection(0, \u0026witness[0]),\n            beta\n        ));\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":7}},{"line":24,"address":[],"length":0,"stats":{"Line":7}},{"line":25,"address":[],"length":0,"stats":{"Line":7}},{"line":26,"address":[],"length":0,"stats":{"Line":1799}},{"line":27,"address":[],"length":0,"stats":{"Line":7}},{"line":28,"address":[],"length":0,"stats":{"Line":7}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":573440}},{"line":38,"address":[],"length":0,"stats":{"Line":7}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":8}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":9}},{"line":61,"address":[],"length":0,"stats":{"Line":9}},{"line":62,"address":[],"length":0,"stats":{"Line":2313}},{"line":63,"address":[],"length":0,"stats":{"Line":2304}},{"line":64,"address":[],"length":0,"stats":{"Line":2304}},{"line":65,"address":[],"length":0,"stats":{"Line":2304}},{"line":66,"address":[],"length":0,"stats":{"Line":16128}},{"line":67,"address":[],"length":0,"stats":{"Line":2304}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":257}},{"line":79,"address":[],"length":0,"stats":{"Line":256}},{"line":80,"address":[],"length":0,"stats":{"Line":256}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}}],"covered":35,"coverable":37},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","core","mod.rs"],"content":"pub mod aggregate;\npub mod garbage_polynomials;\npub mod inner_product;\npub mod jl;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","lib.rs"],"content":"// Documentation\n\n// Main Introduction\n#![forbid(unsafe_code)]\n#![deny(clippy::as_conversions)]\n#![doc = include_str!(\"../doc/mainpage-doc.md\")]\n// Arithmetic Circuit Translation\n#![doc = include_str!(\"../doc/arithmetic_circuit_translation.md\")]\n// Ajtai Commitment\n#![doc = include_str!(\"../doc/ajtai_commitment.md\")]\n// Hierarchical Commitment\n#![doc = include_str!(\"../doc/hierarchical_commitment.md\")]\n// Projections\n#![doc = include_str!(\"../doc/projections.md\")]\n// Aggregation\n#![doc = include_str!(\"../doc/aggregation.md\")]\n// Amortization\n#![doc = include_str!(\"../doc/amortization.md\")]\n\npub mod commitments;\npub mod core;\npub mod prover;\npub mod relation;\npub mod ring;\npub mod transcript;\npub mod verifier;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","main.rs"],"content":"// use labrador::core::jl::{verify_upper_bound, ProjectionMatrix, ProjectionVector};\n// use labrador::ring::rq::Rq;\n// use labrador::ring::rq_vector::RqVector;\n// use labrador::ring::zq::Zq;\n// use rand::rng;\n\n// const D: usize = 4; // Degree of polynomials in S_i\n// const N: usize = 5; // Size of S_i\n\n// fn main() {\n//     // Example poly_ring\n//     let p1: Rq\u003cD\u003e = vec![Zq::new(1)].into();\n//     let p2: Rq\u003cD\u003e = vec![Zq::new(2), Zq::new(1), Zq::new(1)].into();\n//     // Perform polynomial multiplication\n//     let product = p1.clone() * p2.clone();\n\n//     // Perform polynomial addition\n//     let sum = p1.clone() + p2.clone();\n\n//     // Perform polynomial subtraction\n//     let sub = p1.clone() - p2.clone();\n\n//     // Compute the dot product between the polynomial coefficients\n//     let dot = p1.clone().inner_product(\u0026p2);\n\n//     // Negate the polynomial\n//     let negation = -p1.clone();\n\n//     // Perform scalar multiplication\n//     let scalar_multiplication = p1.scalar_mul(Zq::new(2));\n\n//     // Evaluate the polynomial at x = 2\n//     let evaluation = p2.eval(Zq::new(2));\n\n//     // Check if the polynomial is the zero polynomial\n//     let zero_check = p1.is_zero();\n\n//     // Check if p1 is equal to p2\n//     let are_equal = p1.is_equal(\u0026p2);\n\n//     // Print the results\n//     println!(\"Product: {:?}\", product);\n//     println!(\"Sum: {:?}\", sum);\n//     println!(\"Subtraction: {:?}\", sub);\n//     println!(\"Dot product: {:?}\", dot);\n//     println!(\"Negation: {:?}\", negation);\n//     println!(\"Scalar multiplication: {:?}\", scalar_multiplication);\n//     println!(\"Evaluation at x=2: {:?}\", evaluation);\n//     println!(\"Is zero polynomial: {:?}\", zero_check);\n//     println!(\"Are polynomials equal: {:?}\", are_equal);\n\n//     let a = Zq::new(5);\n//     let b = Zq::new(3);\n//     println!(\"a + b = {}\", a + b);\n\n//     // Johnson Linderstrauss Projections\n//     // Example\n//     // Generate the random polynomials\n//     let n = 3;\n//     let mut rng = rng();\n//     let polynomials = RqVector::\u003cN, D\u003e::random_ternary(\u0026mut rng);\n//     // Random projection matrix\n//     let matrix = ProjectionMatrix::new(n);\n//     // Calculate projection\n//     let projection = ProjectionVector::new(\u0026matrix, \u0026polynomials);\n//     // Within bounds with probability 1/2\n//     let beta = polynomials.compute_norm_squared();\n//     println!(\"{}\", verify_upper_bound(projection, beta));\n// }\n\nfn main() {}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","prover.rs"],"content":"use crate::commitments::ajtai_commitment;\nuse crate::commitments::common_instances::AjtaiInstances;\nuse crate::commitments::outer_commitments;\nuse crate::commitments::outer_commitments::DecompositionParameters;\nuse crate::commitments::CommitError;\nuse crate::core::aggregate::FunctionsAggregation;\nuse crate::core::aggregate::ZeroConstantFunctionsAggregation;\nuse crate::core::garbage_polynomials;\nuse crate::core::inner_product;\nuse crate::core::jl::Projection;\nuse crate::relation::env_params;\nuse crate::relation::witness::Witness;\nuse crate::relation::{env_params::EnvironmentParameters, statement::Statement};\nuse crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\nuse crate::transcript::LabradorTranscript;\nuse crate::transcript::Sponge;\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum ProverError {\n    /// Indicates that the L2 norm (squared) of the witness exceeded the allowed threshold.\n    #[error(\"invalid witness size: norm_squared {norm_squared}, allowed {allowed}\")]\n    WitnessL2NormViolated { norm_squared: Zq, allowed: Zq },\n    #[error(\"Invalid Projection of index {index}. Expected {expected}, got {computed}\")]\n    ProjectionError {\n        index: usize,\n        expected: Zq,\n        computed: Zq,\n    },\n    #[error(\"commitment failure\")]\n    CommitError(#[from] ajtai_commitment::CommitError),\n    #[error(\"decomposition failure\")]\n    DecompositionError(#[from] outer_commitments::DecompositionError),\n}\n\npub struct LabradorProver\u003c'a\u003e {\n    params: \u0026'a EnvironmentParameters,\n    crs: \u0026'a AjtaiInstances,\n    witness: \u0026'a Witness,\n    st: \u0026'a Statement,\n    // Aggregation instances\n    constant_aggregator: ZeroConstantFunctionsAggregation\u003c'a\u003e,\n    funcs_aggregator: FunctionsAggregation\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e LabradorProver\u003c'a\u003e {\n    pub fn new(\n        params: \u0026'a EnvironmentParameters,\n        crs: \u0026'a AjtaiInstances,\n        witness: \u0026'a Witness,\n        st: \u0026'a Statement,\n    ) -\u003e Self {\n        Self {\n            params,\n            crs,\n            witness,\n            st,\n            constant_aggregator: ZeroConstantFunctionsAggregation::new(params),\n            funcs_aggregator: FunctionsAggregation::new(params),\n        }\n    }\n\n    fn compute_vector_ti(\u0026self) -\u003e Result\u003cRqMatrix, CommitError\u003e {\n        // Ajtai Commitments t_i = A * s_i\n        let commitments = self\n            .witness\n            .s\n            .iter()\n            .cloned()\n            .map(|s_i| self.crs.commitment_scheme_a.commit(\u0026s_i))\n            .collect::\u003cResult\u003cVec\u003c_\u003e, CommitError\u003e\u003e()?;\n\n        Ok(RqMatrix::new(commitments, false))\n    }\n\n    fn compute_u1\u003cS: Sponge\u003e(\n        \u0026mut self,\n        transcript: \u0026mut LabradorTranscript\u003cS\u003e,\n    ) -\u003e Result\u003c(RqMatrix, RqMatrix), ProverError\u003e {\n        let t_i = self.compute_vector_ti()?;\n        // g_ij = \u003cs_i, s_j\u003e\n        let garbage_polynomial_g = garbage_polynomials::compute_g(\u0026self.witness.s);\n        // calculate outer commitment u_1 = \\sum(B_ik * t_i^(k)) + \\sum(C_ijk * g_ij^(k))\n        let commitment_u1 = outer_commitments::compute_u1(\n            self.crs,\n            \u0026t_i,\n            DecompositionParameters::new(self.params.b, self.params.t_1)?,\n            \u0026garbage_polynomial_g,\n            DecompositionParameters::new(self.params.b, self.params.t_2)?,\n        );\n        transcript.set_u1(commitment_u1);\n        Ok((t_i, garbage_polynomial_g))\n    }\n\n    fn compute_p\u003cS: Sponge\u003e(\u0026self, transcript: \u0026mut LabradorTranscript\u003cS\u003e) -\u003e Projection {\n        let projections = transcript.generate_projections(\n            env_params::SECURITY_PARAMETER,\n            self.params.rank,\n            self.params.multiplicity,\n        );\n        let vector_p = projections.compute_batch_projection(\u0026self.witness.s);\n        transcript.set_vector_p(vector_p);\n        projections\n    }\n\n    fn compute_b_double_prime\u003cS: Sponge\u003e(\n        \u0026mut self,\n        transcript: \u0026mut LabradorTranscript\u003cS\u003e,\n        projections: \u0026Projection,\n    ) {\n        let vector_psi =\n            transcript.generate_vector_psi(self.params.const_agg_length, self.params.constraint_l);\n        let vector_omega = transcript\n            .generate_vector_omega(self.params.const_agg_length, env_params::SECURITY_PARAMETER);\n        // first aggregation\n        self.constant_aggregator\n            .calculate_agg_a_double_prime(\u0026vector_psi, \u0026self.st.a_ct);\n        self.constant_aggregator.calculate_agg_phi_double_prime(\n            \u0026self.st.phi_ct,\n            \u0026projections.get_conjugated_projection_matrices(),\n            \u0026vector_psi,\n            \u0026vector_omega,\n        );\n        let b_ct_aggr = self\n            .constant_aggregator\n            .calculate_agg_b_double_prime(\u0026self.witness.s);\n        transcript.set_vector_b_ct_aggr(b_ct_aggr);\n    }\n\n    fn compute_u2\u003cS: Sponge\u003e(\n        \u0026mut self,\n        transcript: \u0026mut LabradorTranscript\u003cS\u003e,\n    ) -\u003e Result\u003cRqMatrix, ProverError\u003e {\n        let alpha_vector = transcript.generate_rq_vector(self.params.constraint_k);\n        let beta_vector = transcript.generate_rq_vector(self.params.const_agg_length);\n        self.funcs_aggregator.calculate_aggr_phi(\n            \u0026self.st.phi_constraint,\n            self.constant_aggregator.get_phi_double_prime(),\n            \u0026alpha_vector,\n            \u0026beta_vector,\n        );\n\n        // Step 4: Calculate h_ij, u_2, and z starts: ---------------------------------------\n        let garbage_polynomial_h =\n            garbage_polynomials::compute_h(\u0026self.witness.s, self.funcs_aggregator.get_appr_phi());\n        let commitment_u2 = outer_commitments::compute_u2(\n            self.crs,\n            \u0026garbage_polynomial_h,\n            DecompositionParameters::new(self.params.b, self.params.t_1)?,\n        );\n        transcript.set_u2(commitment_u2);\n        Ok(garbage_polynomial_h)\n    }\n\n    // calculate z = c_1*s_1 + ... + c_r*s_r\n    fn compute_z\u003cS: Sponge\u003e(\u0026mut self, transcript: \u0026mut LabradorTranscript\u003cS\u003e) -\u003e RqVector {\n        let challenges =\n            transcript.generate_challenges(env_params::OPERATOR_NORM, self.params.multiplicity);\n        let z =\n            inner_product::compute_linear_combination(\u0026self.witness.s, challenges.get_elements());\n        z\n    }\n\n    /// all prove steps are from page 17\n    pub fn prove\u003cS: Sponge\u003e(\u0026mut self) -\u003e Result\u003cLabradorTranscript\u003cS\u003e, ProverError\u003e {\n        // Generate random challenges used between prover and verifier\n        let mut transcript = LabradorTranscript::new(S::default());\n\n        // Step 1: Outer commitments u_1 starts: --------------------------------------------\n        let (t_i, garbage_polynomial_g) = self.compute_u1(\u0026mut transcript)?;\n        // Step 1: Outer commitments u_1 ends: ----------------------------------------------\n\n        // Step 2: JL projection starts: ----------------------------------------------------\n        let projections = self.compute_p(\u0026mut transcript);\n        // Step 2: JL projection ends: ------------------------------------------------------\n\n        // Step 3: Aggregation starts: --------------------------------------------------------------\n        self.compute_b_double_prime(\u0026mut transcript, \u0026projections);\n\n        // second aggregation\n\n        // Aggregation ends: ----------------------------------------------------------------\n        let garbage_polynomial_h = self.compute_u2(\u0026mut transcript)?;\n\n        let z = self.compute_z(\u0026mut transcript);\n\n        transcript.set_recursive_part(z, t_i, garbage_polynomial_g, garbage_polynomial_h);\n\n        // Step 4: Calculate h_ij, u_2, and z ends: -----------------------------------------\n\n        Ok(transcript)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_prove() {\n        // set up example environment parameters, use default set for testing.\n        let ep_1 = EnvironmentParameters::default();\n        // generate a random witness based on environment parameters above\n        let witness_1 = Witness::new(ep_1.rank, ep_1.multiplicity, ep_1.beta);\n        // generate public statement based on witness_1\n        let st: Statement = Statement::new(\u0026witness_1, \u0026ep_1);\n        // generate the common reference string matrices A, B, C, D\n        let crs: AjtaiInstances = AjtaiInstances::new(\u0026ep_1);\n\n        // create a new prover\n        let mut prover = LabradorProver::new(\u0026ep_1, \u0026crs, \u0026witness_1, \u0026st);\n        let _: LabradorTranscript\u003cShakeSponge\u003e = prover.prove().unwrap();\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":10}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}}],"covered":17,"coverable":53},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","relation","mod.rs"],"content":"pub mod env_params;\npub mod statement;\npub mod witness;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","relation","witness.rs"],"content":"use rand::rng;\n\nuse crate::ring::{rq::Rq, rq_vector::RqVector, zq::Zq};\n\npub struct Witness {\n    pub s: Vec\u003cRqVector\u003e,\n}\n\nimpl Witness {\n    pub fn new(rank: usize, multiplicity: usize, bound: Zq) -\u003e Self {\n        #[allow(clippy::as_conversions)]\n        let std = (bound.get_value() as f64) / f64::sqrt((rank * multiplicity * Rq::DEGREE) as f64);\n        #[allow(clippy::as_conversions)]\n        let std = std as u32;\n        loop {\n            let s: Vec\u003cRqVector\u003e = (0..multiplicity)\n                .map(|_| RqVector::random_with_bound(\u0026mut rng(), rank, std))\n                .collect();\n            if Self::validate_l2_norm(\u0026s, bound) {\n                return Self { s };\n            }\n        }\n    }\n\n    fn validate_l2_norm(candidate: \u0026[RqVector], bound: Zq) -\u003e bool {\n        for witness in candidate {\n            if witness.l2_norm_squared() \u003e bound * bound {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use crate::ring::{rq::Rq, rq_vector::RqVector, zq::Zq};\n\n    use super::Witness;\n\n    #[test]\n    fn test_witness_vector_norm() {\n        let bound = Zq::new(320000);\n        let witness_vector = Witness::new(40, 100, bound);\n        assert_eq!(witness_vector.s.len(), 100);\n        assert_eq!(witness_vector.s[0].get_length(), 40);\n        for witness in witness_vector.s.iter() {\n            let l2_norm = witness.l2_norm_squared();\n            assert!(l2_norm \u003c bound * bound)\n        }\n    }\n\n    #[test]\n    fn test_witness_with_larger_bound() {\n        let poly1 = Rq::new([Zq::new(10000); Rq::DEGREE]);\n        let poly2 = Rq::new([Zq::new(142310); Rq::DEGREE]);\n        let poly3 = Rq::new([Zq::new(9310); Rq::DEGREE]);\n        let poly_vector = vec![poly1, poly2, poly3];\n        assert!(!Witness::validate_l2_norm(\n            \u0026[RqVector::new(poly_vector)],\n            Zq::new(1000)\n        ));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":6}},{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":14,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":121}},{"line":19,"address":[],"length":0,"stats":{"Line":6}},{"line":20,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":224}},{"line":27,"address":[],"length":0,"stats":{"Line":109}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":6}}],"covered":12,"coverable":13},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","mod.rs"],"content":"pub mod rq;\npub mod rq_matrix;\npub mod rq_vector;\npub mod zq;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","rq.rs"],"content":"// This file is part of the polynomial ring operations module.\n//\n//\n// Currently implemented functions include:\n// - Polynomial addition:          +\n// - Polynomial multiplication:    *\n// - inner_product/ Dot product:   inner_product()\n// - Polynomial subtraction:       -\n// - Polynomial negation:          neg()\n// - Scalar multiplication:        scalar_mul()\n// - Polynomial evaluation:        eval()\n// - Zero check:                   is_zero()\n// - Polynomial equality check:    is_equal()\n// - Get the Coefficients:         get_coefficients()\n// - Random small norm vector:     random_small_vector()\n// - Squared norm of coefficients: compute_norm_squared()\n//\n// Further operations and optimizations will be added in future versions.\n\n// We use the Zq ring\nuse crate::ring::zq::Zq;\nuse core::ops::{Add, Mul, Sub};\nuse rand::distr::{Distribution, Uniform};\nuse rand::{CryptoRng, Rng};\nuse rustfft::num_complex::Complex;\nuse rustfft::FftPlanner;\n\n/// This module provides implementations for various operations\n/// in the polynomial ring R = Z_q\\[X\\] / (X^d + 1).\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Rq {\n    coeffs: [Zq; Self::DEGREE],\n}\n\nimpl Rq {\n    pub const DEGREE: usize = 64;\n    /// Constructor for the polynomial ring\n    pub const fn new(coeffs: [Zq; Self::DEGREE]) -\u003e Self {\n        Rq { coeffs }\n    }\n\n    /// Generate zero polynomial\n    pub const fn zero() -\u003e Self {\n        Self {\n            coeffs: [Zq::ZERO; Self::DEGREE],\n        }\n    }\n\n    /// ```compile_fail\n    ///\n    /// let poly = Rq::zero(); // or any constructor you have\n    ///\n    /// // Move happens here …\n    /// let _coeffs = poly.into_coeffs();\n    ///\n    /// // …so using `poly` again must not compile:\n    /// let _still_here = poly; //^ ERROR use of moved value\n    /// ```\n    pub fn into_coeffs(self) -\u003e [Zq; Self::DEGREE] {\n        self.coeffs\n    }\n\n    /// Get the coefficients as a vector\n    pub fn get_coefficients(\u0026self) -\u003e \u0026[Zq; Self::DEGREE] {\n        \u0026self.coeffs\n    }\n\n    /// Generate random polynomial with a provided cryptographically secure RNG\n    pub fn random\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R) -\u003e Self {\n        let uniform = Uniform::new_inclusive(Zq::ZERO, Zq::NEG_ONE).unwrap();\n        let mut coeffs = [Zq::ZERO; Self::DEGREE];\n        coeffs.iter_mut().for_each(|c| *c = uniform.sample(rng));\n        Self { coeffs }\n    }\n\n    /// Generate random polynomial with a provided cryptographically secure RNG and given bound\n    pub fn random_with_bound\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, bound: u32) -\u003e Self {\n        let uniform = Uniform::new_inclusive(Zq::ZERO, Zq::new(bound)).unwrap();\n        let mut coeffs = [Zq::ZERO; Self::DEGREE];\n        coeffs.iter_mut().for_each(|c| {\n            *c = if rng.random_bool(0.5) {\n                -uniform.sample(rng)\n            } else {\n                uniform.sample(rng)\n            }\n        });\n        Self { coeffs }\n    }\n\n    #[allow(clippy::as_conversions)]\n    pub fn l2_norm_squared(\u0026self) -\u003e Zq {\n        self.coeffs\n            .iter()\n            .map(|coeff| {\n                coeff.centered_mod(Zq::new(Zq::Q as u32))\n                    * coeff.centered_mod(Zq::new(Zq::Q as u32))\n            })\n            .sum()\n    }\n\n    /// Decomposes a polynomial into base-B representation:\n    /// p = p⁽⁰⁾ + p⁽¹⁾·B + p⁽²⁾·B² + ... + p⁽ᵗ⁻¹⁾·B^(t-1)\n    /// Where each p⁽ⁱ⁾ has small coefficients, using centered representatives\n    pub fn decompose(\u0026self, base: Zq, num_parts: usize) -\u003e Vec\u003cRq\u003e {\n        debug_assert!(num_parts \u003e 0, \"num_parts must be positive\");\n        let mut parts = Vec::with_capacity(num_parts);\n        let mut initial_coeffs = *self.get_coefficients();\n\n        for _ in 0..num_parts - 1 {\n            // Extract low part (mod base, centered around 0)\n            let mut low_coeffs = [Zq::ZERO; Self::DEGREE];\n\n            for (low_c, coeff) in low_coeffs.iter_mut().zip(initial_coeffs.iter_mut()) {\n                let centered = coeff.centered_mod(base);\n                *low_c = centered;\n                *coeff = (*coeff - centered).scale_by(base);\n            }\n            parts.push(Self::new(low_coeffs));\n        }\n        parts.push(Self::new(initial_coeffs));\n        parts\n    }\n\n    /// Compute the conjugate automorphism \\sigma_{-1} of vector based on B) Constraints..., Page 21.\n    pub fn conjugate_automorphism(\u0026self) -\u003e Self {\n        let q_minus_1 = Zq::NEG_ONE;\n\n        let original_coefficients = self.get_coefficients();\n\n        let mut conjugated_coeffs = [Zq::ZERO; Rq::DEGREE];\n        conjugated_coeffs[0] = original_coefficients[0];\n\n        for (conj_coeff, original_coeff) in conjugated_coeffs\n            .iter_mut()\n            .skip(1)\n            .zip(original_coefficients.iter().rev())\n        {\n            *conj_coeff = original_coeff * q_minus_1;\n        }\n\n        Self::new(conjugated_coeffs)\n    }\n\n    /// Compute the operator norm of a polynomial given its coefficients.\n    /// The operator norm is defined as the maximum magnitude of the DFT (eigenvalues)\n    /// of the coefficient vector.\n    ///\n    /// Note that: The operator norm only affects the coefficients of the random PolyRings generated from the challenge space.\n    /// Prover and Verifier will not do the operator norm check, because random PolyRings are determined after generation.\n    /// Both party will have access to the same PolyRings through transcript,\n    #[allow(clippy::as_conversions)]\n    pub fn operator_norm(\u0026self) -\u003e f64 {\n        let coeffs = self.get_coefficients();\n        let n = coeffs.len();\n        let mut planner = FftPlanner::new();\n        let fft = planner.plan_fft_forward(n);\n\n        // Convert coefficients into complex numbers (with zero imaginary parts)\n        let mut buffer: Vec\u003cComplex\u003cf64\u003e\u003e = coeffs\n            .iter()\n            .map(|\u0026x| {\n                let half = Zq::NEG_ONE.scale_by(Zq::TWO);\n                let converted_value = if x \u003e half {\n                    x.to_u128() as f64 - Zq::NEG_ONE.to_u128() as f64 - 1.0\n                } else {\n                    x.to_u128() as f64\n                };\n                Complex {\n                    re: converted_value,\n                    im: 0.0,\n                }\n            })\n            .collect();\n\n        // Compute the FFT (this gives the eigenvalues of the circulant matrix)\n        fft.process(\u0026mut buffer);\n\n        // Return the maximum absolute value (norm) among the eigenvalues\n        buffer\n            .iter()\n            .map(|c| c.norm())\n            .fold(0.0, |max, x| max.max(x))\n    }\n}\n\nimpl Add\u003c\u0026Rq\u003e for \u0026Rq {\n    type Output = Rq;\n    /// Add two polynomials\n    fn add(self, other: \u0026Rq) -\u003e Rq {\n        let mut coeffs = [Zq::ZERO; Rq::DEGREE];\n        for (r, (a, b)) in coeffs\n            .iter_mut()\n            .zip(self.coeffs.iter().zip(other.coeffs.iter()))\n        {\n            *r = *a + *b;\n        }\n        Rq::new(coeffs)\n    }\n}\n\nimpl Sub\u003c\u0026Rq\u003e for \u0026Rq {\n    type Output = Rq;\n    /// Add two polynomials\n    fn sub(self, other: \u0026Rq) -\u003e Rq {\n        let mut coeffs = [Zq::ZERO; Rq::DEGREE];\n        for (r, (a, b)) in coeffs\n            .iter_mut()\n            .zip(self.coeffs.iter().zip(other.coeffs.iter()))\n        {\n            *r = *a - *b;\n        }\n        Rq::new(coeffs)\n    }\n}\n\nimpl Mul\u003c\u0026Rq\u003e for \u0026Rq {\n    type Output = Rq;\n    /// Polynomial multiplication modulo x^D + 1\n    fn mul(self, other: \u0026Rq) -\u003e Rq {\n        let mut result = [Zq::ZERO; Rq::DEGREE];\n        let mut out_of_field = [Zq::ZERO; Rq::DEGREE];\n        for (i, \u0026self_coeff) in self.coeffs.iter().enumerate() {\n            for (j, \u0026other_coeff) in other.coeffs.iter().enumerate() {\n                if i + j \u003c Rq::DEGREE {\n                    result[i + j] += self_coeff * other_coeff;\n                } else {\n                    out_of_field[(i + j) % Rq::DEGREE] += self_coeff * other_coeff;\n                }\n            }\n        }\n        // Process excess terms with sign adjustment\n        for i in (0..Rq::DEGREE).rev() {\n            result[i] -= out_of_field[i];\n        }\n        Rq::new(result)\n    }\n}\n\nimpl Mul\u003c\u0026Zq\u003e for \u0026Rq {\n    type Output = Rq;\n    /// Scalar multiplication of a polynomial\n    fn mul(self, other: \u0026Zq) -\u003e Rq {\n        let mut copied_coeffs = self.coeffs;\n        for elem in copied_coeffs.iter_mut() {\n            *elem *= *other;\n        }\n        Rq::new(copied_coeffs)\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n\n    pub fn generate_rq_from_zq_vector(vec: Vec\u003cZq\u003e) -\u003e Rq {\n        let mut temp = [Zq::ZERO; Rq::DEGREE];\n        // Process excess terms with sign adjustment\n        for i in (0..vec.len()).rev() {\n            let m = i / Rq::DEGREE;\n            let r = i % Rq::DEGREE;\n            let sign = if m % 2 == 0 { 1 } else { -1 };\n            if sign == 1 {\n                temp[r] += vec[i];\n            } else {\n                temp[r] -= vec[i];\n            }\n        }\n        Rq::new(temp)\n    }\n\n    mod helper {\n        use super::*;\n        pub fn padded(prefix: \u0026[Zq]) -\u003e [Zq; Rq::DEGREE] {\n            assert!(\n                prefix.len() \u003c= Rq::DEGREE,\n                \"too many coefficients for degree {}\",\n                Rq::DEGREE\n            );\n\n            let mut out = [Zq::ZERO; Rq::DEGREE];\n            out[..prefix.len()].copy_from_slice(prefix);\n            out\n        }\n\n        pub fn rq_from(prefix: \u0026[Zq]) -\u003e Rq {\n            Rq {\n                coeffs: padded(prefix),\n            }\n        }\n    }\n\n    // Test new() and polynomial creation\n    #[test]\n    fn test_new_and_create_poly() {\n        let coeffs = [Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)];\n        let poly = helper::rq_from(\u0026coeffs);\n        assert_eq!(poly.coeffs, helper::padded(\u0026coeffs));\n\n        // Direct conversion\n        let coeffs2 = [Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)];\n        let poly_from_vec_direct: Rq = generate_rq_from_zq_vector(coeffs.to_vec());\n        assert_eq!(poly_from_vec_direct.coeffs, helper::padded(\u0026coeffs2));\n    }\n\n    #[test]\n    fn test_into_coeffs_returns_correct() {\n        let mut coeffs = [Zq::ZERO; Rq::DEGREE];\n        coeffs[0] = Zq::ONE;\n        coeffs[0] = Zq::new(20);\n        coeffs[0] = Zq::new(3121);\n        coeffs[0] = Zq::new(40);\n        let poly: Rq = generate_rq_from_zq_vector(coeffs.to_vec());\n\n        let result = Rq::into_coeffs(poly); // or whatever constructor you have\n        assert_eq!(result, coeffs);\n    }\n\n    // Test addition of polynomials\n    #[test]\n    fn test_add() {\n        // Within bounds\n        let poly1: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let poly2: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(4), Zq::new(3), Zq::new(2), Zq::ONE]);\n        let result = \u0026poly1 + \u0026poly2;\n        assert_eq!(\n            result.coeffs,\n            helper::padded(\u0026[Zq::new(5), Zq::new(5), Zq::new(5), Zq::new(5)])\n        );\n\n        // Outside of bounds\n        let poly3: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let poly4: Rq =\n            generate_rq_from_zq_vector(vec![Zq::NEG_ONE, Zq::new(3), Zq::NEG_ONE, Zq::ONE]);\n        let result2 = \u0026poly3 + \u0026poly4;\n        assert_eq!(\n            result2.coeffs,\n            helper::padded(\u0026[Zq::ZERO, Zq::new(5), Zq::new(2), Zq::new(5)])\n        );\n        // Addition with zero polynomial\n        let poly5: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let poly6: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO]);\n        let result3 = \u0026poly5 + \u0026poly6;\n        assert_eq!(\n            result3.coeffs,\n            helper::padded(\u0026[Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)])\n        );\n        // Addition with high coefficients\n        let poly7: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::NEG_ONE]);\n        let poly8: Rq =\n            generate_rq_from_zq_vector(vec![Zq::NEG_ONE, Zq::NEG_ONE, Zq::NEG_ONE, Zq::NEG_ONE]);\n        let result3 = \u0026poly7 + \u0026poly8;\n        assert_eq!(\n            result3.coeffs,\n            helper::padded(\u0026[Zq::ZERO, Zq::ONE, Zq::new(2), -Zq::new(2)])\n        );\n    }\n\n    // Test multiplication of polynomials\n    #[test]\n    fn test_mul() {\n        // Multiplication with wrapping\n        let poly1: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::new(2)]);\n        let poly2: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE]);\n        let result = \u0026poly1 * \u0026poly2;\n        assert_eq!(\n            result.coeffs,\n            helper::padded(\u0026[Zq::new(1), Zq::new(2), Zq::new(3), Zq::new(2)])\n        );\n\n        // Multiplication with zero polynomial\n        let poly3: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::new(2)]);\n        let poly4: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO]);\n        let result2 = \u0026poly3 * \u0026poly4;\n        assert_eq!(\n            result2.coeffs,\n            helper::padded(\u0026[Zq::ZERO, Zq::ZERO, Zq::ZERO])\n        );\n\n        // Needs to be revised later\n        // // Multiplication with wrapping higher order\n        // let poly5: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::new(2)]);\n        // let poly6: Rq = vec![Zq::ONE, Zq::ONE, Zq::new(7), Zq::new(5)].into();\n        // let result3 = poly5 * poly6;\n        // assert_eq!(\n        //     result3.coeffs,\n        //     helper::padded(\u0026[Zq::new(u32::MAX - 12), Zq::new(u32::MAX - 16), Zq::ZERO])\n        // );\n    }\n\n    // Test subtraction of polynomials\n    #[test]\n    fn test_sub() {\n        // within bounds\n        let poly1: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(5), Zq::new(10), Zq::new(15), Zq::new(20)]);\n        let poly2: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(2), Zq::new(4), Zq::new(6), Zq::new(8)]);\n        let result = \u0026poly1 - \u0026poly2;\n        assert_eq!(\n            result.coeffs,\n            helper::padded(\u0026[Zq::new(3), Zq::new(6), Zq::new(9), Zq::new(12)])\n        );\n\n        // Outside of bounds\n        let poly3: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::new(3), Zq::new(2)]);\n        let poly4: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(2), Zq::new(4), Zq::new(6), Zq::new(8)]);\n        let result2 = \u0026poly3 - \u0026poly4;\n        assert_eq!(\n            result2.coeffs,\n            helper::padded(\u0026[\n                Zq::ZERO - Zq::new(1),\n                Zq::ZERO - Zq::new(3),\n                Zq::ZERO - Zq::new(3),\n                Zq::ZERO - Zq::new(6),\n            ])\n        );\n        // Subtraction with zero polynomial\n        let poly5: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let poly6: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO]);\n        let result3 = \u0026poly6 - \u0026poly5;\n        let result4 = \u0026poly5 - \u0026poly6;\n        assert_eq!(\n            result3.coeffs,\n            helper::padded(\u0026[\n                Zq::ZERO - Zq::new(1),\n                Zq::ZERO - Zq::new(2),\n                Zq::ZERO - Zq::new(3),\n                Zq::ZERO - Zq::new(4),\n            ])\n        );\n        assert_eq!(\n            result4.coeffs,\n            helper::padded(\u0026[Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)])\n        );\n    }\n\n    // Test scalar multiplication\n    #[test]\n    fn test_scalar_mul() {\n        let poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let result = \u0026poly * \u0026Zq::new(2);\n        assert_eq!(\n            result.coeffs,\n            helper::padded(\u0026[Zq::new(2), Zq::new(4), Zq::new(6), Zq::new(8)])\n        );\n    }\n\n    // Test coefficient extraction\n    #[test]\n    fn test_get_coefficient() {\n        let poly: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ZERO, Zq::new(5), Zq::NEG_ONE]);\n        let vec = helper::padded(\u0026[Zq::ONE, Zq::ZERO, Zq::new(5), Zq::NEG_ONE]).to_vec();\n        assert!(poly.get_coefficients().to_vec() == vec);\n\n        let poly_zero: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO]);\n        let vec_zero = helper::padded(\u0026[Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO]).to_vec();\n        assert!(poly_zero.get_coefficients().to_vec() == vec_zero);\n    }\n\n    #[test]\n    fn test_base2_decomposition() {\n        // Test case 1: Base 2 decomposition\n        let poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(5), Zq::new(3), Zq::new(7), Zq::new(1)]);\n        let parts = poly.decompose(Zq::TWO, 2);\n\n        // Part 0: remainders mod 2 (no centering needed for base 2)\n        assert_eq!(\n            parts[0].coeffs,\n            helper::padded(\u0026[\n                Zq::ONE, // 5 mod 2 = 1\n                Zq::ONE, // 3 mod 2 = 1\n                Zq::ONE, // 7 mod 2 = 1\n                Zq::ONE, // 1 mod 2 = 1\n            ])\n        );\n\n        // Part 1: quotients after division by 2\n        assert_eq!(\n            parts[1].coeffs,\n            helper::padded(\u0026[\n                Zq::new(2), // 5 div 2 = 2\n                Zq::ONE,    // 3 div 2 = 1\n                Zq::new(3), // 7 div 2 = 3\n                Zq::ZERO,   // 1 div 2 = 0\n            ])\n        );\n\n        // Verify Base 2 reconstruction coefficient by coefficient\n        for i in 0..4 {\n            let expected = poly.coeffs[i];\n            let actual = parts[0].coeffs[i] + parts[1].coeffs[i] * Zq::TWO;\n            assert_eq!(actual, expected, \"Base 2: Coefficient {} mismatch\", i);\n        }\n    }\n\n    #[test]\n    fn test_base3_decomposition() {\n        // Test case: Base 3 decomposition with centering\n        let specific_poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(8), Zq::new(11), Zq::new(4), Zq::new(15)]);\n        let parts = specific_poly.decompose(Zq::new(3), 2);\n\n        // Part 0: centered remainders mod 3\n        assert_eq!(\n            parts[0].coeffs,\n            helper::padded(\u0026[\n                Zq::NEG_ONE, // 8 mod 3 = 2 -\u003e -1 (centered)\n                Zq::NEG_ONE, // 11 mod 3 = 2 -\u003e -1 (centered)\n                Zq::ONE,     // 4 mod 3 = 1 -\u003e 1 (centered)\n                Zq::ZERO,    // 15 mod 3 = 0 -\u003e 0 (centered)\n            ])\n        );\n\n        // Part 1: quotients\n        assert_eq!(\n            parts[1].coeffs,\n            helper::padded(\u0026[\n                Zq::new(3), // (8 + 1) div 3 = 3\n                Zq::new(4), // (11 + 1) div 3 = 4\n                Zq::ONE,    // 4 div 3 = 1\n                Zq::new(5), // 15 div 3 = 5\n            ])\n        );\n\n        // Verify Base 3 reconstruction coefficient by coefficient\n        for i in 0..4 {\n            let expected = specific_poly.coeffs[i];\n            let p0 = parts[0].coeffs[i];\n            let p1 = parts[1].coeffs[i];\n            let actual = p0 + p1 * Zq::new(3);\n            assert_eq!(actual, expected, \"Base 3: Coefficient {} mismatch\", i);\n        }\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        // Test zero polynomial\n        let zero_poly: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO; 4]);\n        let parts = zero_poly.decompose(Zq::TWO, 2);\n        assert!(\n            // Check any polynomial is zero\n            parts\n                .iter()\n                .all(|p| p.get_coefficients().iter().all(|\u0026coeff| coeff == Zq::ZERO)),\n            \"Zero polynomial decomposition failed\"\n        );\n\n        // Test single part decomposition\n        let simple_poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2), Zq::new(3), Zq::new(4)]);\n        let parts = simple_poly.decompose(Zq::TWO, 1);\n        assert_eq!(parts.len(), 1, \"Single part decomposition length incorrect\");\n        assert_eq!(\n            parts[0], simple_poly,\n            \"Single part decomposition value incorrect\"\n        );\n    }\n\n    #[test]\n    fn test_large_base_decomposition() {\n        // Test decomposition with larger bases (8 and 16)\n        let poly: Rq =\n            generate_rq_from_zq_vector(vec![Zq::new(120), Zq::new(33), Zq::new(255), Zq::new(19)]);\n\n        // Base 8 decomposition\n        let parts_base8 = poly.decompose(Zq::new(8), 2);\n\n        // Part 0: centered remainders mod 8\n        assert_eq!(\n            parts_base8[0].coeffs,\n            helper::padded(\u0026[\n                Zq::ZERO,    // 120 mod 8 = 0 -\u003e 0 (centered)\n                Zq::ONE,     // 33 mod 8 = 1 -\u003e 1 (centered)\n                Zq::NEG_ONE, // 255 mod 8 = 7 -\u003e -1 (centered)\n                Zq::new(3),  // 19 mod 8 = 3 -\u003e 3 (centered)\n            ])\n        );\n\n        // Part 1: quotients\n        assert_eq!(\n            parts_base8[1].coeffs,\n            helper::padded(\u0026[\n                Zq::new(15), // 120 div 8 = 15\n                Zq::new(4),  // 33 div 8 = 4\n                Zq::new(32), // (255 + 1) div 8 = 32\n                Zq::new(2),  // 19 div 8 = 2\n            ])\n        );\n\n        // Verify reconstruction coefficient by coefficient\n        for i in 0..4 {\n            let expected = poly.coeffs[i];\n            let p0 = parts_base8[0].coeffs[i];\n            let p1 = parts_base8[1].coeffs[i];\n            let actual = p0 + p1 * Zq::new(8);\n            assert_eq!(actual, expected, \"Base 8: Coefficient {} mismatch\", i);\n        }\n\n        // Base 16 decomposition\n        let parts_base16 = poly.decompose(Zq::new(16), 2);\n\n        // Verify reconstruction for base 16\n        for i in 0..4 {\n            let expected = poly.coeffs[i];\n            let p0 = parts_base16[0].coeffs[i];\n            let p1 = parts_base16[1].coeffs[i];\n            let actual = p0 + p1 * Zq::new(16);\n            assert_eq!(actual, expected, \"Base 16: Coefficient {} mismatch\", i);\n        }\n    }\n\n    #[test]\n    fn test_multi_part_decomposition() {\n        // Test with more than 2 parts\n        let poly: Rq = generate_rq_from_zq_vector(vec![\n            Zq::new(123),\n            Zq::new(456),\n            Zq::new(789),\n            Zq::new(101112),\n        ]);\n\n        // Decompose into 3 parts with base 4\n        let parts = poly.decompose(Zq::new(4), 3);\n        assert_eq!(parts.len(), 3, \"Should have 3 parts\");\n\n        // Test reconstruction with all 3 parts\n        let reconstructed =\n            \u0026(\u0026parts[0] + \u0026(\u0026(\u0026parts[1] * \u0026Zq::new(4)) + \u0026(\u0026parts[2] * \u0026Zq::new(16)))); // 4²\n\n        // Verify reconstruction coefficient by coefficient\n        for i in 0..4 {\n            assert_eq!(\n                reconstructed.coeffs[i], poly.coeffs[i],\n                \"3-part base 4: Coefficient {} mismatch\",\n                i\n            );\n        }\n    }\n\n    #[test]\n    fn test_centering_properties() {\n        // Test that centering works correctly for various values\n        // Using base 5 which has half_base = 2\n        let values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let poly: Rq =\n            generate_rq_from_zq_vector(values.iter().map(|\u0026v| Zq::new(v)).collect::\u003cVec\u003cZq\u003e\u003e());\n\n        let parts = poly.decompose(Zq::new(5), 2);\n\n        // Expected centered values for each coefficient:\n        // 0 mod 5 = 0 -\u003e 0\n        // 1 mod 5 = 1 -\u003e 1\n        // 2 mod 5 = 2 -\u003e 2 (at threshold)\n        // 3 mod 5 = 3 -\u003e -2 (centered)\n        // 4 mod 5 = 4 -\u003e -1 (centered)\n        // 5 mod 5 = 0 -\u003e 0\n        // ... and so on\n        let expected_centered = [\n            Zq::ZERO,    // 0 centered\n            Zq::ONE,     // 1 centered\n            Zq::new(2),  // 2 centered (at threshold)\n            -Zq::new(2), // 3 centered to -2\n            -Zq::ONE,    // 4 centered to -1\n            Zq::ZERO,    // 5 centered\n            Zq::ONE,     // 6 centered\n            Zq::new(2),  // 7 centered\n            -Zq::new(2), // 8 centered to -2\n            -Zq::ONE,    // 9 centered to -1\n            Zq::ZERO,    // 10 centered\n        ];\n\n        for (i, \u0026expected) in expected_centered.iter().enumerate() {\n            assert_eq!(\n                parts[0].coeffs[i], expected,\n                \"Base 5 centering: Coefficient {} incorrectly centered\",\n                i\n            );\n        }\n    }\n\n    #[test]\n    fn test_extreme_values() {\n        // Test with values near the extremes of the Zq range\n        let poly: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::NEG_ONE, -Zq::ONE]);\n\n        // Decompose with base 3\n        let parts = poly.decompose(Zq::new(3), 2);\n\n        // Verify reconstruction\n        let reconstructed = \u0026parts[0] + \u0026(\u0026parts[1] * \u0026Zq::new(3));\n\n        for i in 0..3 {\n            assert_eq!(\n                reconstructed.coeffs[i], poly.coeffs[i],\n                \"Extreme values: Coefficient {} mismatch\",\n                i\n            );\n        }\n\n        // Corrected test for high value divisibility\n        // u32::MAX = 4294967295, which equals 1431655765 * 3 + 0\n        // So u32::MAX mod 3 = 0, which remains 0 (no centering needed)\n        assert_eq!(parts[0].coeffs[1], -Zq::new(1)); // Remainder after division by 3\n        assert_eq!(parts[1].coeffs[1], Zq::ZERO); // Quotient\n\n        // Check u32::MAX - 1 as well\n        // 4294967294 mod 3 = 1, which remains 1 (no centering needed since 1 \u003c= half_base)\n        assert_eq!(parts[0].coeffs[2], Zq::NEG_ONE); // u32::MAX - 1 is the third coefficient\n        assert_eq!(parts[1].coeffs[2], Zq::ZERO); // Should be same quotient\n    }\n\n    #[test]\n    fn test_decomposition_properties() {\n        // Test the algebraic property that all coefficients in first part should be small\n        let poly: Rq = generate_rq_from_zq_vector(vec![\n            Zq::new(100),\n            Zq::new(200),\n            Zq::new(300),\n            Zq::new(400),\n            Zq::new(500),\n            Zq::new(600),\n            Zq::new(700),\n            Zq::new(800),\n        ]);\n\n        for base in [2, 3, 4, 5, 8, 10, 16].iter() {\n            let parts = poly.decompose(Zq::new(*base), 2);\n            let half_base = Zq::new(*base).scale_by(Zq::TWO);\n\n            // Check that all coefficients in first part are properly \"small\"\n            for coeff in parts[0].coeffs.iter() {\n                // In centered representation, all coefficients should be \u003c= half_base\n                let abs_coeff = if *coeff \u003e Zq::new(u32::MAX / 2) {\n                    Zq::ZERO - *coeff // Handle negative values (represented as large positive ones)\n                } else {\n                    *coeff\n                };\n\n                assert!(\n                    abs_coeff \u003c= half_base,\n                    \"Base {}: First part coefficient {} exceeds half-base {}\",\n                    base,\n                    coeff,\n                    half_base\n                );\n            }\n\n            // Verify reconstruction\n            let reconstructed = \u0026parts[0] + \u0026(\u0026parts[1] * \u0026Zq::new(*base));\n            assert_eq!(reconstructed, poly, \"Base {}: Reconstruction failed\", base);\n        }\n    }\n\n    #[test]\n    fn test_conjugate_automorphism() {\n        use crate::core::inner_product::compute_linear_combination;\n\n        let poly1 = helper::rq_from(\u0026[Zq::ONE, Zq::TWO, Zq::new(3)]);\n        let poly2 = helper::rq_from(\u0026[Zq::new(4), Zq::new(5), Zq::new(6)]);\n        let inner_12 =\n            compute_linear_combination(poly1.get_coefficients(), poly2.get_coefficients());\n        let conjugated_1 = poly1.conjugate_automorphism();\n        let inner_conjugated_12 = \u0026conjugated_1 * \u0026poly2;\n\n        assert_eq!(inner_conjugated_12.coeffs.len(), Rq::DEGREE);\n        assert_eq!(inner_conjugated_12.get_coefficients()[0], Zq::new(32));\n        assert_eq!(inner_conjugated_12.get_coefficients()[1], Zq::new(17));\n        assert_eq!(inner_conjugated_12.get_coefficients()[2], Zq::new(6));\n\n        // ct\u003c\\sigma_{-1}(poly1), poly2\u003e ?= \u003cpoly1, poly2\u003e\n        let ct_inner_conjugated_12 = inner_conjugated_12.get_coefficients()[0];\n        assert_eq!(ct_inner_conjugated_12, inner_12);\n    }\n\n    // Test the square of the norm\n    #[test]\n    fn test_norm() {\n        let poly1 = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ZERO, Zq::new(5), Zq::NEG_ONE]);\n        let poly2 = generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::ZERO, Zq::new(5), Zq::ONE]);\n        let poly3 = generate_rq_from_zq_vector(vec![Zq::new(5), Zq::ONE, -Zq::new(6), Zq::ZERO]);\n        let poly4 = Rq::zero();\n\n        assert_eq!(poly1.l2_norm_squared(), Zq::new(27));\n        assert_eq!(poly2.l2_norm_squared(), Zq::new(26));\n        assert_eq!(poly3.l2_norm_squared(), Zq::new(62));\n        assert_eq!(poly4.l2_norm_squared(), Zq::ZERO);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":456582}},{"line":43,"address":[],"length":0,"stats":{"Line":579}},{"line":45,"address":[],"length":0,"stats":{"Line":579}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":279149}},{"line":65,"address":[],"length":0,"stats":{"Line":279149}},{"line":69,"address":[],"length":0,"stats":{"Line":2239}},{"line":70,"address":[],"length":0,"stats":{"Line":2239}},{"line":71,"address":[],"length":0,"stats":{"Line":2239}},{"line":72,"address":[],"length":0,"stats":{"Line":147774}},{"line":77,"address":[],"length":0,"stats":{"Line":4051}},{"line":78,"address":[],"length":0,"stats":{"Line":4051}},{"line":79,"address":[],"length":0,"stats":{"Line":4051}},{"line":80,"address":[],"length":0,"stats":{"Line":263315}},{"line":81,"address":[],"length":0,"stats":{"Line":259264}},{"line":82,"address":[],"length":0,"stats":{"Line":130048}},{"line":84,"address":[],"length":0,"stats":{"Line":129216}},{"line":91,"address":[],"length":0,"stats":{"Line":8150}},{"line":92,"address":[],"length":0,"stats":{"Line":8150}},{"line":94,"address":[],"length":0,"stats":{"Line":529750}},{"line":95,"address":[],"length":0,"stats":{"Line":521600}},{"line":96,"address":[],"length":0,"stats":{"Line":521600}},{"line":104,"address":[],"length":0,"stats":{"Line":117}},{"line":105,"address":[],"length":0,"stats":{"Line":234}},{"line":106,"address":[],"length":0,"stats":{"Line":117}},{"line":107,"address":[],"length":0,"stats":{"Line":117}},{"line":109,"address":[],"length":0,"stats":{"Line":117}},{"line":111,"address":[],"length":0,"stats":{"Line":213}},{"line":113,"address":[],"length":0,"stats":{"Line":13632}},{"line":120,"address":[],"length":0,"stats":{"Line":117}},{"line":121,"address":[],"length":0,"stats":{"Line":117}},{"line":125,"address":[],"length":0,"stats":{"Line":11521}},{"line":126,"address":[],"length":0,"stats":{"Line":11521}},{"line":128,"address":[],"length":0,"stats":{"Line":11521}},{"line":130,"address":[],"length":0,"stats":{"Line":11521}},{"line":131,"address":[],"length":0,"stats":{"Line":11521}},{"line":133,"address":[],"length":0,"stats":{"Line":737344}},{"line":134,"address":[],"length":0,"stats":{"Line":11521}},{"line":135,"address":[],"length":0,"stats":{"Line":11521}},{"line":136,"address":[],"length":0,"stats":{"Line":11521}},{"line":141,"address":[],"length":0,"stats":{"Line":11521}},{"line":152,"address":[],"length":0,"stats":{"Line":156}},{"line":153,"address":[],"length":0,"stats":{"Line":156}},{"line":154,"address":[],"length":0,"stats":{"Line":156}},{"line":155,"address":[],"length":0,"stats":{"Line":156}},{"line":156,"address":[],"length":0,"stats":{"Line":156}},{"line":159,"address":[],"length":0,"stats":{"Line":156}},{"line":161,"address":[],"length":0,"stats":{"Line":10140}},{"line":162,"address":[],"length":0,"stats":{"Line":9984}},{"line":163,"address":[],"length":0,"stats":{"Line":19968}},{"line":164,"address":[],"length":0,"stats":{"Line":3133}},{"line":166,"address":[],"length":0,"stats":{"Line":6851}},{"line":168,"address":[],"length":0,"stats":{"Line":9984}},{"line":169,"address":[],"length":0,"stats":{"Line":9984}},{"line":170,"address":[],"length":0,"stats":{"Line":9984}},{"line":176,"address":[],"length":0,"stats":{"Line":156}},{"line":179,"address":[],"length":0,"stats":{"Line":156}},{"line":181,"address":[],"length":0,"stats":{"Line":10296}},{"line":182,"address":[],"length":0,"stats":{"Line":10296}},{"line":189,"address":[],"length":0,"stats":{"Line":62600}},{"line":190,"address":[],"length":0,"stats":{"Line":62600}},{"line":191,"address":[],"length":0,"stats":{"Line":4069000}},{"line":192,"address":[],"length":0,"stats":{"Line":62600}},{"line":193,"address":[],"length":0,"stats":{"Line":62600}},{"line":197,"address":[],"length":0,"stats":{"Line":62600}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":206,"address":[],"length":0,"stats":{"Line":260}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":17499}},{"line":220,"address":[],"length":0,"stats":{"Line":17499}},{"line":221,"address":[],"length":0,"stats":{"Line":17499}},{"line":222,"address":[],"length":0,"stats":{"Line":1137435}},{"line":223,"address":[],"length":0,"stats":{"Line":71675904}},{"line":224,"address":[],"length":0,"stats":{"Line":36397920}},{"line":225,"address":[],"length":0,"stats":{"Line":36397920}},{"line":227,"address":[],"length":0,"stats":{"Line":35277984}},{"line":232,"address":[],"length":0,"stats":{"Line":1137435}},{"line":235,"address":[],"length":0,"stats":{"Line":17499}},{"line":242,"address":[],"length":0,"stats":{"Line":47358}},{"line":243,"address":[],"length":0,"stats":{"Line":47358}},{"line":244,"address":[],"length":0,"stats":{"Line":3078270}},{"line":247,"address":[],"length":0,"stats":{"Line":47358}}],"covered":86,"coverable":86},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","rq_matrix.rs"],"content":"use crate::{core::inner_product, ring::rq_vector::RqVector};\nuse rand::{CryptoRng, Rng};\nuse std::ops::Mul;\n\nuse super::{rq::Rq, zq::Zq};\n\n/// Matrix of polynomials in Rq\n#[derive(Debug, Clone)]\npub struct RqMatrix {\n    elements: Vec\u003cRqVector\u003e,\n    is_symmetric: bool,\n}\n\nimpl RqMatrix {\n    /// Constructor for the Matrix of polynomials in Rq\n    pub fn new(elements: Vec\u003cRqVector\u003e, is_symmetric: bool) -\u003e Self {\n        RqMatrix {\n            elements,\n            is_symmetric,\n        }\n    }\n\n    pub fn zero(row_len: usize, col_len: usize) -\u003e Self {\n        RqMatrix::new(vec![RqVector::zero(col_len); row_len], false)\n    }\n\n    pub fn symmetric_zero(size: usize) -\u003e Self {\n        Self {\n            elements: (0..size).map(|row| RqVector::zero(row + 1)).collect(),\n            is_symmetric: true,\n        }\n    }\n\n    pub fn get_row_len(\u0026self) -\u003e usize {\n        self.elements.len()\n    }\n\n    pub fn get_col_len(\u0026self) -\u003e usize {\n        let last_row = self.get_row_len() - 1;\n        self.elements[last_row].get_length()\n    }\n\n    pub fn get_cell(\u0026self, row: usize, col: usize) -\u003e \u0026Rq {\n        if !self.is_symmetric || row \u003e= col {\n            \u0026self.elements[row].get_elements()[col]\n        } else {\n            \u0026self.elements[col].get_elements()[row]\n        }\n    }\n\n    pub fn set_sell(\u0026mut self, row: usize, col: usize, value: Rq) {\n        self.elements[row].set(col, value);\n    }\n\n    /// Create a random matrix of polynomials\n    pub fn random\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, row_len: usize, col_len: usize) -\u003e Self {\n        Self {\n            elements: (0..row_len)\n                .map(|_| RqVector::random(rng, col_len))\n                .collect(),\n            is_symmetric: false,\n        }\n    }\n\n    /// Create a random symmetric matrix of polynomials\n    pub fn symmetric_random\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, row_len: usize) -\u003e Self {\n        Self {\n            elements: (0..row_len)\n                .map(|row| RqVector::random(rng, row + 1))\n                .collect(),\n            is_symmetric: true,\n        }\n    }\n\n    pub fn get_elements(\u0026self) -\u003e \u0026[RqVector] {\n        \u0026self.elements\n    }\n\n    pub fn decompose_each_cell(\u0026self, base: Zq, num_parts: usize) -\u003e RqVector {\n        let mut decomposed_vec = Vec::new();\n        for ring_vector in self.get_elements() {\n            for ring in ring_vector.get_elements() {\n                decomposed_vec.extend(ring.decompose(base, num_parts));\n            }\n        }\n        RqVector::new(decomposed_vec)\n    }\n}\n\nimpl FromIterator\u003cRqVector\u003e for RqMatrix {\n    fn from_iter\u003cT: IntoIterator\u003cItem = RqVector\u003e\u003e(iter: T) -\u003e Self {\n        let mut elements = Vec::new();\n        for item in iter {\n            elements.push(item);\n        }\n        RqMatrix::new(elements, false)\n    }\n}\n\n// Implement matrix-vector multiplication for reference to matrix\nimpl Mul\u003c\u0026RqVector\u003e for \u0026RqMatrix {\n    type Output = RqVector;\n\n    fn mul(self, rhs: \u0026RqVector) -\u003e Self::Output {\n        let mut result = RqVector::zero(self.elements.len());\n\n        for (i, row) in self.elements.iter().enumerate() {\n            result.set(\n                i,\n                inner_product::compute_linear_combination(row.get_elements(), rhs.get_elements()),\n            );\n        }\n        result\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use rand::rng;\n\n    use super::*;\n    use crate::ring::rq::tests::generate_rq_from_zq_vector;\n    use crate::ring::rq::Rq;\n    use crate::ring::zq::Zq;\n\n    #[test]\n    #[cfg(not(feature = \"skip-slow-tests\"))]\n    fn rqmatrix_fits_stack() {\n        let mut rng = rand::rng();\n        let _: RqMatrix = RqMatrix::random(\u0026mut rng, 256, 1 \u003c\u003c 10);\n    }\n\n    #[test]\n    fn test_set_sell() {\n        let mut matrix = RqMatrix::zero(10, 18);\n        matrix.set_sell(4, 9, Rq::new([Zq::new(10); Rq::DEGREE]));\n        matrix.set_sell(8, 1, Rq::new([Zq::new(3); Rq::DEGREE]));\n\n        for (i, vector) in matrix.get_elements().iter().enumerate() {\n            for (j, poly) in vector.get_elements().iter().enumerate() {\n                if (i == 4) \u0026\u0026 (j == 9) {\n                    assert_eq!(poly, \u0026Rq::new([Zq::new(10); Rq::DEGREE]))\n                } else if (i == 8) \u0026\u0026 (j == 1) {\n                    assert_eq!(poly, \u0026Rq::new([Zq::new(3); Rq::DEGREE]))\n                } else {\n                    assert_eq!(poly, \u0026Rq::zero())\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn test_symmetric_matrix() {\n        let symmetric_matrix = RqMatrix::symmetric_random(\u0026mut rng(), 12);\n        assert_eq!(symmetric_matrix.get_row_len(), 12);\n        assert_eq!(symmetric_matrix.get_col_len(), 12);\n        for i in 0..symmetric_matrix.get_row_len() {\n            assert_eq!(symmetric_matrix.get_elements()[i].get_length(), i + 1);\n        }\n        for i in 0..symmetric_matrix.get_row_len() {\n            for j in 0..symmetric_matrix.get_col_len() {\n                assert_eq!(\n                    symmetric_matrix.get_cell(i, j),\n                    symmetric_matrix.get_cell(j, i)\n                )\n            }\n        }\n    }\n\n    #[test]\n    fn test_rq_matrix_from_iterator() {\n        let expected = vec![\n            RqVector::random(\u0026mut rng(), 5),\n            RqVector::random(\u0026mut rng(), 5),\n            RqVector::random(\u0026mut rng(), 5),\n            RqVector::random(\u0026mut rng(), 5),\n        ];\n        let polynomial_matrix = expected.clone().into_iter();\n        let result: RqMatrix = polynomial_matrix.collect();\n\n        assert_eq!(result.get_elements(), \u0026expected);\n    }\n\n    #[test]\n    fn test_zero_matrix() {\n        /// Check if Polynomial == 0\n        pub fn is_polynomial_zero(poly: \u0026Rq) -\u003e bool {\n            poly.get_coefficients()\n                .iter()\n                .all(|\u0026coeff| coeff == Zq::ZERO)\n        }\n\n        let matrix = RqMatrix::zero(10, 20);\n        assert_eq!(matrix.get_row_len(), 10);\n        assert_eq!(matrix.get_col_len(), 20);\n        for row in matrix.get_elements() {\n            for cell in row.get_elements() {\n                assert!(is_polynomial_zero(cell));\n            }\n        }\n    }\n\n    #[test]\n    fn test_rqmartrix_mul() {\n        let poly1: Rq = generate_rq_from_zq_vector(vec![Zq::new(8), Zq::new(6)]);\n        let poly2: Rq = generate_rq_from_zq_vector(vec![-Zq::new(5), -Zq::new(5)]);\n        let poly3: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ZERO]);\n        let poly4: Rq = generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::new(4)]);\n        let matrix_1: RqMatrix = RqMatrix::new(vec![RqVector::from(vec![poly1, poly2])], false);\n        let vec_1: RqVector = RqVector::from(vec![poly3, poly4]);\n\n        let result_1 = matrix_1.mul(\u0026vec_1);\n        let expected_poly_1 =\n            generate_rq_from_zq_vector(vec![Zq::new(8), -Zq::new(14), -Zq::new(20)]);\n        let expected_1 = RqVector::from(vec![expected_poly_1]);\n        assert_eq!(result_1, expected_1);\n\n        let poly5: Rq = generate_rq_from_zq_vector(vec![-Zq::new(7), Zq::new(7)]);\n        let poly6: Rq = generate_rq_from_zq_vector(vec![-Zq::new(3), Zq::ZERO]);\n        let poly7: Rq = generate_rq_from_zq_vector(vec![Zq::new(8), -Zq::new(2)]);\n        let poly8: Rq = generate_rq_from_zq_vector(vec![-Zq::new(4), Zq::new(4)]);\n        let poly9: Rq = generate_rq_from_zq_vector(vec![Zq::NEG_ONE, -Zq::new(2)]);\n        let poly10: Rq = generate_rq_from_zq_vector(vec![-Zq::new(3), -Zq::new(3)]);\n        let matrix_2: RqMatrix = RqMatrix::new(\n            vec![\n                RqVector::from(vec![poly5, poly6]),\n                RqVector::from(vec![poly7, poly8]),\n            ],\n            false,\n        );\n        let vec_2: RqVector = RqVector::from(vec![poly9, poly10]);\n\n        let result_2 = matrix_2.mul(\u0026vec_2);\n        let expected_poly_2_1 =\n            generate_rq_from_zq_vector(vec![Zq::new(16), Zq::new(16), -Zq::new(14)]);\n        let expected_poly_2_2 =\n            generate_rq_from_zq_vector(vec![Zq::new(4), -Zq::new(14), -Zq::new(8)]);\n        let expected_2 = RqVector::from(vec![expected_poly_2_1, expected_poly_2_2]);\n        assert_eq!(result_2, expected_2);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":102}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":6}},{"line":29,"address":[],"length":0,"stats":{"Line":30}},{"line":34,"address":[],"length":0,"stats":{"Line":382}},{"line":35,"address":[],"length":0,"stats":{"Line":382}},{"line":38,"address":[],"length":0,"stats":{"Line":255}},{"line":39,"address":[],"length":0,"stats":{"Line":255}},{"line":40,"address":[],"length":0,"stats":{"Line":255}},{"line":43,"address":[],"length":0,"stats":{"Line":729}},{"line":44,"address":[],"length":0,"stats":{"Line":1458}},{"line":45,"address":[],"length":0,"stats":{"Line":498}},{"line":47,"address":[],"length":0,"stats":{"Line":231}},{"line":51,"address":[],"length":0,"stats":{"Line":80}},{"line":52,"address":[],"length":0,"stats":{"Line":80}},{"line":56,"address":[],"length":0,"stats":{"Line":6}},{"line":58,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":21}},{"line":68,"address":[],"length":0,"stats":{"Line":21}},{"line":75,"address":[],"length":0,"stats":{"Line":88}},{"line":76,"address":[],"length":0,"stats":{"Line":88}},{"line":79,"address":[],"length":0,"stats":{"Line":9}},{"line":80,"address":[],"length":0,"stats":{"Line":9}},{"line":81,"address":[],"length":0,"stats":{"Line":36}},{"line":82,"address":[],"length":0,"stats":{"Line":72}},{"line":86,"address":[],"length":0,"stats":{"Line":9}},{"line":91,"address":[],"length":0,"stats":{"Line":42}},{"line":92,"address":[],"length":0,"stats":{"Line":42}},{"line":93,"address":[],"length":0,"stats":{"Line":15012}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":42}},{"line":104,"address":[],"length":0,"stats":{"Line":225}},{"line":105,"address":[],"length":0,"stats":{"Line":225}},{"line":107,"address":[],"length":0,"stats":{"Line":1957}},{"line":113,"address":[],"length":0,"stats":{"Line":225}}],"covered":35,"coverable":36},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","rq_vector.rs"],"content":"use crate::ring::rq::Rq;\nuse crate::ring::zq::Zq;\nuse core::ops::Mul;\nuse rand::{CryptoRng, Rng};\nuse std::ops::Add;\n\n/// Vector of polynomials in Rq\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RqVector {\n    elements: Vec\u003cRq\u003e,\n}\n\nimpl RqVector {\n    pub fn new(elements: Vec\u003cRq\u003e) -\u003e Self {\n        Self { elements }\n    }\n\n    pub fn new_from_zq_vector(elements: Vec\u003cZq\u003e) -\u003e Self {\n        let mut result = Vec::new();\n        debug_assert!(elements.len() % Rq::DEGREE == 0);\n        elements.chunks_exact(Rq::DEGREE).for_each(|chunk| {\n            result.push(Rq::new(chunk.try_into().unwrap()));\n        });\n\n        RqVector { elements: result }\n    }\n\n    /// Create a zero vector\n    pub fn zero(length: usize) -\u003e Self {\n        Self {\n            elements: vec![Rq::zero(); length],\n        }\n    }\n\n    pub fn set(\u0026mut self, index: usize, val: Rq) {\n        self.elements[index] = val;\n    }\n\n    pub fn get_length(\u0026self) -\u003e usize {\n        self.elements.len()\n    }\n\n    pub fn get_elements(\u0026self) -\u003e \u0026Vec\u003cRq\u003e {\n        \u0026self.elements\n    }\n\n    /// Create a random vector\n    pub fn random\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, length: usize) -\u003e Self {\n        Self {\n            elements: (0..length).map(|_| Rq::random(rng)).collect(),\n        }\n    }\n\n    pub fn random_with_bound\u003cR: Rng + CryptoRng\u003e(rng: \u0026mut R, length: usize, bound: u32) -\u003e Self {\n        Self {\n            elements: (0..length)\n                .map(|_| Rq::random_with_bound(rng, bound))\n                .collect(),\n        }\n    }\n\n    /// Function to concatenate coefficients from multiple Rq into a Vec\u003cZq\u003e\n    pub fn concatenate_coefficients(\u0026self) -\u003e Vec\u003cZq\u003e {\n        let total_coeffs = self.elements.len() * Rq::DEGREE;\n        let mut concatenated_coeffs: Vec\u003cZq\u003e = Vec::with_capacity(total_coeffs);\n        // Iterate over each Rq, extracting the coefficients and concatenating them\n        for rq in \u0026self.elements {\n            let coeffs = rq.get_coefficients();\n            concatenated_coeffs.extend_from_slice(coeffs);\n        }\n        concatenated_coeffs\n    }\n\n    // Compute the squared norm of a vector of polynomials\n    pub fn l2_norm_squared(\u0026self) -\u003e Zq {\n        self.elements\n            .iter()\n            .map(|poly| poly.l2_norm_squared()) // Collect coefficients from all polynomials\n            .sum()\n    }\n\n    pub fn decompose(\u0026self, b: Zq, parts: usize) -\u003e Vec\u003cRqVector\u003e {\n        self.get_elements()\n            .iter()\n            .map(|i| RqVector::new(Rq::decompose(i, b, parts)))\n            .collect()\n    }\n}\n\nimpl Add\u003c\u0026RqVector\u003e for \u0026RqVector {\n    type Output = RqVector;\n    // add two poly vectors\n    fn add(self, other: \u0026RqVector) -\u003e RqVector {\n        self.get_elements()\n            .iter()\n            .zip(other.get_elements())\n            .map(|(a, b)| a + b)\n            .collect()\n    }\n}\n\nimpl FromIterator\u003cRq\u003e for RqVector {\n    fn from_iter\u003cT: IntoIterator\u003cItem = Rq\u003e\u003e(iter: T) -\u003e Self {\n        let mut elements = Vec::new();\n        for item in iter {\n            elements.push(item);\n        }\n        RqVector::new(elements)\n    }\n}\n\n/// Create a new vector from a `Vec` of elements\nimpl From\u003cVec\u003cRq\u003e\u003e for RqVector {\n    fn from(elements: Vec\u003cRq\u003e) -\u003e Self {\n        Self { elements }\n    }\n}\n\nimpl Mul\u003c\u0026Rq\u003e for \u0026RqVector {\n    type Output = RqVector;\n    // A poly vector multiple by a PolyRing\n    fn mul(self, other: \u0026Rq) -\u003e RqVector {\n        self.get_elements().iter().map(|s| s * other).collect()\n    }\n}\n\nimpl Mul\u003c\u0026Zq\u003e for \u0026RqVector {\n    type Output = RqVector;\n    // A poly vector multiple by a PolyRing\n    fn mul(self, other: \u0026Zq) -\u003e RqVector {\n        self.get_elements().iter().map(|s| s * other).collect()\n    }\n}\n\nimpl Mul\u003cZq\u003e for \u0026RqVector {\n    type Output = RqVector;\n    // A poly vector multiple by a PolyRing\n    fn mul(self, other: Zq) -\u003e RqVector {\n        self.get_elements().iter().map(|s| s * \u0026other).collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use rand::rng;\n\n    use super::*;\n    use crate::{core::inner_product, ring::rq::tests::generate_rq_from_zq_vector};\n\n    #[test]\n    fn test_rqvector_from_iterator() {\n        let expected = vec![\n            Rq::random(\u0026mut rng()),\n            Rq::random(\u0026mut rng()),\n            Rq::random(\u0026mut rng()),\n        ];\n        let vector_of_polynomials = expected.clone().into_iter();\n        let result: RqVector = vector_of_polynomials.collect();\n\n        assert_eq!(result.get_elements(), \u0026expected);\n    }\n\n    #[test]\n    fn test_rq_vector_multiplication_with_zq() {\n        let poly1: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(22)]);\n        let poly2: Rq = generate_rq_from_zq_vector(vec![Zq::new(17), Zq::new(12)]);\n        let rq_vector = RqVector::from(vec![poly1, poly2]);\n        let result = \u0026rq_vector * Zq::new(3);\n\n        assert_eq!(\n            result.get_elements()[0],\n            generate_rq_from_zq_vector(vec![Zq::new(3), Zq::new(66)])\n        );\n        assert_eq!(\n            result.get_elements()[1],\n            generate_rq_from_zq_vector(vec![Zq::new(51), Zq::new(36)])\n        );\n\n        #[allow(clippy::op_ref)]\n        let result2 = \u0026rq_vector * \u0026Zq::new(3);\n        assert_eq!(\n            result2.get_elements()[0],\n            generate_rq_from_zq_vector(vec![Zq::new(3), Zq::new(66)])\n        );\n        assert_eq!(\n            result2.get_elements()[1],\n            generate_rq_from_zq_vector(vec![Zq::new(51), Zq::new(36)])\n        );\n    }\n\n    #[test]\n    fn test_rqvector_mul() {\n        let poly1: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(2)]);\n        let poly2: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::new(4)]);\n        let vec_1: RqVector = RqVector::from(vec![poly1]);\n        let vec_2: RqVector = RqVector::from(vec![poly2]);\n        let result =\n            inner_product::compute_linear_combination(vec_1.get_elements(), vec_2.get_elements());\n        let poly_exp: Rq = generate_rq_from_zq_vector(vec![Zq::new(1), Zq::new(6), Zq::new(8)]);\n        assert_eq!(result, poly_exp);\n\n        let poly3: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let poly4: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let vec_3: RqVector = RqVector::from(vec![poly3]);\n        let vec_4: RqVector = RqVector::from(vec![poly4]);\n        let result_1 =\n            inner_product::compute_linear_combination(vec_3.get_elements(), vec_4.get_elements());\n        let poly_exp_1: Rq = generate_rq_from_zq_vector(vec![\n            Zq::new(1),\n            Zq::new(2),\n            Zq::new(3),\n            Zq::new(4),\n            Zq::new(3),\n            Zq::new(2),\n            Zq::new(1),\n        ]);\n        assert_eq!(result_1, poly_exp_1);\n\n        let poly5: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let poly6: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let poly7: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let poly8: Rq = generate_rq_from_zq_vector(vec![Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE]);\n        let vec_5: RqVector = RqVector::from(vec![poly5, poly6]);\n        let vec_6: RqVector = RqVector::from(vec![poly7, poly8]);\n        let result_2 =\n            inner_product::compute_linear_combination(vec_5.get_elements(), vec_6.get_elements());\n        let poly_exp_2: Rq = generate_rq_from_zq_vector(vec![\n            Zq::new(2),\n            Zq::new(4),\n            Zq::new(6),\n            Zq::new(8),\n            Zq::new(6),\n            Zq::new(4),\n            Zq::new(2),\n        ]);\n        assert_eq!(result_2, poly_exp_2);\n    }\n\n    // Test the square of the norm\n    #[test]\n    fn test_norm() {\n        let poly1 = generate_rq_from_zq_vector(vec![\n            Zq::ONE,\n            Zq::ZERO,\n            Zq::new(5),\n            Zq::NEG_ONE - Zq::new(1),\n        ]);\n        let poly2 = generate_rq_from_zq_vector(vec![Zq::ZERO, Zq::ZERO, Zq::new(5), Zq::ONE]);\n        let poly_vec1: RqVector = vec![poly1.clone(), poly2.clone()].into();\n        assert_eq!(\n            poly_vec1.l2_norm_squared(),\n            poly1.l2_norm_squared() + poly2.l2_norm_squared()\n        );\n\n        let zero_vec: RqVector = RqVector::zero(4);\n        assert_eq!(zero_vec.l2_norm_squared(), Zq::ZERO);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":21449}},{"line":18,"address":[],"length":0,"stats":{"Line":5120}},{"line":19,"address":[],"length":0,"stats":{"Line":5120}},{"line":20,"address":[],"length":0,"stats":{"Line":10240}},{"line":21,"address":[],"length":0,"stats":{"Line":320000}},{"line":22,"address":[],"length":0,"stats":{"Line":314880}},{"line":29,"address":[],"length":0,"stats":{"Line":253}},{"line":31,"address":[],"length":0,"stats":{"Line":253}},{"line":35,"address":[],"length":0,"stats":{"Line":1813}},{"line":36,"address":[],"length":0,"stats":{"Line":1813}},{"line":39,"address":[],"length":0,"stats":{"Line":598}},{"line":40,"address":[],"length":0,"stats":{"Line":598}},{"line":43,"address":[],"length":0,"stats":{"Line":36040}},{"line":44,"address":[],"length":0,"stats":{"Line":36040}},{"line":48,"address":[],"length":0,"stats":{"Line":209}},{"line":50,"address":[],"length":0,"stats":{"Line":1513}},{"line":54,"address":[],"length":0,"stats":{"Line":109}},{"line":56,"address":[],"length":0,"stats":{"Line":109}},{"line":63,"address":[],"length":0,"stats":{"Line":2055}},{"line":64,"address":[],"length":0,"stats":{"Line":2055}},{"line":65,"address":[],"length":0,"stats":{"Line":2055}},{"line":67,"address":[],"length":0,"stats":{"Line":532045}},{"line":71,"address":[],"length":0,"stats":{"Line":2055}},{"line":75,"address":[],"length":0,"stats":{"Line":241}},{"line":76,"address":[],"length":0,"stats":{"Line":241}},{"line":78,"address":[],"length":0,"stats":{"Line":8626}},{"line":82,"address":[],"length":0,"stats":{"Line":10}},{"line":83,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":49}},{"line":93,"address":[],"length":0,"stats":{"Line":9441}},{"line":94,"address":[],"length":0,"stats":{"Line":9441}},{"line":96,"address":[],"length":0,"stats":{"Line":9441}},{"line":97,"address":[],"length":0,"stats":{"Line":66085}},{"line":103,"address":[],"length":0,"stats":{"Line":21297}},{"line":104,"address":[],"length":0,"stats":{"Line":21297}},{"line":105,"address":[],"length":0,"stats":{"Line":235947}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":21297}},{"line":114,"address":[],"length":0,"stats":{"Line":117}},{"line":122,"address":[],"length":0,"stats":{"Line":90}},{"line":123,"address":[],"length":0,"stats":{"Line":627}},{"line":130,"address":[],"length":0,"stats":{"Line":9397}},{"line":131,"address":[],"length":0,"stats":{"Line":65776}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":4}}],"covered":44,"coverable":45},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","ring","zq.rs"],"content":"use core::ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign};\nuse rand::distr::uniform::{Error, SampleBorrow, SampleUniform, UniformInt, UniformSampler};\nuse rand::prelude::*;\nuse std::fmt;\nuse std::iter::Sum;\n/// Represents an element in the ring Z/qZ where q = 2^32.\n/// Uses native u32 operations with automatic modulo reduction through wrapping arithmetic.\n#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Default)]\npub struct Zq {\n    /// Stored value is always in [0, q-1] due to u32's wrapping behavior\n    value: u32,\n}\n\nimpl Zq {\n    /// Modulus q = 2^32 - 1\n    #[allow(clippy::as_conversions)]\n    pub const Q: u64 = u32::MAX as u64;\n    /// Zero element (additive identity)\n    pub const ZERO: Self = Self::new(0);\n    /// Multiplicative identity\n    pub const ONE: Self = Self::new(1);\n    /// Two\n    pub const TWO: Self = Self::new(2);\n    /// Maximum element\n    pub const NEG_ONE: Self = Self::new(u32::MAX - 1);\n\n    /// Creates a new Zq element from a raw u32 value.\n    /// No explicit modulo needed as u32 automatically wraps\n    pub const fn new(value: u32) -\u003e Self {\n        Self { value }\n    }\n\n    pub fn to_u128(\u0026self) -\u003e u128 {\n        u128::from(self.value)\n    }\n\n    pub const fn is_zero(\u0026self) -\u003e bool {\n        self.value == 0\n    }\n\n    pub fn get_value(\u0026self) -\u003e u32 {\n        self.value\n    }\n\n    /// Returns the centered representative modulo the given bound\n    /// Result is guaranteed to be in (-bound/2, bound/2]\n    ///\n    /// # Panics\n    ///\n    /// Panics if `bound` is zero.\n    pub(crate) fn centered_mod(\u0026self, bound: Self) -\u003e Self {\n        assert!(\n            bound != Zq::ZERO,\n            \"cannot get centered representative modulo for zero bound\"\n        );\n        let bounded_coeff = Self::new(self.value % bound.value);\n        let half_bound = bound.scale_by(Self::TWO);\n\n        if bounded_coeff \u003e half_bound {\n            bounded_coeff - bound\n        } else {\n            bounded_coeff\n        }\n    }\n\n    /// Scales by other Zq.\n    ///\n    /// Effectively it is a floor division of internal values.\n    /// But for the ring of integers there is no defined division\n    /// operation.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `bound` is zero.\n    pub(crate) fn scale_by(\u0026self, rhs: Self) -\u003e Self {\n        assert!(rhs != Zq::ZERO, \"cannot scale by zero\");\n        Self::new(self.value / rhs.value)\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn add_op(self, rhs: Zq) -\u003e Zq {\n        let sum = (self.value as u64 + rhs.value as u64) % Zq::Q;\n        Zq::new(sum as u32)\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn sub_op(self, rhs: Zq) -\u003e Zq {\n        let sub = (self.value as u64 + Zq::Q - rhs.value as u64) % Zq::Q;\n        Zq::new(sub as u32)\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn mul_op(self, b: Zq) -\u003e Zq {\n        let prod = (self.value as u64 * b.value as u64) % Zq::Q;\n        Zq::new(prod as u32)\n    }\n}\n\n// Macro to generate arithmetic trait implementations\nmacro_rules! impl_arithmetic {\n    ($trait:ident, $assign_trait:ident, $method:ident, $assign_method:ident, $op:ident) =\u003e {\n        impl $trait for Zq {\n            type Output = Self;\n\n            fn $method(self, rhs: Self) -\u003e Self::Output {\n                self.$op(rhs)\n            }\n        }\n\n        impl $assign_trait for Zq {\n            fn $assign_method(\u0026mut self, rhs: Self) {\n                *self = self.$op(rhs);\n            }\n        }\n\n        impl $trait\u003cZq\u003e for \u0026Zq {\n            type Output = Zq;\n\n            fn $method(self, rhs: Zq) -\u003e Self::Output {\n                self.$op(rhs)\n            }\n        }\n\n        impl $trait\u003c\u0026Zq\u003e for \u0026Zq {\n            type Output = Zq;\n\n            fn $method(self, rhs: \u0026Zq) -\u003e Self::Output {\n                self.$op(*rhs)\n            }\n        }\n    };\n}\n\nimpl_arithmetic!(Add, AddAssign, add, add_assign, add_op);\nimpl_arithmetic!(Sub, SubAssign, sub, sub_assign, sub_op);\nimpl_arithmetic!(Mul, MulAssign, mul, mul_assign, mul_op);\n\n// Implement the Neg trait for Zq.\nimpl Neg for Zq {\n    type Output = Zq;\n\n    /// Returns the additive inverse of the field element.\n    ///\n    /// Wrap around (q - a) mod q.\n    fn neg(self) -\u003e Zq {\n        // If the value is zero, its inverse is itself.\n        if self.value == 0 {\n            self\n        } else {\n            #[allow(clippy::as_conversions)]\n            Zq::new(Zq::Q as u32 - self.get_value())\n        }\n    }\n}\n\nimpl fmt::Display for Zq {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        // Shows value with modulus for clarity\n        write!(f, \"{} (mod {})\", self.value, Zq::Q)\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\npub struct UniformZq(UniformInt\u003cu32\u003e);\n\nimpl UniformSampler for UniformZq {\n    type X = Zq;\n\n    fn new\u003cB1, B2\u003e(low: B1, high: B2) -\u003e Result\u003cSelf, Error\u003e\n    where\n        B1: SampleBorrow\u003cSelf::X\u003e + Sized,\n        B2: SampleBorrow\u003cSelf::X\u003e + Sized,\n    {\n        UniformInt::\u003cu32\u003e::new(low.borrow().value, high.borrow().value).map(UniformZq)\n    }\n    fn new_inclusive\u003cB1, B2\u003e(low: B1, high: B2) -\u003e Result\u003cSelf, Error\u003e\n    where\n        B1: SampleBorrow\u003cSelf::X\u003e + Sized,\n        B2: SampleBorrow\u003cSelf::X\u003e + Sized,\n    {\n        UniformInt::\u003cu32\u003e::new_inclusive(low.borrow().value, high.borrow().value).map(UniformZq)\n    }\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e Self::X {\n        Self::X::new(self.0.sample(rng))\n    }\n}\n\nimpl SampleUniform for Zq {\n    type Sampler = UniformZq;\n}\n\nimpl Sum for Zq {\n    // Accumulate using the addition operator\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\n    where\n        I: Iterator\u003cItem = Zq\u003e,\n    {\n        iter.fold(Zq::ZERO, |acc, x| acc + x)\n    }\n}\n\npub fn add_assign_two_zq_vectors(first: \u0026mut [Zq], second: Vec\u003cZq\u003e) {\n    first\n        .iter_mut()\n        .zip(second)\n        .for_each(|(first_coeff, second_coeff)| *first_coeff += second_coeff);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_basic_arithmetic() {\n        let a = Zq::new(5);\n        let b = Zq::new(3);\n\n        // Addition\n        assert_eq!((a + b).value, 8, \"5 + 3 should be 8\");\n        // Subtraction\n        assert_eq!((a - b).value, 2, \"5 - 3 should be 2\");\n        // Multiplication\n        assert_eq!((a * b).value, 15, \"5 * 3 should be 15\");\n    }\n\n    #[test]\n    fn test_wrapping_arithmetic() {\n        let a = Zq::NEG_ONE;\n        let b = Zq::ONE;\n\n        assert_eq!((a + b).value, 0, \"u32::MAX + 1 should wrap to 0\");\n        assert_eq!((b - a).value, 2, \"1 - u32::MAX should wrap to 2 (mod 2^32)\");\n    }\n\n    #[test]\n    fn test_subtraction_edge_cases() {\n        let max = Zq::NEG_ONE;\n        let one = Zq::ONE;\n        let two = Zq::TWO;\n\n        assert_eq!((one - max).value, 2);\n        assert_eq!((two - max).value, 3);\n        assert_eq!((max - max).value, 0);\n    }\n\n    #[test]\n    fn test_multiplication_wrapping() {\n        let a = Zq::new(1 \u003c\u003c 31);\n        let two = Zq::TWO;\n\n        // Multiplication wraps when exceeding u32 range\n        assert_eq!((a * two).value, 1, \"2^31 * 2 should wrap to 1\");\n    }\n\n    #[test]\n    fn test_assignment_operators() {\n        let mut a = Zq::new(5);\n        let b = Zq::new(3);\n\n        a += b;\n        assert_eq!(a.value, 8, \"5 += 3 should be 8\");\n\n        a -= b;\n        assert_eq!(a.value, 5, \"8 -= 3 should be 5\");\n\n        a *= b;\n        assert_eq!(a.value, 15, \"5 *= 3 should be 15\");\n    }\n\n    #[test]\n    fn test_conversion_from_u32() {\n        let a: Zq = Zq::new(5);\n        assert_eq!(a.value, 5, \"Conversion from u32 should preserve value\");\n    }\n\n    #[test]\n    fn test_negative_arithmetic() {\n        let small = Zq::new(3);\n        let large = Zq::new(5);\n\n        // Test underflow handling (3 - 5 in u32 terms)\n        let result = small - large;\n        assert_eq!(result.value, u32::MAX - 2, \"3 - 5 should wrap to 2^32 - 2\");\n\n        // Test compound negative operations\n        let mut x = Zq::new(10);\n        x -= Zq::new(15);\n        assert_eq!(x.value, u32::MAX - 5, \"10 -= 15 should wrap to 2^32 - 5\");\n\n        // Test negative equivalent value in multiplication\n        let a = Zq::NEG_ONE; // Represents -1 in mod 2^32 arithmetic\n        let b = Zq::TWO;\n        assert_eq!(\n            (a * b).value,\n            u32::MAX - 2,\n            \"(-1) * 2 should be -2 ≡ 2^32 - 2\"\n        );\n    }\n\n    #[test]\n    fn test_display_implementation() {\n        let a = Zq::new(5);\n        let max = Zq::NEG_ONE;\n        assert_eq!(format!(\"{}\", a), format!(\"5 (mod {})\", Zq::Q));\n        assert_eq!(format!(\"{}\", max), format!(\"4294967294 (mod {})\", Zq::Q));\n    }\n\n    #[test]\n    fn test_maximum_element() {\n        dbg!(Zq::NEG_ONE);\n        dbg!(Zq::ZERO);\n        dbg!(Zq::ONE);\n        dbg!(Zq::ZERO - Zq::ONE);\n        assert_eq!(Zq::NEG_ONE, Zq::ZERO - Zq::ONE);\n    }\n\n    #[test]\n    fn test_ord() {\n        let a = Zq::new(100);\n        let b = Zq::new(200);\n        let c = Zq::new(100);\n        let d = Zq::new(400);\n\n        let res_1 = a.cmp(\u0026b);\n        let res_2 = a.cmp(\u0026c);\n        let res_3 = d.cmp(\u0026b);\n        assert!(res_1.is_lt());\n        assert!(res_2.is_eq());\n        assert!(res_3.is_gt());\n        assert_eq!(a, c);\n        assert!(a \u003c b);\n        assert!(d \u003e b);\n    }\n\n    #[test]\n    fn test_neg() {\n        let a = Zq::new(100);\n        let b = Zq::ZERO;\n        let neg_a: Zq = -a;\n        let neg_b: Zq = -b;\n\n        assert_eq!(neg_a + a, Zq::ZERO);\n        assert_eq!(neg_b, Zq::ZERO);\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":179002434}},{"line":33,"address":[],"length":0,"stats":{"Line":13153}},{"line":34,"address":[],"length":0,"stats":{"Line":13153}},{"line":37,"address":[],"length":0,"stats":{"Line":19}},{"line":38,"address":[],"length":0,"stats":{"Line":19}},{"line":41,"address":[],"length":0,"stats":{"Line":55699572}},{"line":42,"address":[],"length":0,"stats":{"Line":55699572}},{"line":51,"address":[],"length":0,"stats":{"Line":1057344}},{"line":52,"address":[],"length":0,"stats":{"Line":1057344}},{"line":53,"address":[],"length":0,"stats":{"Line":1057344}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":1057344}},{"line":57,"address":[],"length":0,"stats":{"Line":1057344}},{"line":59,"address":[],"length":0,"stats":{"Line":1057344}},{"line":60,"address":[],"length":0,"stats":{"Line":526304}},{"line":62,"address":[],"length":0,"stats":{"Line":531040}},{"line":75,"address":[],"length":0,"stats":{"Line":1080967}},{"line":76,"address":[],"length":0,"stats":{"Line":1080967}},{"line":77,"address":[],"length":0,"stats":{"Line":1080967}},{"line":81,"address":[],"length":0,"stats":{"Line":76789307}},{"line":82,"address":[],"length":0,"stats":{"Line":76789307}},{"line":83,"address":[],"length":0,"stats":{"Line":76789307}},{"line":87,"address":[],"length":0,"stats":{"Line":1660152}},{"line":88,"address":[],"length":0,"stats":{"Line":1660152}},{"line":89,"address":[],"length":0,"stats":{"Line":1660152}},{"line":93,"address":[],"length":0,"stats":{"Line":76529850}},{"line":94,"address":[],"length":0,"stats":{"Line":76529850}},{"line":95,"address":[],"length":0,"stats":{"Line":76529850}},{"line":105,"address":[],"length":0,"stats":{"Line":78421585}},{"line":106,"address":[],"length":0,"stats":{"Line":78421585}},{"line":111,"address":[],"length":0,"stats":{"Line":75828587}},{"line":112,"address":[],"length":0,"stats":{"Line":75828587}},{"line":119,"address":[],"length":0,"stats":{"Line":725823}},{"line":120,"address":[],"length":0,"stats":{"Line":725823}},{"line":127,"address":[],"length":0,"stats":{"Line":3314}},{"line":128,"address":[],"length":0,"stats":{"Line":3314}},{"line":145,"address":[],"length":0,"stats":{"Line":133025}},{"line":147,"address":[],"length":0,"stats":{"Line":133025}},{"line":148,"address":[],"length":0,"stats":{"Line":205}},{"line":151,"address":[],"length":0,"stats":{"Line":132820}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":6297}},{"line":181,"address":[],"length":0,"stats":{"Line":6297}},{"line":183,"address":[],"length":0,"stats":{"Line":402928}},{"line":184,"address":[],"length":0,"stats":{"Line":402928}},{"line":194,"address":[],"length":0,"stats":{"Line":10188}},{"line":198,"address":[],"length":0,"stats":{"Line":1123836}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":6}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":206,"address":[],"length":0,"stats":{"Line":1548}}],"covered":51,"coverable":54},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","mod.rs"],"content":"pub mod sponges;\nuse crate::{\n    core::jl::Projection,\n    ring::{rq::Rq, rq_matrix::RqMatrix, rq_vector::RqVector, zq::Zq},\n};\npub use sponges::Sponge;\n\npub struct LabradorTranscript\u003cS: Sponge\u003e {\n    sponge: S,\n    pub u1: RqVector,\n    pub vector_p: Vec\u003cZq\u003e,\n    pub b_ct_aggr: RqVector,\n    pub u2: RqVector,\n    pub z: RqVector,\n    pub t: RqMatrix,\n    pub g: RqMatrix,\n    pub h: RqMatrix,\n}\n\nimpl\u003cS: Sponge\u003e LabradorTranscript\u003cS\u003e {\n    pub fn new(sponge: S) -\u003e Self {\n        Self {\n            sponge,\n            u1: RqVector::new(Vec::new()),\n            vector_p: Vec::new(),\n            b_ct_aggr: RqVector::new(Vec::new()),\n            u2: RqVector::new(Vec::new()),\n            z: RqVector::new(Vec::new()),\n            t: RqMatrix::new(vec![RqVector::new(Vec::new())], false),\n            g: RqMatrix::new(vec![RqVector::new(Vec::new())], true),\n            h: RqMatrix::new(vec![RqVector::new(Vec::new())], true),\n        }\n    }\n\n    pub fn set_u1(\u0026mut self, u1: RqVector) {\n        self.absorb_u1(\u0026u1);\n        self.u1 = u1;\n    }\n\n    pub fn absorb_u1(\u0026mut self, u1: \u0026RqVector) {\n        self.sponge.absorb_rq(u1.get_elements());\n    }\n\n    pub fn set_vector_p(\u0026mut self, p: Vec\u003cZq\u003e) {\n        self.absorb_vector_p(\u0026p);\n        self.vector_p = p;\n    }\n\n    pub fn absorb_vector_p(\u0026mut self, p: \u0026[Zq]) {\n        self.sponge.absorb_zq(p);\n    }\n\n    pub fn set_vector_b_ct_aggr(\u0026mut self, input: RqVector) {\n        self.absorb_vector_b_ct_aggr(\u0026input);\n        self.b_ct_aggr = input;\n    }\n\n    pub fn absorb_vector_b_ct_aggr(\u0026mut self, input: \u0026RqVector) {\n        self.sponge.absorb_rq(input.get_elements());\n    }\n\n    pub fn set_u2(\u0026mut self, u2: RqVector) {\n        self.absorb_u2(\u0026u2);\n        self.u2 = u2;\n    }\n\n    pub fn absorb_u2(\u0026mut self, u2: \u0026RqVector) {\n        self.sponge.absorb_rq(u2.get_elements());\n    }\n\n    pub fn set_recursive_part(\u0026mut self, z: RqVector, t: RqMatrix, g: RqMatrix, h: RqMatrix) {\n        self.z = z;\n        self.t = t;\n        self.g = g;\n        self.h = h;\n    }\n\n    pub fn generate_projections(\n        \u0026mut self,\n        security_parameter: usize,\n        rank: usize,\n        multiplicity: usize,\n    ) -\u003e Projection {\n        // r vectors, each of length 256 * nD\n        let row_size = 2 * security_parameter;\n        let col_size = rank * Rq::DEGREE;\n\n        let matrices = (0..multiplicity)\n            .map(|_| {\n                let linear_projection_randomness = self.sponge.squeeze_zq(row_size * col_size);\n                linear_projection_randomness\n                    .chunks_exact(col_size)\n                    .map(|chunk| {\n                        let coeffs = chunk\n                            .iter()\n                            .map(|elem| {\n                                if elem.get_value() \u003c 2_u32.pow(30) {\n                                    Zq::NEG_ONE\n                                } else if elem.get_value() \u003c 2_u32.pow(31) {\n                                    Zq::ONE\n                                } else {\n                                    Zq::ZERO\n                                }\n                            })\n                            .collect();\n                        RqVector::new_from_zq_vector(coeffs)\n                    })\n                    .collect()\n            })\n            .collect();\n        Projection::new(matrices, security_parameter)\n    }\n\n    pub fn generate_vector_psi(\n        \u0026mut self,\n        number_of_vectors: usize,\n        vector_length: usize,\n    ) -\u003e Vec\u003cVec\u003cZq\u003e\u003e {\n        let elements = self.sponge.squeeze_zq(number_of_vectors * vector_length);\n        elements\n            .chunks_exact(vector_length)\n            .map(|chunk| chunk.into())\n            .collect()\n    }\n\n    pub fn generate_vector_omega(\n        \u0026mut self,\n        number_of_vectors: usize,\n        security_parameter: usize,\n    ) -\u003e Vec\u003cVec\u003cZq\u003e\u003e {\n        let elements = self\n            .sponge\n            .squeeze_zq(number_of_vectors * 2 * security_parameter);\n        elements\n            .chunks_exact(2 * security_parameter)\n            .map(|chunk| chunk.into())\n            .collect()\n    }\n\n    pub fn generate_rq_vector(\u0026mut self, vector_length: usize) -\u003e RqVector {\n        RqVector::new(self.sponge.squeeze_rq(vector_length))\n    }\n\n    pub fn generate_challenges(\u0026mut self, op_norm: f64, multiplicity: usize) -\u003e RqVector {\n        let mut result = Vec::new();\n        loop {\n            let candidate = self.sample_challenge();\n            if candidate.operator_norm() \u003c op_norm {\n                result.push(candidate);\n                if result.len() \u003e= multiplicity {\n                    return RqVector::new(result);\n                }\n            }\n        }\n    }\n\n    #[allow(clippy::as_conversions)]\n    fn sample_challenge(\u0026mut self) -\u003e Rq {\n        let mut coeffs = [Zq::ZERO; Rq::DEGREE];\n        let random_bits = self.sponge.squeeze_bits(10 + 31);\n        // Add 31 coefficients, each either +1 or -1.\n        for (item, random_bit) in coeffs.iter_mut().zip(\u0026random_bits).take(31) {\n            *item = if *random_bit { Zq::new(1) } else { -Zq::new(1) };\n        }\n        // Add 10 coefficients, each either +2 or -2.\n        for (item, random_bit) in coeffs.iter_mut().zip(random_bits).skip(31).take(10) {\n            *item = if random_bit { Zq::new(2) } else { -Zq::new(2) };\n        }\n\n        // ------------------ 3. Shuffle using Fisher–Yates approach ---------\n        for i in (1..Rq::DEGREE).rev() {\n            let random_bytes = self.sponge.squeeze_bytes(4);\n            let random_index = u32::from_le_bytes(random_bytes.try_into().unwrap());\n            let random_index = (random_index as usize) % (i + 1); // uniform in 0..i\n            coeffs.swap(i, random_index);\n        }\n        Rq::new(coeffs)\n    }\n}\n\n#[cfg(test)]\nmod tests_generate_pi {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_projection_matrix_has_correct_size() {\n        let (security_parameter, rank, multiplicity) = (128, 20, 9);\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let projections = transcript.generate_projections(security_parameter, rank, multiplicity);\n        assert_eq!(projections.get_projection_matrices().len(), multiplicity); // number_of_project_matrices\n        assert_eq!(\n            projections.get_projection_matrices()[0].get_row_len(),\n            2 * security_parameter\n        );\n        assert_eq!(projections.get_projection_matrices()[0].get_col_len(), rank);\n    }\n\n    // Test the distribution of values in the random matrix\n    #[test]\n    #[allow(clippy::as_conversions)]\n    fn test_projection_matrix_is_random() {\n        let (security_parameter, rank, multiplicity) = (128, 1000, 1);\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let projections = transcript.generate_projections(security_parameter, rank, multiplicity);\n\n        for projection_matrix in projections.get_projection_matrices() {\n            let mut counts = [0.0, 0.0, 0.0]; // -1, 0, 1\n            for row in projection_matrix.get_elements() {\n                for cell in row.concatenate_coefficients() {\n                    match cell {\n                        Zq::ZERO =\u003e counts[1] += 1.0,\n                        Zq::ONE =\u003e counts[2] += 1.0,\n                        Zq::NEG_ONE =\u003e counts[0] += 1.0,\n                        _ =\u003e panic!(\"Should not occur\"),\n                    }\n                }\n            }\n            // Number of elements in the matrix as f64 (256x4x1000)\n            #[allow(clippy::as_conversions)]\n            let total: f64 = (256 * Rq::DEGREE * rank) as f64;\n            println!(\"this is the total amount of elements{}\", total);\n            let expected = [0.25, 0.5, 0.25];\n            for i in 0..3 {\n                let actual = counts[i] / total;\n                println!(\"This is the actual value {}\", actual);\n                assert!(\n                    //Since its a statistical test some small error tolerance is allowed\n                    (actual - expected[i]).abs() \u003c 0.005,\n                    \"Values are not within expected proportions\"\n                );\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod test_generate_psi {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_generate_vector_psi_has_correct_size() {\n        let (k_range, l_range) = (20, 12);\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let result = transcript.generate_vector_psi(k_range, l_range);\n        assert_eq!(result.len(), k_range); // number_of_project_matrices\n        assert_eq!(result[0].len(), l_range);\n    }\n\n    // TODO: Testing randomness of the distribution is needed.\n}\n\n#[cfg(test)]\nmod test_generate_omega {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_generate_vector_omega_has_correct_size() {\n        let (security_parameter, k_range) = (128, 20);\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let result = transcript.generate_vector_omega(k_range, security_parameter);\n        assert_eq!(result.len(), k_range); // number_of_project_matrices\n        assert_eq!(result[0].len(), 256);\n    }\n\n    // TODO: Testing randomness of the distribution is needed.\n}\n\n#[cfg(test)]\nmod test_generate_rq {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_generate_rq_has_correct_size() {\n        let k_range = 20;\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let result = transcript.generate_rq_vector(k_range);\n        assert_eq!(result.get_elements().len(), k_range); // number_of_project_matrices\n    }\n\n    // TODO: Testing randomness of the distribution is needed.\n}\n\n#[cfg(test)]\nmod test_generate_challenges {\n    use super::*;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_generate_challenges_has_correct_size() {\n        let multiplicity = 9;\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n        let result = transcript.generate_challenges(15.0, multiplicity);\n        assert_eq!(result.get_elements().len(), multiplicity); // number_of_project_matrices\n    }\n\n    /// Test Challenge Set:\n    /// const 71 and const 15 are from Challenge Space, paper page 6.\n    /// l2 norm \u003c= 71\n    /// operator norm \u003c= 15\n    #[test]\n    fn test_challenge_set() {\n        let op_norm = 15.0;\n        let multiplicity = 9;\n        let mut transcript = LabradorTranscript::new(ShakeSponge::default());\n\n        let challenge_set = transcript.generate_challenges(15.0, multiplicity);\n\n        for i in 0..multiplicity {\n            // l2 norm 71 is from paper page 6, Challenge Space.\n            use crate::core::inner_product::compute_linear_combination;\n            assert_eq!(\n                compute_linear_combination(\n                    challenge_set.get_elements()[i].get_coefficients(),\n                    challenge_set.get_elements()[i].get_coefficients()\n                ),\n                Zq::new(71)\n            );\n            assert!(challenge_set.get_elements()[i].operator_norm() \u003c= op_norm);\n        }\n\n        for i in 0..multiplicity {\n            for j in 0..multiplicity {\n                if i != j {\n                    assert_ne!(\n                        challenge_set.get_elements()[i],\n                        challenge_set.get_elements()[j]\n                    );\n                }\n            }\n        }\n    }\n\n    // TODO: Testing randomness of the distribution is needed.\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":11}},{"line":24,"address":[],"length":0,"stats":{"Line":11}},{"line":25,"address":[],"length":0,"stats":{"Line":11}},{"line":26,"address":[],"length":0,"stats":{"Line":11}},{"line":27,"address":[],"length":0,"stats":{"Line":11}},{"line":28,"address":[],"length":0,"stats":{"Line":11}},{"line":29,"address":[],"length":0,"stats":{"Line":11}},{"line":30,"address":[],"length":0,"stats":{"Line":11}},{"line":31,"address":[],"length":0,"stats":{"Line":11}},{"line":35,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":26}},{"line":90,"address":[],"length":0,"stats":{"Line":20}},{"line":91,"address":[],"length":0,"stats":{"Line":20}},{"line":92,"address":[],"length":0,"stats":{"Line":20}},{"line":93,"address":[],"length":0,"stats":{"Line":5140}},{"line":94,"address":[],"length":0,"stats":{"Line":5120}},{"line":95,"address":[],"length":0,"stats":{"Line":5120}},{"line":96,"address":[],"length":0,"stats":{"Line":20157440}},{"line":97,"address":[],"length":0,"stats":{"Line":20152320}},{"line":98,"address":[],"length":0,"stats":{"Line":5037508}},{"line":99,"address":[],"length":0,"stats":{"Line":15114812}},{"line":100,"address":[],"length":0,"stats":{"Line":5041675}},{"line":102,"address":[],"length":0,"stats":{"Line":10073137}},{"line":105,"address":[],"length":0,"stats":{"Line":5120}},{"line":106,"address":[],"length":0,"stats":{"Line":5120}},{"line":108,"address":[],"length":0,"stats":{"Line":20}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":40}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":40}},{"line":140,"address":[],"length":0,"stats":{"Line":7}},{"line":141,"address":[],"length":0,"stats":{"Line":7}},{"line":144,"address":[],"length":0,"stats":{"Line":5}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":147}},{"line":148,"address":[],"length":0,"stats":{"Line":147}},{"line":149,"address":[],"length":0,"stats":{"Line":27}},{"line":150,"address":[],"length":0,"stats":{"Line":27}},{"line":151,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":147}},{"line":159,"address":[],"length":0,"stats":{"Line":147}},{"line":160,"address":[],"length":0,"stats":{"Line":147}},{"line":162,"address":[],"length":0,"stats":{"Line":4704}},{"line":163,"address":[],"length":0,"stats":{"Line":4557}},{"line":166,"address":[],"length":0,"stats":{"Line":1617}},{"line":167,"address":[],"length":0,"stats":{"Line":1470}},{"line":171,"address":[],"length":0,"stats":{"Line":9408}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":147}}],"covered":85,"coverable":89},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","mod.rs"],"content":"use crate::ring::{rq::Rq, zq::Zq};\n\npub trait Sponge {\n    fn default() -\u003e Self;\n    fn absorb_zq(\u0026mut self, input: \u0026[Zq]);\n    fn absorb_rq(\u0026mut self, input: \u0026[Rq]);\n    fn squeeze_zq(\u0026mut self, output_length: usize) -\u003e Vec\u003cZq\u003e;\n    fn squeeze_rq(\u0026mut self, output_length: usize) -\u003e Vec\u003cRq\u003e;\n    fn squeeze_bits(\u0026mut self, bit_length: usize) -\u003e Vec\u003cbool\u003e;\n    fn squeeze_bytes(\u0026mut self, byte_length: usize) -\u003e Vec\u003cu8\u003e;\n}\n\npub mod shake;\n// pub mod poseidon;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","poseidon","instance.rs"],"content":"use crate::zq::Zq;\n\nuse super::{permutation::PoseidonPermutation, sponge::PoseidonSponge};\n\n// ===========================================================================\n// Poseidon parameter set – hard-coded for Fiat–Shamir transcripts\n// ===========================================================================\n//\n// The ARK (add-round-key) and MDS matrices below were *generated once* and are\n// embedded so that every prover/verifier derives the **same** challenges.\nconst WIDTH: usize = 9;\nconst RATE: usize = 1;\nconst OUTPUT_LEN: usize = 1;\nconst ROUNDS: usize = 28;\nconst PARTIAL_ROUNDS: usize = 20;\nconst ALPHA: u64 = 3;\n// Hard‑coded round constants (ARK) and MDS matrix.  Generated off‑line.\nconst ARK: [[Zq; WIDTH]; ROUNDS] = [\n    [\n        Zq::new(2773654128),\n        Zq::new(2698871901),\n        Zq::new(1186535217),\n        Zq::new(2276367172),\n        Zq::new(460986456),\n        Zq::new(1130506256),\n        Zq::new(1436990685),\n        Zq::new(3571618093),\n        Zq::new(1928846831),\n    ],\n    [\n        Zq::new(784272210),\n        Zq::new(2362493121),\n        Zq::new(3754859051),\n        Zq::new(1152838762),\n        Zq::new(1277027414),\n        Zq::new(4290089713),\n        Zq::new(750711681),\n        Zq::new(3735304872),\n        Zq::new(2484390012),\n    ],\n    [\n        Zq::new(3022291695),\n        Zq::new(1296513440),\n        Zq::new(2666656071),\n        Zq::new(1392772787),\n        Zq::new(3924839390),\n        Zq::new(3434015439),\n        Zq::new(3547712534),\n        Zq::new(3119852137),\n        Zq::new(3798005745),\n    ],\n    [\n        Zq::new(2375363973),\n        Zq::new(1758886039),\n        Zq::new(2041597959),\n        Zq::new(3263939143),\n        Zq::new(1885616341),\n        Zq::new(1813930986),\n        Zq::new(203888102),\n        Zq::new(1528124030),\n        Zq::new(56779178),\n    ],\n    [\n        Zq::new(3755261782),\n        Zq::new(706143006),\n        Zq::new(2082983570),\n        Zq::new(352354306),\n        Zq::new(2353150435),\n        Zq::new(3650061737),\n        Zq::new(3893118498),\n        Zq::new(183150537),\n        Zq::new(2228089161),\n    ],\n    [\n        Zq::new(922618003),\n        Zq::new(3292151780),\n        Zq::new(236167017),\n        Zq::new(2617694273),\n        Zq::new(2876369390),\n        Zq::new(4265817939),\n        Zq::new(1383107438),\n        Zq::new(286389424),\n        Zq::new(3869373395),\n    ],\n    [\n        Zq::new(1955724147),\n        Zq::new(1111197896),\n        Zq::new(633124926),\n        Zq::new(2523587424),\n        Zq::new(4135563482),\n        Zq::new(3059457948),\n        Zq::new(2282176497),\n        Zq::new(1783995730),\n        Zq::new(3403269348),\n    ],\n    [\n        Zq::new(508988721),\n        Zq::new(301251615),\n        Zq::new(4208429837),\n        Zq::new(2847939307),\n        Zq::new(3727165119),\n        Zq::new(3625918486),\n        Zq::new(3478562333),\n        Zq::new(1459737698),\n        Zq::new(100323470),\n    ],\n    [\n        Zq::new(3179318671),\n        Zq::new(1533355377),\n        Zq::new(2704441550),\n        Zq::new(2362155401),\n        Zq::new(4225681297),\n        Zq::new(621873557),\n        Zq::new(1849485098),\n        Zq::new(4012360807),\n        Zq::new(3322683455),\n    ],\n    [\n        Zq::new(271837745),\n        Zq::new(1175116485),\n        Zq::new(1502825906),\n        Zq::new(113799952),\n        Zq::new(710728204),\n        Zq::new(930285870),\n        Zq::new(936814998),\n        Zq::new(3142336897),\n        Zq::new(1195857553),\n    ],\n    [\n        Zq::new(3229477597),\n        Zq::new(3874900104),\n        Zq::new(633468355),\n        Zq::new(664022320),\n        Zq::new(1037768339),\n        Zq::new(24745787),\n        Zq::new(1390286585),\n        Zq::new(2050114210),\n        Zq::new(3461313472),\n    ],\n    [\n        Zq::new(2038116502),\n        Zq::new(2756126285),\n        Zq::new(314702156),\n        Zq::new(198049006),\n        Zq::new(3362107641),\n        Zq::new(804124193),\n        Zq::new(1347345692),\n        Zq::new(3778418349),\n        Zq::new(1603517811),\n    ],\n    [\n        Zq::new(246075735),\n        Zq::new(2910920140),\n        Zq::new(2101057122),\n        Zq::new(2041317133),\n        Zq::new(2883309822),\n        Zq::new(4019460306),\n        Zq::new(2468923228),\n        Zq::new(964910736),\n        Zq::new(1333043724),\n    ],\n    [\n        Zq::new(293190938),\n        Zq::new(3902017027),\n        Zq::new(549889505),\n        Zq::new(4272274465),\n        Zq::new(3832846664),\n        Zq::new(2204806555),\n        Zq::new(3020552376),\n        Zq::new(3447507883),\n        Zq::new(855953368),\n    ],\n    [\n        Zq::new(2079971112),\n        Zq::new(2508401160),\n        Zq::new(3834351883),\n        Zq::new(1427569236),\n        Zq::new(3358408800),\n        Zq::new(2439693552),\n        Zq::new(4054927129),\n        Zq::new(4053693217),\n        Zq::new(723473858),\n    ],\n    [\n        Zq::new(1025339977),\n        Zq::new(585257694),\n        Zq::new(3070506491),\n        Zq::new(3175819591),\n        Zq::new(1392016786),\n        Zq::new(1516602977),\n        Zq::new(3228410444),\n        Zq::new(3130776340),\n        Zq::new(3165959881),\n    ],\n    [\n        Zq::new(3842311420),\n        Zq::new(2262157250),\n        Zq::new(3756225800),\n        Zq::new(2582280172),\n        Zq::new(1270243441),\n        Zq::new(2052508852),\n        Zq::new(4271664205),\n        Zq::new(620984828),\n        Zq::new(3325253760),\n    ],\n    [\n        Zq::new(548636457),\n        Zq::new(1164607978),\n        Zq::new(3027080685),\n        Zq::new(1908414320),\n        Zq::new(1208816014),\n        Zq::new(671096184),\n        Zq::new(4042441851),\n        Zq::new(2000153875),\n        Zq::new(2975622655),\n    ],\n    [\n        Zq::new(2588519128),\n        Zq::new(1500421688),\n        Zq::new(280920169),\n        Zq::new(1425318099),\n        Zq::new(173722839),\n        Zq::new(1354484516),\n        Zq::new(1969077869),\n        Zq::new(2165032598),\n        Zq::new(2764691127),\n    ],\n    [\n        Zq::new(3889006152),\n        Zq::new(676568773),\n        Zq::new(1097350839),\n        Zq::new(3748044660),\n        Zq::new(3451456889),\n        Zq::new(1469067299),\n        Zq::new(1196266786),\n        Zq::new(3351660008),\n        Zq::new(3216956496),\n    ],\n    [\n        Zq::new(2920308927),\n        Zq::new(1964475343),\n        Zq::new(1208178427),\n        Zq::new(1685596759),\n        Zq::new(3452869029),\n        Zq::new(574413953),\n        Zq::new(1372297329),\n        Zq::new(1642685791),\n        Zq::new(1521032998),\n    ],\n    [\n        Zq::new(1396137219),\n        Zq::new(3249324467),\n        Zq::new(1491626859),\n        Zq::new(1222034466),\n        Zq::new(3741121943),\n        Zq::new(2630086446),\n        Zq::new(4101711170),\n        Zq::new(3962365070),\n        Zq::new(630331971),\n    ],\n    [\n        Zq::new(3756693713),\n        Zq::new(1976849786),\n        Zq::new(1599868415),\n        Zq::new(4193484663),\n        Zq::new(3575428569),\n        Zq::new(2614894763),\n        Zq::new(721681014),\n        Zq::new(3645252436),\n        Zq::new(96433812),\n    ],\n    [\n        Zq::new(1889643081),\n        Zq::new(178898262),\n        Zq::new(2836025067),\n        Zq::new(1086358336),\n        Zq::new(3421342207),\n        Zq::new(1160658413),\n        Zq::new(3078690548),\n        Zq::new(1734238039),\n        Zq::new(1684918153),\n    ],\n    [\n        Zq::new(4186013047),\n        Zq::new(1024422138),\n        Zq::new(4025507495),\n        Zq::new(2413389692),\n        Zq::new(614405915),\n        Zq::new(2631560766),\n        Zq::new(4144324857),\n        Zq::new(2400759460),\n        Zq::new(1279501883),\n    ],\n    [\n        Zq::new(1791688840),\n        Zq::new(2006611136),\n        Zq::new(3093261711),\n        Zq::new(1016157743),\n        Zq::new(11561707),\n        Zq::new(1430464813),\n        Zq::new(73038415),\n        Zq::new(2025372355),\n        Zq::new(2402576570),\n    ],\n    [\n        Zq::new(2758798058),\n        Zq::new(2132722282),\n        Zq::new(1698416471),\n        Zq::new(3578176273),\n        Zq::new(550672905),\n        Zq::new(70724481),\n        Zq::new(3070901761),\n        Zq::new(306186726),\n        Zq::new(2828652630),\n    ],\n    [\n        Zq::new(1005410618),\n        Zq::new(1376511878),\n        Zq::new(4093260411),\n        Zq::new(3950256285),\n        Zq::new(1890541837),\n        Zq::new(1315511419),\n        Zq::new(3327986955),\n        Zq::new(1322306885),\n        Zq::new(1270447424),\n    ],\n];\nconst MDS: [[Zq; WIDTH]; WIDTH] = [\n    [\n        Zq::new(3997651091),\n        Zq::new(658253063),\n        Zq::new(2095400994),\n        Zq::new(440926105),\n        Zq::new(1796368741),\n        Zq::new(1961349520),\n        Zq::new(540996892),\n        Zq::new(35935778),\n        Zq::new(732075401),\n    ],\n    [\n        Zq::new(1743127377),\n        Zq::new(3247221626),\n        Zq::new(4148659237),\n        Zq::new(2205285832),\n        Zq::new(3910687740),\n        Zq::new(2853895742),\n        Zq::new(1662369266),\n        Zq::new(241107308),\n        Zq::new(4022943497),\n    ],\n    [\n        Zq::new(2071371317),\n        Zq::new(4222913952),\n        Zq::new(1163051760),\n        Zq::new(3185249567),\n        Zq::new(4114377118),\n        Zq::new(1048229747),\n        Zq::new(658207529),\n        Zq::new(1971020081),\n        Zq::new(4001507915),\n    ],\n    [\n        Zq::new(4278306557),\n        Zq::new(2902580578),\n        Zq::new(1382067936),\n        Zq::new(3738299059),\n        Zq::new(1548047067),\n        Zq::new(1128497469),\n        Zq::new(2358825001),\n        Zq::new(567535302),\n        Zq::new(4263023986),\n    ],\n    [\n        Zq::new(188724725),\n        Zq::new(890882199),\n        Zq::new(2995073197),\n        Zq::new(3520401121),\n        Zq::new(2334136676),\n        Zq::new(1039560330),\n        Zq::new(3354448203),\n        Zq::new(2456760197),\n        Zq::new(860596610),\n    ],\n    [\n        Zq::new(1063803022),\n        Zq::new(4115470744),\n        Zq::new(2914526459),\n        Zq::new(995387934),\n        Zq::new(47066002),\n        Zq::new(3823938923),\n        Zq::new(329509446),\n        Zq::new(2091055303),\n        Zq::new(2927144621),\n    ],\n    [\n        Zq::new(1222968641),\n        Zq::new(3572964758),\n        Zq::new(532234855),\n        Zq::new(1137915407),\n        Zq::new(902452800),\n        Zq::new(1725021750),\n        Zq::new(3941355778),\n        Zq::new(816646153),\n        Zq::new(2658636777),\n    ],\n    [\n        Zq::new(2652215134),\n        Zq::new(3067867604),\n        Zq::new(1764433633),\n        Zq::new(3289297051),\n        Zq::new(3187448683),\n        Zq::new(3735943544),\n        Zq::new(3993652112),\n        Zq::new(2905114558),\n        Zq::new(477157260),\n    ],\n    [\n        Zq::new(3093659876),\n        Zq::new(479575061),\n        Zq::new(3390824282),\n        Zq::new(3037823443),\n        Zq::new(1492293764),\n        Zq::new(3797464643),\n        Zq::new(3579348020),\n        Zq::new(2374361921),\n        Zq::new(842530663),\n    ],\n];\n\n/// Convenience type aliases for the fixed permutation + sponge\ntype Perm = PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e;\ntype Sponge = PoseidonSponge\u003cOUTPUT_LEN, RATE, WIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e;\n\n/// A **Fiat–Shamir transcript** based on Poseidon.\n///\n/// The transcript collects field elements via [`absorb_element`].  When a new\n/// challenge is required, [`get_scalar_challenge`] returns the Poseidon hash of\n/// the current buffer, interpreted as a scalar in the same field `Zq`.\n///\n/// The internal message buffer is **not** cleared after squeezing, allowing the\n/// caller to derive *multiple* independent challenges sequentially by first\n/// appending the previous challenge back into the transcript (standard\n/// practice in many proof systems).\npub struct Transcript {\n    buf: Vec\u003cZq\u003e,\n}\n\nimpl Default for Transcript {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Transcript {\n    /// Creates an **empty** transcript.\n    pub fn new() -\u003e Self {\n        Self { buf: Vec::new() }\n    }\n\n    /// Appends a field element to the transcript.  Elements are stored in the\n    /// order they are seen and fed verbatim to the Poseidon sponge.\n    pub fn absorb_element(\u0026mut self, elem: Zq) {\n        self.buf.push(elem);\n    }\n\n    /// Generates a *scalar* challenge and **appends it** to the transcript so\n    /// that subsequent challenges are bound to the previous ones.\n    pub fn get_scalar_challenge(\u0026mut self) -\u003e Zq {\n        let permutation = Perm::new_with_ark_mds(ARK, MDS);\n        let mut sponge = Sponge::new(self.buf.clone(), permutation);\n        let challenge = sponge.compute_hash()[0];\n        self.buf.push(challenge);\n        challenge\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Transcript;\n    use crate::zq::Zq;\n\n    #[test]\n    fn test_transcript() {\n        let mut transcript = Transcript::new();\n        transcript.absorb_element(Zq::new(12));\n        transcript.absorb_element(Zq::new(12312));\n        transcript.absorb_element(Zq::new(111));\n        let _result = transcript.get_scalar_challenge();\n        // result == 3770429813\n    }\n\n    #[test]\n    fn test_challenge_is_appended_to_transcript() {\n        let mut t = Transcript::new();\n        t.absorb_element(Zq::new(42));\n        let c1 = t.get_scalar_challenge();\n        let c2 = t.get_scalar_challenge();\n        assert_ne!(c1, c2);\n    }\n\n    /// Two transcripts with identical message sequences must agree on the\n    /// challenge value.\n    #[test]\n    fn test_two_transcripts_agree() {\n        let mut t1 = Transcript::new();\n        let mut t2 = Transcript::new();\n        for \u0026x in \u0026[1u32, 2, 3, 5, 8] {\n            t1.absorb_element(Zq::new(x));\n            t2.absorb_element(Zq::new(x));\n        }\n        assert_eq!(t1.get_scalar_challenge(), t2.get_scalar_challenge());\n    }\n\n    /// Changing *one* absorbed element should almost certainly alter the\n    /// challenge (collision resistance is probabilistic; here we just assert\n    /// inequality for this specific test vector).\n    #[test]\n    fn test_challenge_changes_with_input() {\n        let mut t1 = Transcript::new();\n        let mut t2 = Transcript::new();\n        t1.absorb_element(Zq::new(99));\n        t2.absorb_element(Zq::new(100));\n        assert_ne!(t1.get_scalar_challenge(), t2.get_scalar_challenge());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","poseidon","permutation.rs"],"content":"use crate::zq::Zq;\nuse blake2::Blake2b256;\nuse blake2::Digest;\nuse rand::distr::{Distribution, Uniform};\nuse rand::{random, rng, CryptoRng};\n\n/// A configurable implementation of the *Poseidon* permutation.\n///\n/// The permutation operates over a fixed–width state `WIDTH` of field\n/// elements [`Zq`], runs for `ROUNDS` total rounds, of which\n/// `PARTIAL_ROUNDS` are **partial rounds** (S-box is applied to **only one**\n/// state word, and uses an S-box of the form \\(x \\mapsto x^{ALPHA}\\).\n///\n/// # Type Parameters\n/// * `WIDTH` – Number of field elements in the internal state.\n/// * `ROUNDS` – Total rounds executed by [`permute`]; including partial rounds.\n/// * `PARTIAL_ROUNDS` – Number of *partial* rounds; the remaining\n///   \\(ROUNDS-\\text{PARTIAL_ROUNDS}\\) are *full* rounds.\n/// * `ALPHA` – Exponent used by the power S-box.\n///\n/// The round constants (ARK) and MDS matrix are generated from fresh randomness at construction time.\npub struct PoseidonPermutation\u003c\n    const WIDTH: usize,\n    const ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n    const ALPHA: u64,\n\u003e {\n    /// Current permutation state.\n    pub state: [Zq; WIDTH],\n    /// Round keys (ARK) – `ROUNDS × WIDTH` matrix.\n    pub ark: [[Zq; WIDTH]; ROUNDS],\n    /// MDS matrix (`WIDTH × WIDTH`) used to mix the state every round.\n    pub mds: [[Zq; WIDTH]; WIDTH],\n}\n\nimpl\u003cconst WIDTH: usize, const ROUNDS: usize, const PARTIAL_ROUNDS: usize, const ALPHA: u64\u003e Default\n    for PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cconst WIDTH: usize, const ROUNDS: usize, const PARTIAL_ROUNDS: usize, const ALPHA: u64\u003e\n    PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e\n{\n    /// Constructs a fresh permutation instance with **zero** initial state and\n    /// randomly generated ARK and MDS parameters.\n    ///\n    /// ARK and MDS generation works for testing porpuses,\n    /// but their correctness and security needs careful consideration.\n    pub fn new() -\u003e Self {\n        Self {\n            state: [Zq::ZERO; WIDTH],\n            ark: Self::generate_round_constants(),\n            mds: Self::generate_mds_matrix(rng()),\n        }\n    }\n\n    /// Constructs a permutation whose *parameterisation* (ARK \u0026 MDS) is fully\n    /// specified by the caller.\n    ///\n    /// This constructor is the preferred choice for reproducible behaviour in\n    /// tests or when deploying standard Poseidon instances.\n    pub fn new_with_ark_mds(ark: [[Zq; WIDTH]; ROUNDS], mds: [[Zq; WIDTH]; WIDTH]) -\u003e Self {\n        Self {\n            state: [Zq::ZERO; WIDTH],\n            ark,\n            mds,\n        }\n    }\n\n    // Generates ARK matrix\n    fn generate_round_constants() -\u003e [[Zq; WIDTH]; ROUNDS] {\n        // Create a matrix to store constants for each round and state position\n        let mut ark = [[Zq::new(0); WIDTH]; ROUNDS];\n\n        // Iterate over the rows (rounds)\n        for row in ark.iter_mut().take(ROUNDS) {\n            // Iterate over the states in the current row using `iter_mut` for mutable access\n            for state in row.iter_mut().take(WIDTH) {\n                // 4 random bytes to use as input (seed)\n                let seed: [u8; 4] = random();\n\n                // Hasher based on Blake2b\n                let mut hasher = Blake2b256::new();\n                hasher.update(seed);\n\n                // Get the hash output\n                let hash_result: [u8; 32] = hasher.finalize().into();\n\n                // Take the first 4 bytes of the hash\n                let hash_bytes: [u8; 4] = hash_result[..4]\n                    .try_into()\n                    .expect(\"can cast a slice into an array\");\n\n                // Convert those 4 bytes into a u32 value\n                let constant = u32::from_le_bytes(hash_bytes);\n\n                // Store the constant in the matrix\n                *state = Zq::new(constant);\n            }\n        }\n        ark\n    }\n\n    /// Generates an MDS (Maximum Distance Separable) matrix using a Cauchy matrix\n    fn generate_mds_matrix\u003cR: CryptoRng\u003e(mut rng: R) -\u003e [[Zq; WIDTH]; WIDTH] {\n        let uniform = Uniform::new_inclusive(Zq::ZERO, Zq::MAX).unwrap();\n\n        let mut x_vals = Vec::new();\n        let mut y_vals = Vec::new();\n\n        // Sample unique x values\n        while x_vals.len() \u003c WIDTH {\n            let candidate = uniform.sample(\u0026mut rng);\n            if !x_vals.contains(\u0026candidate) {\n                x_vals.push(candidate);\n            }\n        }\n\n        // Sample unique y values with additional constraint\n        while y_vals.len() \u003c WIDTH {\n            let candidate = uniform.sample(\u0026mut rng);\n            let valid =\n                !y_vals.contains(\u0026candidate) \u0026\u0026 !x_vals.iter().any(|x| *x + candidate == Zq::ZERO);\n            if valid {\n                y_vals.push(candidate);\n            }\n        }\n\n        // Construct the Cauchy matrix\n        let mut matrix = [[Zq::ZERO; WIDTH]; WIDTH];\n\n        for (i, \u0026x_val) in x_vals.iter().enumerate() {\n            for (j, \u0026y_val) in y_vals.iter().enumerate() {\n                let denom = x_val + y_val;\n                matrix[i][j] = denom.inv().expect(\"Inverse must exist here\");\n            }\n        }\n\n        matrix\n    }\n\n    // Adds the *round constants* (`ARK`) for the given round number to the\n    /// current state **in‑place**.\n    fn apply_round_constants(\u0026mut self, round_num: usize) {\n        for (i, elem) in self.state.iter_mut().enumerate() {\n            *elem += self.ark[round_num][i];\n        }\n    }\n\n    /// Applies the S‑box \\(x \\mapsto x^{ALPHA}\\) to the state.\n    ///\n    /// * When `is_full_round == true` the exponentiation is applied to **every**\n    ///   lane.\n    /// * Otherwise *only the first* state element (`state[0]`) is transformed –\n    ///   this corresponds to a **partial round** in the Poseidon/Hades design.\n    fn apply_s_box(\u0026mut self, is_full_round: bool) {\n        if is_full_round {\n            for elem in \u0026mut self.state {\n                *elem = elem.pow(ALPHA);\n            }\n        } else {\n            self.state[0] = self.state[0].pow(ALPHA);\n        }\n    }\n\n    /// Multiplies the state by the MDS matrix.\n    fn apply_mds(\u0026mut self) {\n        let mut old_state = self.state;\n        // Matrix multiplication with the state for diffusion\n        for (i, _cur) in self.state.iter().enumerate() {\n            let mut sum: Zq = Zq::ZERO;\n            for (j, elem) in self.state.iter().enumerate() {\n                // matrix multiplication\n                sum += *elem * self.mds[i][j];\n            }\n            old_state[i] = sum;\n        }\n        self.state = old_state;\n    }\n\n    /// Executes the complete Poseidon permutation on the internal state.\n    ///\n    /// Each round performs, in order:\n    /// 1. Add‑round‑constants (ARK)\n    /// 2. S‑box (either full or partial)\n    /// 3. MDS multiplication\n    pub fn permute(\u0026mut self) {\n        let full_rounds_half = (ROUNDS - PARTIAL_ROUNDS) / 2;\n        // --- first half of full rounds --------------------------------------------------------\n        for i in 0..full_rounds_half {\n            self.apply_round_constants(i);\n            self.apply_s_box(true);\n            self.apply_mds();\n        }\n        // --- partial rounds -------------------------------------------------------------------\n        for i in full_rounds_half..(full_rounds_half + PARTIAL_ROUNDS) {\n            self.apply_round_constants(i);\n            self.apply_s_box(false); // Apply the S-box to the first element only\n            self.apply_mds();\n        }\n        // --- second half of full rounds -------------------------------------------------------\n        for i in (full_rounds_half + PARTIAL_ROUNDS)..(ROUNDS) {\n            self.apply_round_constants(i);\n            self.apply_s_box(true);\n            self.apply_mds();\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::poseidon::permutation::PoseidonPermutation;\n    use crate::zq::Zq;\n\n    type Permutation1 = PoseidonPermutation\u003c6, 41, 6, 3\u003e;\n    type Permutation2 = PoseidonPermutation\u003c6, 6, 6, 3\u003e;\n    type Permutation3 = PoseidonPermutation\u003c2, 2, 0, 1\u003e;\n    type Permutation4 = PoseidonPermutation\u003c2, 3, 1, 2\u003e;\n\n    #[test]\n    fn test_correct_permutation_config() {\n        let permutation = Permutation1::new();\n        assert_eq!(permutation.state.len(), 6);\n    }\n\n    #[test]\n    fn test_s_box_partial_round_alpha_3() {\n        // Arrange\n        let mut permutation = Permutation1::new();\n        for (ctr, elem) in permutation.state.iter_mut().enumerate() {\n            *elem = Zq::new(ctr as u32 + 10);\n        }\n\n        // Act\n        permutation.apply_s_box(false);\n\n        // Assert\n        assert_eq!(permutation.state[0], Zq::new(10).pow(3));\n        for i in 1..(permutation.state.len()) {\n            assert_eq!(permutation.state[i], Zq::new(i as u32 + 10));\n        }\n    }\n\n    #[test]\n    fn test_s_box_full_round_alpha_3() {\n        // Arrange\n        let mut permutation = Permutation1::new();\n        for (ctr, elem) in permutation.state.iter_mut().enumerate() {\n            *elem = Zq::new(ctr as u32 + 10);\n        }\n\n        // Act\n        permutation.apply_s_box(true);\n\n        // Assert\n        for (index, elem) in permutation.state.iter().enumerate() {\n            assert_eq!(elem, \u0026Zq::new(index as u32 + 10).pow(3));\n        }\n    }\n\n    #[test]\n    fn test_apply_ark() {\n        // Arrange\n        let mut permutation = Permutation2::new();\n        permutation.ark = [\n            [\n                Zq::new(0),\n                Zq::new(1),\n                Zq::new(2),\n                Zq::new(3),\n                Zq::new(4),\n                Zq::new(5),\n            ],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n            [Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO, Zq::ZERO],\n        ];\n\n        // Act\n        permutation.apply_round_constants(0);\n\n        // Assert\n        for (idx, elem) in permutation.state.iter().enumerate() {\n            assert_eq!(elem, \u0026Zq::new(idx as u32));\n        }\n    }\n\n    #[test]\n    fn test_apply_mds_all_one_matrix() {\n        // Arrange\n        let mut permutation = Permutation1::new();\n        permutation.mds = [\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n            [Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE, Zq::ONE],\n        ];\n        for (i, elem) in permutation.state.iter_mut().enumerate() {\n            *elem = Zq::new((i + 1) as u32); // state = [1,2,3,4,5,6]\n        }\n\n        // Act\n        permutation.apply_mds();\n\n        // Assert\n        let expected = Zq::new(21);\n        for elem in \u0026permutation.state {\n            assert_eq!(elem, \u0026expected);\n        }\n    }\n\n    /// permute: ALPHA = 1 (identity S-box) and identity MDS.\n    /// With two full rounds and *no* partial rounds the permutation\n    /// should simply add the round constants twice.\n    #[test]\n    fn test_permute_with_identity_mds_s_box() {\n        // Arrange\n        let mut permutation = Permutation3::new();\n        permutation.ark = [[Zq::new(5), Zq::new(7)], [Zq::new(11), Zq::new(13)]];\n        permutation.mds = [[Zq::new(1), Zq::new(0)], [Zq::new(0), Zq::new(1)]];\n\n        // Act\n        permutation.permute();\n\n        // Assert\n        assert_eq!(permutation.state[0], Zq::new(16)); // 5+11\n        assert_eq!(permutation.state[1], Zq::new(20)); // 7+13\n    }\n\n    /// permute: ALPHA = 2 (square), **one partial round**.\n    /// Identity MDS and zero ARK so the result depends *only*\n    /// on the S-box schedule:\n    ///\n    ///   initial:     (2,3)\n    ///   round-0 F:   ( 4,  9)\n    ///   round-1 P:   (16,  9)\n    ///   round-2 F:   (256, 81)\n    #[test]\n    fn test_permute_partial_round_sbox() {\n        // Arrange\n        let mut permutation = Permutation4::new();\n        permutation.ark = [[Zq::ZERO; 2]; 3];\n        permutation.mds = [[Zq::new(1), Zq::new(0)], [Zq::new(0), Zq::new(1)]];\n        permutation.state[0] = Zq::new(2);\n        permutation.state[1] = Zq::new(3);\n\n        // Act\n        permutation.permute();\n\n        // Assert\n        assert_eq!(permutation.state[0], Zq::new(256));\n        assert_eq!(permutation.state[1], Zq::new(81));\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":69},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","poseidon","sponge.rs"],"content":"use super::permutation::PoseidonPermutation;\nuse crate::zq::Zq;\n\n/// Errors that can occur while manipulating the underlying Poseidon state during\n/// **absorption**.\n#[derive(Debug)]\npub enum PoseidonError {\n    /// Attempted to write to an index outside the state array.\n    OutOfBounds(usize),\n    /// Called with an *empty* input vector when one was expected.\n    EmptyInput,\n}\n\n/// Errors returned by [`PoseidonSponge::squeeze`] when the caller’s request\n/// is incompatible with the sponge *rate*.\n#[derive(Debug, thiserror::Error)]\npub enum SpongeError {\n    /// The requested number of field elements exceeds the sponge rate.\n    #[error(\"Squeeze request of {requested} exceeds rate {rate}\")]\n    OversizedSqueeze { requested: usize, rate: usize },\n}\n\n/// Generic Poseidon **sponge construction**.\n///\n/// The sponge is parameterised over\n/// * `OUTPUT_LENGTH` – number of field elements returned by [`compute_hash`].\n/// * `RATE` – how many of the `WIDTH` state words are exposed during\n///   *absorb*/*squeeze* (i.e. *capacity* = `WIDTH - RATE`).\n/// * `WIDTH`, `ROUNDS`, `PARTIAL_ROUNDS`, `ALPHA` – forwarded to\n///   [`PoseidonPermutation`].\n///\n/// **Usage pattern**:\n/// 1. Create with [`new`], providing the message as `Vec\u003cZq\u003e` and a\n///    permutation instance.\n/// 2. Call [`compute_hash`] to obtain the digest.\npub struct PoseidonSponge\u003c\n    const OUTPUT_LENGTH: usize,\n    const RATE: usize,\n    const WIDTH: usize,\n    const ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n    const ALPHA: u64,\n\u003e {\n    /// Buffer holding the message to be absorbed.\n    input: Vec\u003cZq\u003e,\n    /// Output of length `OUTPUT_LENGTH`; initialised to all‑zero.\n    output: [Zq; OUTPUT_LENGTH],\n    /// Internal Poseidon permutation instance.\n    permutation: PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e,\n}\n\nimpl\u003c\n        const OUTPUT_LENGTH: usize,\n        const RATE: usize,\n        const WIDTH: usize,\n        const ROUNDS: usize,\n        const PARTIAL_ROUNDS: usize,\n        const ALPHA: u64,\n    \u003e PoseidonSponge\u003cOUTPUT_LENGTH, RATE, WIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e\n{\n    /// Constructs a new sponge with the provided *message* and *permutation\n    /// parameters*.\n    pub fn new(\n        input: Vec\u003cZq\u003e,\n        permutation: PoseidonPermutation\u003cWIDTH, ROUNDS, PARTIAL_ROUNDS, ALPHA\u003e,\n    ) -\u003e Self {\n        Self {\n            input,\n            output: [Zq::ZERO; OUTPUT_LENGTH],\n            permutation,\n        }\n    }\n\n    /// **Absorb** the message into the sponge state according to the Poseidon\n    /// rate/capacity split, forwarding to [`PoseidonPermutation::permute`] each\n    /// time the rate section is filled. Returns an error only in pathological\n    /// circumstances (e.g. writing out of bounds if `RATE`/`WIDTH` are\n    /// miss‑configured).\n    fn absorb(\u0026mut self) -\u003e Result\u003c(), PoseidonError\u003e {\n        let mut remaining = self.input.clone();\n        let mut position = 0;\n\n        while !remaining.is_empty() {\n            let available_space = RATE - position;\n            let elements_to_absorb = remaining.len().min(available_space);\n            let elements_to_process = \u0026remaining[..elements_to_absorb];\n\n            for (i, elem) in elements_to_process.iter().enumerate() {\n                let target_index = WIDTH - RATE + position + i;\n                if target_index \u003e= self.permutation.state.len() {\n                    return Err(PoseidonError::OutOfBounds(target_index));\n                }\n                self.permutation.state[target_index] += *elem;\n            }\n\n            remaining = (remaining[elements_to_absorb..]).to_vec();\n\n            if remaining.is_empty() {\n                self.permutation.permute();\n                return Ok(());\n            }\n            self.permutation.permute();\n            position = 0;\n        }\n\n        Ok(())\n    }\n\n    /// **Squeeze** `OUTPUT_LENGTH` field elements from the sponge. This is\n    /// cached so that subsequent calls return the same slice without\n    /// recomputation.\n    fn squeeze(\u0026mut self) -\u003e Result\u003c[Zq; OUTPUT_LENGTH], SpongeError\u003e {\n        // Check if the requested number of elements exceeds the rate.\n        if OUTPUT_LENGTH \u003e RATE {\n            return Err(SpongeError::OversizedSqueeze {\n                requested: OUTPUT_LENGTH,\n                rate: RATE,\n            });\n        }\n\n        let mut output = [Zq::ZERO; OUTPUT_LENGTH];\n        let mut remaining_elements = output.as_mut_slice();\n        let mut squeeze_index = 0;\n        // Loop until we return the expected amount\n        loop {\n            if squeeze_index + remaining_elements.len() \u003c= RATE {\n                remaining_elements.copy_from_slice(\n                    \u0026self.permutation.state[WIDTH - RATE + squeeze_index\n                        ..WIDTH - RATE + remaining_elements.len() + squeeze_index],\n                );\n                return Ok(output);\n            }\n            // Reset squeeze index in case we need to squeeze again to fill the output\n            let num_elements_squeezed = RATE - squeeze_index;\n            remaining_elements[..num_elements_squeezed].copy_from_slice(\n                \u0026self.permutation.state[WIDTH - RATE + squeeze_index\n                    ..WIDTH - RATE + num_elements_squeezed + squeeze_index],\n            );\n\n            remaining_elements = \u0026mut remaining_elements[num_elements_squeezed..];\n            self.permutation.permute();\n            squeeze_index = 0;\n        }\n    }\n\n    /// Computes (and caches) the Poseidon hash of the input message. Repeated\n    /// calls are **free** after the first one.\n    pub fn compute_hash(\u0026mut self) -\u003e \u0026[Zq] {\n        if self.output.iter().all(|\u0026x| x == Zq::ZERO) {\n            self.absorb().expect(\"absorb failed\");\n            self.output = self.squeeze().expect(\"squeeze failed\");\n        }\n        \u0026self.output\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{PoseidonPermutation, PoseidonSponge};\n    use crate::zq::Zq;\n\n    #[test]\n    fn test_absorb_fills_rate_then_permute() {\n        // Arrange\n        // WIDTH = 4, RATE = 2 → capacity = 2\n        let mut permutation = PoseidonPermutation::\u003c4, 2, 0, 1\u003e::new();\n        permutation.mds = [[Zq::ZERO; 4]; 4];\n        for i in 0..4 {\n            permutation.mds[i][i] = Zq::ONE;\n        }\n        permutation.ark = [[Zq::ZERO; 4]; 2];\n        let msg = vec![Zq::new(5), Zq::new(7)];\n        let mut sponge = PoseidonSponge::\u003c1, 2, 4, 2, 0, 1\u003e::new(msg, permutation);\n\n        // absorb is implicit inside compute_hash\n        sponge.absorb().unwrap();\n\n        // After absorption the last `RATE` lanes should hold the message as we\n        // used an identity permutation.\n        assert_eq!(sponge.permutation.state[2], Zq::new(5));\n        assert_eq!(sponge.permutation.state[3], Zq::new(7));\n    }\n}\n","traces":[{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","transcript","sponges","shake","mod.rs"],"content":"use sha3::{\n    digest::{ExtendableOutput, Update, XofReader},\n    Shake256,\n};\n\nuse crate::ring::{rq::Rq, zq::Zq};\nuse crate::transcript::Sponge;\n\npub struct ShakeSponge {\n    hasher: Shake256,\n}\n\nimpl Sponge for ShakeSponge {\n    fn default() -\u003e Self {\n        Self {\n            hasher: Shake256::default(),\n        }\n    }\n    fn absorb_zq(\u0026mut self, input: \u0026[Zq]) {\n        // Convert Rq ector to u8\n        let mut u8_version_input: Vec\u003cu8\u003e = Vec::new();\n        for coeff in input {\n            u8_version_input.extend_from_slice(\u0026coeff.get_value().to_be_bytes());\n        }\n        self.hasher.update(\u0026u8_version_input);\n    }\n\n    fn absorb_rq(\u0026mut self, input: \u0026[Rq]) {\n        // Convert Rq ector to u8\n        let mut u8_version_input: Vec\u003cu8\u003e = Vec::new();\n        for rq in input {\n            for coeff in rq.get_coefficients() {\n                u8_version_input.extend_from_slice(\u0026coeff.get_value().to_be_bytes());\n            }\n        }\n        self.hasher.update(\u0026u8_version_input);\n    }\n\n    fn squeeze_bits(\u0026mut self, bit_length: usize) -\u003e Vec\u003cbool\u003e {\n        let byte_len = bit_length.div_ceil(8);\n        let mut reader = self.hasher.clone().finalize_xof();\n        let mut output_buffer = vec![u8::default(); byte_len];\n        reader.read(\u0026mut output_buffer);\n\n        let mut result = Vec::with_capacity(bit_length);\n        for byte in \u0026output_buffer {\n            let mut mask = 1u8;\n            for _ in 0..8 {\n                if result.len() == bit_length {\n                    break;\n                }\n                result.push(byte \u0026 mask != 0);\n                mask \u003c\u003c= 1;\n            }\n        }\n        self.hasher.update(\u0026output_buffer);\n        result\n    }\n\n    fn squeeze_zq(\u0026mut self, output_length: usize) -\u003e Vec\u003cZq\u003e {\n        let mut reader = self.hasher.clone().finalize_xof();\n        let mut output_buffer = vec![u8::default(); output_length * 4];\n        reader.read(\u0026mut output_buffer);\n\n        let zq_values: Vec\u003cZq\u003e = output_buffer\n            .chunks_exact(4)\n            .map(|chunk| {\n                u32::from_le_bytes(chunk.try_into().expect(\"Could not convert 4 u8 to one u32\"))\n            })\n            .map(Zq::new)\n            .collect();\n\n        self.absorb_zq(\u0026zq_values);\n        zq_values\n    }\n\n    fn squeeze_rq(\u0026mut self, output_length: usize) -\u003e Vec\u003cRq\u003e {\n        let mut reader = self.hasher.clone().finalize_xof();\n        let mut output_buffer = vec![u8::default(); output_length * Rq::DEGREE * 4];\n        reader.read(\u0026mut output_buffer);\n\n        let zq_values: Vec\u003cZq\u003e = output_buffer\n            .chunks_exact(4)\n            .map(|chunk| {\n                u32::from_le_bytes(chunk.try_into().expect(\"Could not convert 4 u8 to one u32\"))\n            })\n            .map(Zq::new)\n            .collect();\n\n        let result: Vec\u003cRq\u003e = zq_values\n            .chunks_exact(Rq::DEGREE)\n            .map(|chunk| {\n                let rq_input: [Zq; Rq::DEGREE] =\n                    chunk.try_into().expect(\"Chunk size is Rq::DEGREE\");\n                Rq::new(rq_input)\n            })\n            .collect();\n\n        self.absorb_rq(\u0026result);\n        result\n    }\n\n    fn squeeze_bytes(\u0026mut self, byte_length: usize) -\u003e Vec\u003cu8\u003e {\n        let mut reader = self.hasher.clone().finalize_xof();\n        let mut output_buffer = vec![u8::default(); byte_length];\n        reader.read(\u0026mut output_buffer);\n        self.hasher.update(\u0026output_buffer);\n        output_buffer\n    }\n}\n\n#[cfg(test)]\nmod test_sponge_correctness {\n    use super::*;\n    use crate::ring::zq::UniformZq;\n    use rand::{distr::uniform::UniformSampler, rng};\n\n    fn random_zq_vector(n: usize) -\u003e Vec\u003cZq\u003e {\n        let uniform = UniformZq::new_inclusive(Zq::ZERO, Zq::NEG_ONE).unwrap();\n        (0..n).map(|_| uniform.sample(\u0026mut rng())).collect()\n    }\n\n    #[test]\n    fn test_zq_sponge_execution() {\n        let mut sponge = ShakeSponge::default();\n        let polynomial_1 = Rq::new([Zq::new(2); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(5); Rq::DEGREE]);\n        let polynomial_3 = Rq::new([Zq::new(1); Rq::DEGREE]);\n\n        sponge.absorb_rq(\u0026[polynomial_1, polynomial_2, polynomial_3]);\n        let result = sponge.squeeze_rq(1);\n        assert_eq!(result.len(), 1);\n    }\n\n    #[test]\n    fn test_rq_sponge_execution() {\n        let mut sponge = ShakeSponge::default();\n        let input: Vec\u003cZq\u003e = random_zq_vector(64);\n        sponge.absorb_zq(\u0026input);\n        let result = sponge.squeeze_rq(1);\n        assert_eq!(result.len(), 1);\n    }\n\n    #[test]\n    fn test_zq_squeeze_output_size() {\n        let mut sponge = ShakeSponge::default();\n        let input: Vec\u003cZq\u003e = random_zq_vector(64);\n        sponge.absorb_zq(\u0026input);\n        let result = sponge.squeeze_zq(1000);\n        assert_eq!(result.len(), 1000);\n    }\n\n    #[test]\n    fn test_rq_squeeze_output_size() {\n        let mut sponge = ShakeSponge::default();\n        let polynomial_1 = Rq::new([Zq::new(2); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(5); Rq::DEGREE]);\n        let polynomial_3 = Rq::new([Zq::new(1); Rq::DEGREE]);\n\n        sponge.absorb_rq(\u0026[polynomial_1, polynomial_2, polynomial_3]);\n        let result = sponge.squeeze_rq(1000);\n        assert_eq!(result.len(), 1000);\n    }\n\n    #[test]\n    fn test_absorb_zq_is_deterministic() {\n        let input: Vec\u003cZq\u003e = random_zq_vector(64);\n        let mut s1 = ShakeSponge::default();\n        let mut s2 = ShakeSponge::default();\n        s1.absorb_zq(\u0026input);\n        s2.absorb_zq(\u0026input);\n        let out1 = s1.squeeze_zq(8);\n        let out2 = s2.squeeze_zq(8);\n        assert_eq!(out1, out2);\n    }\n\n    #[test]\n    fn test_absorb_rq_is_deterministic() {\n        let polynomial_1 = Rq::new([Zq::new(54821); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(2131213); Rq::DEGREE]);\n        let polynomial_3 = Rq::new([Zq::new(9891741); Rq::DEGREE]);\n\n        let mut sponge1 = ShakeSponge::default();\n        sponge1.absorb_rq(\u0026[\n            polynomial_1.clone(),\n            polynomial_2.clone(),\n            polynomial_3.clone(),\n        ]);\n\n        let mut sponge2 = ShakeSponge::default();\n        sponge2.absorb_rq(\u0026[polynomial_1, polynomial_2, polynomial_3]);\n        assert_eq!(sponge1.squeeze_rq(1), sponge2.squeeze_rq(1))\n    }\n\n    #[test]\n    fn test_zq_successive_squeezes_is_unique() {\n        let mut s = ShakeSponge::default();\n        let input: Vec\u003cZq\u003e = random_zq_vector(32);\n        s.absorb_zq(\u0026input);\n        let o1 = s.squeeze_zq(8);\n        let o2 = s.squeeze_zq(8);\n        assert_ne!(o1, o2);\n    }\n\n    #[test]\n    fn test_rq_successive_squeezes_is_unique() {\n        let polynomial_1 = Rq::new([Zq::new(54821); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(2131213); Rq::DEGREE]);\n\n        let mut sponge = ShakeSponge::default();\n        sponge.absorb_rq(\u0026[polynomial_1, polynomial_2]);\n        let result1 = sponge.squeeze_rq(1);\n        let result2 = sponge.squeeze_rq(1);\n        assert_ne!(result1, result2)\n    }\n\n    #[test]\n    fn test_zq_output_can_be_large() {\n        let mut s = ShakeSponge::default();\n        let input: Vec\u003cZq\u003e = random_zq_vector(16);\n        s.absorb_zq(\u0026input);\n        let out = s.squeeze_zq(1000);\n        assert_eq!(out.len(), 1000);\n    }\n\n    #[test]\n    fn test_rq_output_can_be_large() {\n        let polynomial_1 = Rq::new([Zq::new(54821); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(2131213); Rq::DEGREE]);\n\n        let mut sponge = ShakeSponge::default();\n        sponge.absorb_rq(\u0026[polynomial_1, polynomial_2]);\n\n        assert_eq!(sponge.squeeze_rq(1000).len(), 1000);\n    }\n\n    #[test]\n    fn test_squeeze_message_order() {\n        let polynomial_1 = Rq::new([Zq::new(54821); Rq::DEGREE]);\n        let polynomial_2 = Rq::new([Zq::new(2131213); Rq::DEGREE]);\n\n        let mut sponge1 = ShakeSponge::default();\n        sponge1.absorb_rq(\u0026[polynomial_1.clone(), polynomial_2.clone()]);\n\n        let mut sponge2 = ShakeSponge::default();\n        sponge2.absorb_rq(\u0026[polynomial_2, polynomial_1]);\n        assert_ne!(sponge1.squeeze_rq(1), sponge2.squeeze_rq(1))\n    }\n\n    #[test]\n    fn test_different_inputs_diff_outputs() {\n        let input1: Vec\u003cZq\u003e = random_zq_vector(64);\n        let input2: Vec\u003cZq\u003e = random_zq_vector(64);\n        let mut s1 = ShakeSponge::default();\n        let mut s2 = ShakeSponge::default();\n        s1.absorb_zq(\u0026input1);\n        s2.absorb_zq(\u0026input2);\n        let o1 = s1.squeeze_zq(8);\n        let o2 = s2.squeeze_zq(8);\n        assert_ne!(o1, o2);\n    }\n\n    /// Edge case: zero‑length squeeze should not panic and must return empty vecs.\n    #[test]\n    fn zero_length_squeeze() {\n        let mut s = ShakeSponge::default();\n        assert!(s.squeeze_zq(0).is_empty());\n        assert!(s.squeeze_rq(0).is_empty());\n    }\n\n    #[test]\n    fn squeeze_bits_deterministic_and_length() {\n        let mut s1 = ShakeSponge::default();\n        let mut s2 = ShakeSponge::default();\n        s1.absorb_zq(\u0026[Zq::new(41)]);\n        s2.absorb_zq(\u0026[Zq::new(41)]);\n\n        let b1 = s1.squeeze_bits(123);\n        let b2 = s2.squeeze_bits(123);\n        assert_eq!(b1, b2); // deterministic\n        assert_eq!(b1.len(), 123); // exact length\n    }\n}\n\n#[cfg(test)]\nmod test_sponge_randomness {\n    // We should test squeeze outputs are random-looking\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":30}},{"line":16,"address":[],"length":0,"stats":{"Line":30}},{"line":19,"address":[],"length":0,"stats":{"Line":50}},{"line":21,"address":[],"length":0,"stats":{"Line":50}},{"line":22,"address":[],"length":0,"stats":{"Line":40328174}},{"line":25,"address":[],"length":0,"stats":{"Line":50}},{"line":28,"address":[],"length":0,"stats":{"Line":36}},{"line":30,"address":[],"length":0,"stats":{"Line":36}},{"line":31,"address":[],"length":0,"stats":{"Line":4272}},{"line":32,"address":[],"length":0,"stats":{"Line":135552}},{"line":36,"address":[],"length":0,"stats":{"Line":36}},{"line":39,"address":[],"length":0,"stats":{"Line":149}},{"line":40,"address":[],"length":0,"stats":{"Line":149}},{"line":41,"address":[],"length":0,"stats":{"Line":149}},{"line":42,"address":[],"length":0,"stats":{"Line":149}},{"line":43,"address":[],"length":0,"stats":{"Line":149}},{"line":45,"address":[],"length":0,"stats":{"Line":149}},{"line":46,"address":[],"length":0,"stats":{"Line":1977}},{"line":48,"address":[],"length":0,"stats":{"Line":7187}},{"line":49,"address":[],"length":0,"stats":{"Line":6422}},{"line":50,"address":[],"length":0,"stats":{"Line":149}},{"line":52,"address":[],"length":0,"stats":{"Line":6273}},{"line":53,"address":[],"length":0,"stats":{"Line":6273}},{"line":56,"address":[],"length":0,"stats":{"Line":149}},{"line":57,"address":[],"length":0,"stats":{"Line":149}},{"line":60,"address":[],"length":0,"stats":{"Line":37}},{"line":61,"address":[],"length":0,"stats":{"Line":37}},{"line":62,"address":[],"length":0,"stats":{"Line":37}},{"line":63,"address":[],"length":0,"stats":{"Line":37}},{"line":65,"address":[],"length":0,"stats":{"Line":37}},{"line":67,"address":[],"length":0,"stats":{"Line":20162897}},{"line":68,"address":[],"length":0,"stats":{"Line":20162860}},{"line":70,"address":[],"length":0,"stats":{"Line":37}},{"line":73,"address":[],"length":0,"stats":{"Line":37}},{"line":74,"address":[],"length":0,"stats":{"Line":37}},{"line":77,"address":[],"length":0,"stats":{"Line":18}},{"line":78,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":18}},{"line":80,"address":[],"length":0,"stats":{"Line":18}},{"line":82,"address":[],"length":0,"stats":{"Line":18}},{"line":84,"address":[],"length":0,"stats":{"Line":131538}},{"line":85,"address":[],"length":0,"stats":{"Line":131520}},{"line":87,"address":[],"length":0,"stats":{"Line":18}},{"line":90,"address":[],"length":0,"stats":{"Line":18}},{"line":91,"address":[],"length":0,"stats":{"Line":18}},{"line":92,"address":[],"length":0,"stats":{"Line":2073}},{"line":93,"address":[],"length":0,"stats":{"Line":2055}},{"line":94,"address":[],"length":0,"stats":{"Line":2055}},{"line":95,"address":[],"length":0,"stats":{"Line":2055}},{"line":99,"address":[],"length":0,"stats":{"Line":18}},{"line":100,"address":[],"length":0,"stats":{"Line":18}},{"line":103,"address":[],"length":0,"stats":{"Line":9261}},{"line":104,"address":[],"length":0,"stats":{"Line":9261}},{"line":105,"address":[],"length":0,"stats":{"Line":9261}},{"line":106,"address":[],"length":0,"stats":{"Line":9261}},{"line":107,"address":[],"length":0,"stats":{"Line":9261}},{"line":108,"address":[],"length":0,"stats":{"Line":9261}}],"covered":57,"coverable":57},{"path":["/","Users","omibo","Documents","Nethermind","condor-rs","labrador","src","verifier.rs"],"content":"#![allow(clippy::result_large_err)]\n\nuse thiserror::Error;\n\nuse crate::commitments::common_instances::AjtaiInstances;\nuse crate::commitments::outer_commitments::{self, DecompositionParameters};\nuse crate::core::aggregate::{FunctionsAggregation, ZeroConstantFunctionsAggregation};\nuse crate::core::inner_product;\nuse crate::relation::env_params;\nuse crate::relation::{env_params::EnvironmentParameters, statement::Statement};\nuse crate::ring::rq::Rq;\nuse crate::ring::rq_matrix::RqMatrix;\nuse crate::ring::rq_vector::RqVector;\nuse crate::ring::zq::Zq;\nuse crate::transcript::{LabradorTranscript, Sponge};\n\n#[derive(Debug, Error)]\npub enum VerifierError {\n    #[error(\"matrix not symmetric at ({i},{j}): expected {expected:?}, found {found:?}\")]\n    NotSymmetric {\n        i: usize,\n        j: usize,\n        expected: Rq,\n        found: Rq,\n    },\n    #[error(\"B0 mismatch at index {index}: expected {expected}, computed {computed}\")]\n    B0Mismatch {\n        index: usize,\n        expected: Zq,\n        computed: Zq,\n    },\n    #[error(\"‖z‖² = {norm} exceeds allowed bound {allowed}\")]\n    NormSumExceeded { norm: Zq, allowed: Zq },\n    #[error(\"A·z check failed: expected {expected:?}, computed {computed:?}\")]\n    AzError {\n        computed: RqVector,\n        expected: RqVector,\n    },\n    #[error(\"⟨z,z⟩ mismatch: expected {expected:?}, computed {computed:?}\")]\n    ZInnerError { computed: Rq, expected: Rq },\n    #[error(\"φ(z) mismatch: expected {expected:?}, computed {computed:?}\")]\n    PhiError { computed: Rq, expected: Rq },\n    #[error(\"relation check failed\")]\n    RelationCheckFailed,\n    #[error(\"outer commitment mismatch: expected {expected:?}, computed {computed:?}\")]\n    OuterCommitError {\n        computed: RqVector,\n        expected: RqVector,\n    },\n    #[error(transparent)]\n    DecompositionError(#[from] outer_commitments::DecompositionError),\n}\npub struct LabradorVerifier\u003c'a\u003e {\n    params: \u0026'a EnvironmentParameters,\n    crs: \u0026'a AjtaiInstances,\n    st: \u0026'a Statement,\n    // Aggregation instances\n    constant_aggregator: ZeroConstantFunctionsAggregation\u003c'a\u003e,\n    funcs_aggregator: FunctionsAggregation\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e LabradorVerifier\u003c'a\u003e {\n    pub fn new(\n        params: \u0026'a EnvironmentParameters,\n        crs: \u0026'a AjtaiInstances,\n        st: \u0026'a Statement,\n    ) -\u003e Self {\n        Self {\n            params,\n            crs,\n            st,\n            constant_aggregator: ZeroConstantFunctionsAggregation::new(params),\n            funcs_aggregator: FunctionsAggregation::new(params),\n        }\n    }\n\n    /// All check conditions are from page 18\n    pub fn verify\u003cS: Sponge\u003e(\n        \u0026mut self,\n        proof: \u0026LabradorTranscript\u003cS\u003e,\n    ) -\u003e Result\u003cbool, VerifierError\u003e {\n        let mut transcript = LabradorTranscript::new(S::default());\n\n        transcript.absorb_u1(\u0026proof.u1);\n        let projections = transcript.generate_projections(\n            env_params::SECURITY_PARAMETER,\n            self.params.rank,\n            self.params.multiplicity,\n        );\n        transcript.absorb_vector_p(\u0026proof.vector_p);\n        let size_of_psi = usize::div_ceil(env_params::SECURITY_PARAMETER, self.params.log_q);\n        let size_of_omega = size_of_psi;\n        let psi = transcript.generate_vector_psi(size_of_psi, self.params.constraint_l);\n        let omega = transcript.generate_vector_omega(size_of_omega, env_params::SECURITY_PARAMETER);\n        transcript.absorb_vector_b_ct_aggr(\u0026proof.b_ct_aggr);\n        let vector_alpha = transcript.generate_rq_vector(self.params.constraint_k);\n        let size_of_beta = size_of_psi;\n        let vector_beta = transcript.generate_rq_vector(size_of_beta);\n        transcript.absorb_u2(\u0026proof.u2);\n        let challenges =\n            transcript.generate_challenges(env_params::OPERATOR_NORM, self.params.multiplicity);\n\n        // check b_0^{''(k)} ?= \u003comega^(k),p\u003e + \\sum(psi_l^(k) * b_0^{'(l)})\n        Self::check_b_0_aggr(self, proof, self.params, \u0026psi, \u0026omega)?;\n\n        // 3. line 14: check norm_sum(z, t, g, h) \u003c= (beta')^2\n\n        // decompose z into z = z^(0) + z^(1) * b, only two parts.\n        let z_ij = RqVector::decompose(\u0026proof.z, self.params.b, 2);\n        let t_ij: Vec\u003cVec\u003cRqVector\u003e\u003e = proof\n            .t\n            .get_elements()\n            .iter()\n            .map(|i| RqVector::decompose(i, self.params.b, self.params.t_1))\n            .collect();\n        let g_ij: Vec\u003cVec\u003cRqVector\u003e\u003e = proof\n            .g\n            .get_elements()\n            .iter()\n            .map(|i| RqVector::decompose(i, self.params.b, self.params.t_2))\n            .collect();\n        let h_ij: Vec\u003cVec\u003cRqVector\u003e\u003e = proof\n            .h\n            .get_elements()\n            .iter()\n            .map(|i| RqVector::decompose(i, self.params.b, self.params.t_1))\n            .collect();\n        let norm_z_ij = z_ij\n            .iter()\n            .fold(Zq::ZERO, |acc, p| acc + p.l2_norm_squared());\n        let norm_t_ij = Self::norm_squared(\u0026t_ij);\n        let norm_g_ij = Self::norm_squared(\u0026g_ij);\n        let norm_h_ij = Self::norm_squared(\u0026h_ij);\n        let norm_sum = norm_z_ij + norm_t_ij + norm_g_ij + norm_h_ij;\n\n        if norm_sum \u003e self.params.beta * self.params.beta {\n            return Err(VerifierError::NormSumExceeded {\n                norm: norm_sum,\n                allowed: self.params.beta * self.params.beta,\n            });\n        }\n\n        // 4. line 15: check Az ?= c_1 * t_1 + ... + c_r * t_r\n        let az = self.crs.commitment_scheme_a.matrix() * \u0026proof.z;\n        let ct_sum = inner_product::compute_linear_combination(\n            proof.t.get_elements(),\n            challenges.get_elements(),\n        );\n        if az != ct_sum {\n            return Err(VerifierError::AzError {\n                computed: az,\n                expected: ct_sum,\n            });\n        }\n\n        // 5. lne 16: check \u003cz, z\u003e ?= \\sum(g_ij * c_i * c_j)\n\n        let z_inner = inner_product::compute_linear_combination(\n            proof.z.get_elements(),\n            proof.z.get_elements(),\n        );\n        let sum_gij_cij = Self::calculate_gh_ci_cj(\u0026proof.g, \u0026challenges, self.params.multiplicity);\n\n        if z_inner != sum_gij_cij {\n            return Err(VerifierError::ZInnerError {\n                computed: z_inner,\n                expected: sum_gij_cij,\n            });\n        }\n\n        // 6. line 17: check \\sum(\u003c\\phi_i, z\u003ec_i) ?= \\sum(h_ij * c_i * c_j)\n        self.constant_aggregator.calculate_agg_phi_double_prime(\n            \u0026self.st.phi_ct,\n            \u0026projections.get_conjugated_projection_matrices(),\n            \u0026psi,\n            \u0026omega,\n        );\n        self.funcs_aggregator.calculate_aggr_phi(\n            \u0026self.st.phi_constraint,\n            self.constant_aggregator.get_phi_double_prime(),\n            \u0026vector_alpha,\n            \u0026vector_beta,\n        );\n        let sum_phi_z_c =\n            Self::calculate_phi_z_c(self.funcs_aggregator.get_appr_phi(), \u0026challenges, \u0026proof.z);\n        let sum_hij_cij = Self::calculate_gh_ci_cj(\u0026proof.h, \u0026challenges, self.params.multiplicity);\n\n        // Left side multiple by 2 because of when we calculate h_ij, we didn't apply the division (divided by 2)\n        if \u0026sum_phi_z_c * \u0026Zq::TWO != sum_hij_cij {\n            return Err(VerifierError::PhiError {\n                computed: \u0026sum_phi_z_c * \u0026Zq::TWO,\n                expected: sum_hij_cij,\n            });\n        }\n\n        // 7. line 18: check \\sum(a_ij * g_ij) + \\sum(h_ii) - b ?= 0\n\n        self.constant_aggregator\n            .calculate_agg_a_double_prime(\u0026psi, \u0026self.st.a_ct);\n        self.funcs_aggregator.calculate_agg_a(\n            \u0026self.st.a_constraint,\n            self.constant_aggregator.get_alpha_double_prime(),\n            \u0026vector_alpha,\n            \u0026vector_beta,\n        );\n\n        self.funcs_aggregator.calculate_aggr_b(\n            \u0026self.st.b_constraint,\n            \u0026proof.b_ct_aggr,\n            \u0026vector_alpha,\n            \u0026vector_beta,\n        );\n\n        if !Self::check_relation(\n            self.funcs_aggregator.get_agg_a(),\n            self.funcs_aggregator.get_aggr_b(),\n            \u0026proof.g,\n            \u0026proof.h,\n        ) {\n            return Err(VerifierError::RelationCheckFailed);\n        }\n\n        // 8. line 19: u_1 ?= \\sum(\\sum(B_ik * t_i^(k))) + \\sum(\\sum(C_ijk * g_ij^(k)))\n\n        let u_1 = \u0026proof.u1;\n        let commitment_u1 = outer_commitments::compute_u1(\n            self.crs,\n            \u0026proof.t,\n            DecompositionParameters::new(self.params.b, self.params.t_1)?,\n            \u0026proof.g,\n            DecompositionParameters::new(self.params.b, self.params.t_2)?,\n        );\n\n        if proof.u1 != commitment_u1 {\n            return Err(VerifierError::OuterCommitError {\n                computed: u_1.clone(),\n                expected: commitment_u1,\n            });\n        }\n\n        // 9. line 20: u_2 ?= \\sum(\\sum(D_ijk * h_ij^(k)))\n        let commitment_u2 = outer_commitments::compute_u2(\n            self.crs,\n            \u0026proof.h,\n            DecompositionParameters::new(self.params.b, self.params.t_1)?,\n        );\n\n        if proof.u2 != commitment_u2 {\n            return Err(VerifierError::OuterCommitError {\n                computed: commitment_u2,\n                expected: proof.u2.clone(),\n            });\n        }\n\n        Ok(true)\n    }\n\n    /// calculate the right hand side of line 16 or line 17, \\sum(g_ij * c_i * c_j) or \\sum(h_ij * c_i * c_j)\n    fn calculate_gh_ci_cj(x_ij: \u0026RqMatrix, random_c: \u0026RqVector, r: usize) -\u003e Rq {\n        (0..r)\n            .map(|i| {\n                (0..r)\n                    .map(|j| {\n                        \u0026(x_ij.get_cell(i, j) * \u0026random_c.get_elements()[i])\n                            * \u0026random_c.get_elements()[j]\n                    })\n                    .fold(Rq::zero(), |acc, x| \u0026acc + \u0026x)\n            })\n            .fold(Rq::zero(), |acc, x| \u0026acc + \u0026x)\n    }\n\n    /// calculate the left hand side of line 17, \\sum(\u003c\\phi_z, z\u003e * c_i)\n    fn calculate_phi_z_c(phi: \u0026[RqVector], c: \u0026RqVector, z: \u0026RqVector) -\u003e Rq {\n        phi.iter()\n            .zip(c.get_elements())\n            .map(|(phi_i, c_i)| {\n                \u0026(inner_product::compute_linear_combination(phi_i.get_elements(), z.get_elements()))\n                    * c_i\n            })\n            .fold(Rq::zero(), |acc, x| \u0026acc + \u0026x)\n    }\n\n    fn norm_squared(polys: \u0026[Vec\u003cRqVector\u003e]) -\u003e Zq {\n        polys.iter().fold(Zq::ZERO, |acc, poly| {\n            acc + poly\n                .iter()\n                .fold(Zq::ZERO, |acc, p| acc + p.l2_norm_squared())\n        })\n    }\n\n    /// line 18, page 18: check if \\sum(a_{ij} * g_{ij}) + \\sum(h_{ii}) - b ?= 0\n    /// in the verifier process, page 18 from the paper.\n    ///\n    /// param: a_primes: a_{ij}^{''(k)}\n    /// param: b_primes: b^{''(k)}\n    /// param: g: g_{ij}\n    /// param: h: h_{ii}\n    ///\n    /// return: true if the relation holds, false otherwise\n    pub fn check_relation(a_primes: \u0026RqMatrix, b_primes: \u0026Rq, g: \u0026RqMatrix, h: \u0026RqMatrix) -\u003e bool {\n        let r = a_primes.get_elements().len();\n\n        let mut sum_a_primes_g = Rq::zero();\n        // walk only over the stored half: i ≤ j\n        for i in 0..r {\n            for j in 0..r {\n                sum_a_primes_g = \u0026sum_a_primes_g + \u0026(a_primes.get_cell(i, j) * g.get_cell(i, j));\n            }\n        }\n\n        let sum_h_ii = (0..r).fold(Rq::zero(), |acc, i| \u0026acc + h.get_cell(i, i));\n\n        let b_primes2 = b_primes * \u0026Zq::TWO;\n        let sum_a_primes_g2 = \u0026sum_a_primes_g * \u0026Zq::TWO;\n\n        \u0026sum_a_primes_g2 + \u0026sum_h_ii == b_primes2\n    }\n\n    fn check_b_0_aggr\u003cS: Sponge\u003e(\n        \u0026self,\n        proof: \u0026LabradorTranscript\u003cS\u003e,\n        ep: \u0026EnvironmentParameters,\n        psi: \u0026[Vec\u003cZq\u003e],\n        omega: \u0026[Vec\u003cZq\u003e],\n    ) -\u003e Result\u003cbool, VerifierError\u003e {\n        for k in 0..ep.kappa {\n            let b_0_poly = proof.b_ct_aggr.get_elements()[k].get_coefficients()[0];\n            let mut b_0: Zq = (0..ep.constraint_l)\n                .map(|l| psi[k][l] * self.st.b_0_ct[l])\n                .sum();\n\n            let inner_omega_p =\n                inner_product::compute_linear_combination(\u0026omega[k], \u0026proof.vector_p);\n            b_0 += inner_omega_p;\n            if b_0 != b_0_poly {\n                return Err(VerifierError::B0Mismatch {\n                    index: k,\n                    expected: b_0_poly,\n                    computed: b_0,\n                });\n            }\n        }\n\n        Ok(true)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::prover::LabradorProver;\n    use crate::relation::witness::Witness;\n    use crate::transcript::sponges::shake::ShakeSponge;\n\n    #[test]\n    fn test_verify() {\n        let ep_1 = EnvironmentParameters::default();\n        // generate a random witness based on ep above\n        let witness_1 = Witness::new(ep_1.rank, ep_1.multiplicity, ep_1.beta);\n        // generate public statements based on witness_1\n        let st: Statement = Statement::new(\u0026witness_1, \u0026ep_1);\n        // generate the common reference string matrices\n        let crs = AjtaiInstances::new(\u0026ep_1);\n\n        // create a new prover\n        let mut prover = LabradorProver::new(\u0026ep_1, \u0026crs, \u0026witness_1, \u0026st);\n        let proof: LabradorTranscript\u003cShakeSponge\u003e = prover.prove().unwrap();\n\n        // create a new verifier\n        let mut verifier = LabradorVerifier::new(\u0026ep_1, \u0026crs, \u0026st);\n        let result = verifier.verify(\u0026proof);\n        assert!(result.unwrap());\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":5}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":8}},{"line":242,"address":[],"length":0,"stats":{"Line":6}},{"line":243,"address":[],"length":0,"stats":{"Line":24}},{"line":244,"address":[],"length":0,"stats":{"Line":18}},{"line":245,"address":[],"length":0,"stats":{"Line":18}},{"line":247,"address":[],"length":0,"stats":{"Line":30}},{"line":249,"address":[],"length":0,"stats":{"Line":10}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":1}},{"line":256,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":260,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":3}},{"line":264,"address":[],"length":0,"stats":{"Line":12}},{"line":265,"address":[],"length":0,"stats":{"Line":9}},{"line":266,"address":[],"length":0,"stats":{"Line":9}},{"line":267,"address":[],"length":0,"stats":{"Line":42}},{"line":280,"address":[],"length":0,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":9}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":5}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":294,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":1}},{"line":299,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[],"length":0,"stats":{"Line":5}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":308,"address":[],"length":0,"stats":{"Line":4}},{"line":309,"address":[],"length":0,"stats":{"Line":28}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":314,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":1}}],"covered":114,"coverable":151}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>